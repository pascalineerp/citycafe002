
/************************************************************************
*  Filepath: /web/static/src/legacy/js/views/graph/graph_controller.js  *
*  Bundle: web.assets_backend_legacy_lazy                               *
*  Lines: 352                                                           *
************************************************************************/
odoo.define('web.GraphController', function (require) {
"use strict";

/*---------------------------------------------------------
 * Odoo Graph view
 *---------------------------------------------------------*/

const AbstractController = require('web.AbstractController');
const { ComponentWrapper } = require('web.OwlCompatibility');
const DropdownMenu = require('web.DropdownMenu');
const { DEFAULT_INTERVAL, INTERVAL_OPTIONS } = require('web.searchUtils');
const { qweb } = require('web.core');
const { _t } = require('web.core');

class CarretDropdownMenu extends DropdownMenu {
    /**
     * @override
     */
    get displayCaret() {
        return true;
    }
}

var GraphController = AbstractController.extend({
    custom_events: _.extend({}, AbstractController.prototype.custom_events, {
        item_selected: '_onItemSelected',
        open_view: '_onOpenView',
    }),

    /**
     * @override
     * @param {Widget} parent
     * @param {GraphModel} model
     * @param {GraphRenderer} renderer
     * @param {Object} params
     * @param {string[]} params.measures
     * @param {boolean} params.isEmbedded
     * @param {string[]} params.groupableFields,
     */
    init: function (parent, model, renderer, params) {
        this._super.apply(this, arguments);
        this.measures = params.measures;
        // this parameter condition the appearance of a 'Group By'
        // button in the control panel owned by the graph view.
        this.isEmbedded = params.isEmbedded;
        this.withButtons = params.withButtons;
        // views to use in the action triggered when the graph is clicked
        this.views = params.views;
        this.title = params.title;

        // this parameter determines what is the list of fields
        // that may be used within the groupby menu available when
        // the view is embedded
        this.groupableFields = params.groupableFields;
        this.buttonDropdownPromises = [];
    },
    /**
     * @todo check if this can be removed (mostly duplicate with
     * AbstractController method)
     */
    destroy: function () {
        if (this.$buttons) {
            // remove jquery's tooltip() handlers
            this.$buttons.find('button').off().tooltip('dispose');
        }
        this._super.apply(this, arguments);
    },

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    /**
     * Returns the current mode, measure and groupbys, so we can restore the
     * view when we save the current state in the search view, or when we add it
     * to the dashboard.
     *
     * @override
     * @returns {Object}
     */
    getOwnedQueryParams: function () {
        var state = this.model.get();
        return {
            context: {
                graph_measure: state.measure,
                graph_mode: state.mode,
                graph_groupbys: state.groupBy,
            }
        };
    },
    /**
     * @override
     */
    reload: async function () {
        const promises = [this._super(...arguments)];
        if (this.withButtons) {
            const state = this.model.get();
            this.measures.forEach(m => m.isActive = m.fieldName === state.measure);
            promises.push(this.measureMenu.update({ items: this.measures }));
        }
        return Promise.all(promises);
    },
    /**
     * Render the buttons according to the GraphView.buttons and
     * add listeners on it.
     * Set this.$buttons with the produced jQuery element
     *
     * @param {jQuery} [$node] a jQuery node where the rendered buttons should
     * be inserted $node may be undefined, in which case the GraphView does
     * nothing
     */
    renderButtons: function ($node) {
        this.$buttons = $(qweb.render('GraphView.buttons'));
        this.$buttons.find('button').tooltip();
        this.$buttons.click(ev => this._onButtonClick(ev));

        if (this.withButtons) {
            const state = this.model.get();
            const fragment = document.createDocumentFragment();
            // Instantiate and append MeasureMenu
            this.measures.forEach(m => m.isActive = m.fieldName === state.measure);
            this.measureMenu = new ComponentWrapper(this, CarretDropdownMenu, {
                title: _t("Measures"),
                items: this.measures,
            });
            this.buttonDropdownPromises = [this.measureMenu.mount(fragment)];
            if (this.isEmbedded) {
                // Instantiate and append GroupBy menu
                this.groupByMenu = new ComponentWrapper(this, CarretDropdownMenu, {
                    title: _t("Group By"),
                    icon: 'fa fa-bars',
                    items: this._getGroupBys(state.groupBy),
                });
                this.buttonDropdownPromises.push(this.groupByMenu.mount(fragment));
            }
            if ($node) {
                this.$buttons.appendTo($node);
            }
        }
    },
    /**
     * Makes sure that the buttons in the control panel matches the current
     * state (so, correct active buttons and stuff like that).
     *
     * @override
     */
    updateButtons: function () {
        if (!this.$buttons) {
            return;
        }
        var state = this.model.get();
        this.$buttons.find('.o_graph_button').removeClass('active');
        this.$buttons
            .find('.o_graph_button[data-mode="' + state.mode + '"]')
            .addClass('active');
        this.$buttons
            .find('.o_graph_button[data-mode="stack"]')
            .data('stacked', state.stacked)
            .toggleClass('active', state.stacked)
            .toggleClass('o_hidden', state.mode !== 'bar');
        this.$buttons
            .find('.o_graph_button[data-order]')
            .toggleClass('o_hidden', state.mode === 'pie' || !!Object.keys(state.timeRanges).length)
            .filter('.o_graph_button[data-order="' + state.orderBy + '"]')
            .toggleClass('active', !!state.orderBy);

        if (this.withButtons) {
            return this._attachDropdownComponents();
        }
    },

    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------

    /**
     * Attaches the different dropdown components to the buttons container.
     *
     * @returns {Promise}
     */
    async _attachDropdownComponents() {
        await Promise.all(this.buttonDropdownPromises);
        if (this.isDestroyed()) {
            return;
        }
        const actionsContainer = this.$buttons[0];
        // Attach "measures" button
        actionsContainer.appendChild(this.measureMenu.el);
        this.measureMenu.el.classList.add('o_graph_measures_list');
        if (this.isEmbedded) {
            // Attach "groupby" button
            actionsContainer.appendChild(this.groupByMenu.el);
            this.groupByMenu.el.classList.add('o_group_by_menu');
        }
        // Update button classes accordingly to the current mode
        const buttons = actionsContainer.querySelectorAll('.dropdown-toggle');
        for (const button of buttons) {
            button.classList.remove('btn-secondary');
            if (this.isEmbedded) {
                button.classList.add('btn-outline-secondary');
            } else {
                button.classList.add('btn-primary');
                button.tabIndex = 0;
            }
        }
    },

    /**
     * Returns the items used by the Group By menu in embedded mode.
     *
     * @private
     * @param {string[]} activeGroupBys
     * @returns {Object[]}
     */
    _getGroupBys(activeGroupBys) {
        const normalizedGroupBys = this._normalizeActiveGroupBys(activeGroupBys);
        const groupBys = Object.keys(this.groupableFields).map(fieldName => {
            const field = this.groupableFields[fieldName];
            const groupByActivity = normalizedGroupBys.filter(gb => gb.fieldName === fieldName);
            const groupBy = {
                id: fieldName,
                isActive: Boolean(groupByActivity.length),
                description: field.string,
                itemType: 'groupBy',
            };
            if (['date', 'datetime'].includes(field.type)) {
                groupBy.hasOptions = true;
                const activeOptionIds = groupByActivity.map(gb => gb.interval);
                groupBy.options = Object.values(INTERVAL_OPTIONS).map(o => {
                    return Object.assign({}, o, { isActive: activeOptionIds.includes(o.id) });
                });
            }
            return groupBy;
        }).sort((gb1, gb2) => {
            return gb1.description.localeCompare(gb2.description);
        });
        return groupBys;
    },

    /**
     * This method puts the active groupBys in a convenient form.
     *
     * @private
     * @param {string[]} activeGroupBys
     * @returns {Object[]} normalizedGroupBys
     */
    _normalizeActiveGroupBys(activeGroupBys) {
        return activeGroupBys.map(groupBy => {
            const fieldName = groupBy.split(':')[0];
            const field = this.groupableFields[fieldName];
            const normalizedGroupBy = { fieldName };
            if (['date', 'datetime'].includes(field.type)) {
                normalizedGroupBy.interval = groupBy.split(':')[1] || DEFAULT_INTERVAL;
            }
            return normalizedGroupBy;
        });
    },

    //--------------------------------------------------------------------------
    // Handlers
    //--------------------------------------------------------------------------

    /**
     * Do what need to be done when a button from the control panel is clicked.
     *
     * @private
     * @param {MouseEvent} ev
     */
    _onButtonClick: function (ev) {
        var $target = $(ev.target);
        if ($target.hasClass('o_graph_button')) {
            if (_.contains(['bar','line', 'pie'], $target.data('mode'))) {
                this.update({ mode: $target.data('mode') });
            } else if ($target.data('mode') === 'stack') {
                this.update({ stacked: !$target.data('stacked') });
            } else if (['asc', 'desc'].includes($target.data('order'))) {
                const order = $target.data('order');
                const state = this.model.get();
                this.update({ orderBy: state.orderBy === order ? false : order });
            }
        }
    },

    /**
     * @private
     * @param {OdooEvent} ev
     */
    _onItemSelected(ev) {
        const item = ev.data.item;
        if (this.isEmbedded && item.itemType === 'groupBy') {
            const fieldName = item.id;
            const optionId = ev.data.option && ev.data.option.id;
            const activeGroupBys = this.model.get().groupBy;
            if (optionId) {
                const normalizedGroupBys = this._normalizeActiveGroupBys(activeGroupBys);
                const index = normalizedGroupBys.findIndex(ngb =>
                    ngb.fieldName === fieldName && ngb.interval === optionId);
                if (index === -1) {
                    activeGroupBys.push(fieldName + ':' + optionId);
                } else {
                    activeGroupBys.splice(index, 1);
                }
            } else {
                const groupByFieldNames = activeGroupBys.map(gb => gb.split(':')[0]);
                const indexOfGroupby = groupByFieldNames.indexOf(fieldName);
                if (indexOfGroupby === -1) {
                    activeGroupBys.push(fieldName);
                } else {
                    activeGroupBys.splice(indexOfGroupby, 1);
                }
            }
            this.update({ groupBy: activeGroupBys });
            this.groupByMenu.update({
                items: this._getGroupBys(activeGroupBys),
            });
        } else if (item.itemType === 'measure') {
            this.update({ measure: item.fieldName });
            this.measures.forEach(m => m.isActive = m.fieldName === item.fieldName);
            this.measureMenu.update({ items: this.measures });
        }
    },

    /**
     * @private
     * @param {OdooEvent} ev
     * @param {Array[]} ev.data.domain
     */
    _onOpenView(ev) {
        ev.stopPropagation();
        const state = this.model.get();
        const context = Object.assign({}, state.context);
        Object.keys(context).forEach(x => {
            if (x === 'group_by' || x.startsWith('search_default_')) {
                delete context[x];
            }
        });
        this.do_action({
            context: context,
            domain: ev.data.domain,
            name: this.title,
            res_model: this.modelName,
            target: 'current',
            type: 'ir.actions.act_window',
            view_mode: 'list',
            views: this.views,
        });
    },
});

return GraphController;

});
;

/*******************************************************************
*  Filepath: /web/static/src/legacy/js/views/graph/graph_model.js  *
*  Bundle: web.assets_backend_legacy_lazy                          *
*  Lines: 331                                                      *
*******************************************************************/
odoo.define('web.GraphModel', function (require) {
"use strict";

var core = require('web.core');
const { DEFAULT_INTERVAL, rankInterval } = require('web.searchUtils');

var _t = core._t;

/**
 * The graph model is responsible for fetching and processing data from the
 * server.  It basically just do a(some) read_group(s) and format/normalize data.
 */
var AbstractModel = require('web.AbstractModel');

return AbstractModel.extend({
    /**
     * @override
     * @param {Widget} parent
     */
    init: function () {
        this._super.apply(this, arguments);
        this.chart = null;
    },

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    /**
     *
     * We defend against outside modifications by extending the chart data. It
     * may be overkill.
     *
     * @override
     * @returns {Object}
     */
    __get: function () {
        return Object.assign({ isSample: this.isSampleModel }, this.chart);
    },
    /**
     * Initial loading.
     *
     * @todo All the work to fall back on the graph_groupbys keys in the context
     * should be done by the graphView I think.
     *
     * @param {Object} params
     * @param {Object} params.context
     * @param {Object} params.fields
     * @param {string[]} params.domain
     * @param {string[]} params.groupBys a list of valid field names
     * @param {string[]} params.groupedBy a list of valid field names
     * @param {boolean} params.stacked
     * @param {string} params.measure a valid field name
     * @param {'pie'|'bar'|'line'} params.mode
     * @param {string} params.modelName
     * @param {Object} params.timeRanges
     * @returns {Promise} The promise does not return a handle, we don't need
     *   to keep track of various entities.
     */
    __load: function (params) {
        var groupBys = params.context.graph_groupbys || params.groupBys;
        this.initialGroupBys = groupBys;
        this.fields = params.fields;
        this.modelName = params.modelName;
        this.chart = Object.assign({
            context: params.context,
            dataPoints: [],
            domain: params.domain,
            groupBy: params.groupedBy.length ? params.groupedBy : groupBys,
            measure: params.context.graph_measure || params.measure,
            mode: params.context.graph_mode || params.mode,
            origins: [],
            stacked: params.stacked,
            timeRanges: params.timeRanges,
            orderBy: params.orderBy
        });

        if (this.chart.measure === "__count") {
            this.chart.measure = "__count__";
        }

        this._computeDerivedParams();

        return this._loadGraph();
    },
    /**
     * Reload data.  It is similar to the load function. Note that we ignore the
     * handle parameter, we always expect our data to be in this.chart object.
     *
     * @todo This method takes 'groupBy' and load method takes 'groupedBy'. This
     *   is insane.
     *
     * @param {any} handle ignored!
     * @param {Object} params
     * @param {boolean} [params.stacked]
     * @param {Object} [params.context]
     * @param {string[]} [params.domain]
     * @param {string[]} [params.groupBy]
     * @param {string} [params.measure] a valid field name
     * @param {string} [params.mode] one of 'bar', 'pie', 'line'
     * @param {Object} [params.timeRanges]
     * @returns {Promise}
     */
    __reload: function (handle, params) {
        if ('context' in params) {
            this.chart.context = params.context;
            this.chart.groupBy = params.context.graph_groupbys || this.chart.groupBy;
            this.chart.measure = params.context.graph_measure || this.chart.measure;
            this.chart.mode = params.context.graph_mode || this.chart.mode;
        }
        if ('domain' in params) {
            this.chart.domain = params.domain;
        }
        if ('groupBy' in params) {
            this.chart.groupBy = params.groupBy.length ? params.groupBy : this.initialGroupBys;
        }
        if ('measure' in params) {
            this.chart.measure = params.measure;
        }
        if ('timeRanges' in params) {
            this.chart.timeRanges = params.timeRanges;
        }

        if (this.chart.measure === "__count") {
            this.chart.measure = "__count__";
        }

        this._computeDerivedParams();

        if ('mode' in params) {
            this.chart.mode = params.mode;
            return Promise.resolve();
        }
        if ('stacked' in params) {
            this.chart.stacked = params.stacked;
            return Promise.resolve();
        }
        if ('orderBy' in params) {
            this.chart.orderBy = params.orderBy;
            return Promise.resolve();
        }
        return this._loadGraph();
    },

    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------

    /**
     * Compute this.chart.processedGroupBy, this.chart.domains, this.chart.origins,
     * and this.chart.comparisonFieldIndex.
     * Those parameters are determined by this.chart.timeRanges, this.chart.groupBy, and this.chart.domain.
     *
     * @private
     */
    _computeDerivedParams: function () {
        this.chart.processedGroupBy = this._processGroupBy(this.chart.groupBy);

        const { range, rangeDescription, comparisonRange, comparisonRangeDescription, fieldName } = this.chart.timeRanges;
        if (range) {
            this.chart.domains = [
                this.chart.domain.concat(range),
                this.chart.domain.concat(comparisonRange),
            ];
            this.chart.origins = [rangeDescription, comparisonRangeDescription];
            const groupBys = this.chart.processedGroupBy.map(function (gb) {
                return gb.split(":")[0];
            });
            this.chart.comparisonFieldIndex = groupBys.indexOf(fieldName);
        } else {
            this.chart.domains = [this.chart.domain];
            this.chart.origins = [""];
            this.chart.comparisonFieldIndex = -1;
        }
    },
    /**
     * @override
     */
    _isEmpty() {
        return this.chart.dataPoints.length === 0;
    },
    /**
     * Fetch and process graph data.  It is basically a(some) read_group(s)
     * with correct fields for each domain.  We have to do some light processing
     * to separate date groups in the field list, because they can be defined
     * with an aggregation function, such as my_date:week.
     *
     * @private
     * @returns {Promise}
     */
    _loadGraph: function () {
        var self = this;
        this.chart.dataPoints = [];
        var groupBy = this.chart.processedGroupBy;
        var fields = _.map(groupBy, function (groupBy) {
            return groupBy.split(':')[0];
        });
        const loadId = this.loadId ? ++this.loadId : 1;
        this.loadId = loadId;

        if (this.chart.measure !== '__count__') {
            if (this.fields[this.chart.measure].type === 'many2one') {
                fields = fields.concat(this.chart.measure + ":count_distinct");
            }
            else {
                fields = fields.concat(this.chart.measure);
            }
        }

        var context = _.extend({fill_temporal: true}, this.chart.context);

        var proms = [];
        this.chart.domains.forEach(function (domain, originIndex) {
            proms.push(self._rpc({
                model: self.modelName,
                method: 'read_group',
                context: context,
                domain: domain,
                fields: fields,
                groupBy: groupBy,
                lazy: false,
            }).then(self._processData.bind(self, originIndex, loadId)));
        });
        return Promise.all(proms);
    },
    /**
     * Since read_group is insane and returns its result on different keys
     * depending of some input, we have to normalize the result.
     * Each group coming from the read_group produces a dataPoint
     *
     * @private
     * @param {number} originIndex
     * @param {any} rawData result from the read_group
     */
    _processData: function (originIndex, loadId, rawData) {
        if (loadId < this.loadId) {
            return;
        }
        var self = this;
        var isCount = this.chart.measure === '__count__';
        var labels;

        function getLabels (dataPt) {
            return self.chart.processedGroupBy.map(function (field) {
                return self._sanitizeValue(dataPt[field], field.split(":")[0]);
            });
        }
        rawData.forEach(function (dataPt){
            labels = getLabels(dataPt);
            var count = dataPt.__count || dataPt[self.chart.processedGroupBy[0]+'_count'] || 0;
            var value = isCount ? count : dataPt[self.chart.measure];
            if (value instanceof Array) {
                // when a many2one field is used as a measure AND as a grouped
                // field, bad things happen.  The server will only return the
                // grouped value and will not aggregate it.  Since there is a
                // name clash, we are then in the situation where this value is
                // an array.  Fortunately, if we group by a field, then we can
                // say for certain that the group contains exactly one distinct
                // value for that field.
                value = 1;
            }
            self.chart.dataPoints.push({
                resId: dataPt[self.chart.groupBy[0]] instanceof Array ? dataPt[self.chart.groupBy[0]][0] : -1,
                count: count,
                domain: dataPt.__domain,
                value: value,
                labels: labels,
                originIndex: originIndex,
            });
        });
    },
    /**
     * Process the groupBy parameter in order to keep only the finer interval option for
     * elements based on date/datetime field (e.g. 'date:year'). This means that
     * 'week' is prefered to 'month'. The field stays at the place of its first occurence.
     * For instance,
     * ['foo', 'date:month', 'bar', 'date:week'] becomes ['foo', 'date:week', 'bar'].
     *
     * @private
     * @param {string[]} groupBy
     * @returns {string[]}
     */
    _processGroupBy: function(groupBy) {
        const groupBysMap = new Map();
        for (const gb of groupBy) {
            let [fieldName, interval] = gb.split(':');
            const field = this.fields[fieldName];
            if (['date', 'datetime'].includes(field.type)) {
                interval = interval || DEFAULT_INTERVAL;
            }
            if (groupBysMap.has(fieldName)) {
                const registeredInterval = groupBysMap.get(fieldName);
                if (rankInterval(registeredInterval) < rankInterval(interval)) {
                    groupBysMap.set(fieldName, interval);
                }
            } else {
                groupBysMap.set(fieldName, interval);
            }
        }
        return [...groupBysMap].map(([fieldName, interval]) => {
            if (interval) {
                return `${fieldName}:${interval}`;
            }
            return fieldName;
        });
    },
    /**
     * Helper function (for _processData), turns various values in a usable
     * string form, that we can display in the interface.
     *
     * @private
     * @param {any} value value for the field fieldName received by the read_group rpc
     * @param {string} fieldName
     * @returns {string}
     */
    _sanitizeValue: function (value, fieldName) {
        if (value === false && this.fields[fieldName].type !== 'boolean') {
            return _t("Undefined");
        }
        if (value instanceof Array) {
            return value[1];
        }
        if (fieldName && (this.fields[fieldName].type === 'selection')) {
            var selected = _.where(this.fields[fieldName].selection, {0: value})[0];
            return selected ? selected[1] : value;
        }
        return value;
    },
});

});
;

/**********************************************************************
*  Filepath: /web/static/src/legacy/js/views/graph/graph_renderer.js  *
*  Bundle: web.assets_backend_legacy_lazy                             *
*  Lines: 999                                                         *
**********************************************************************/
odoo.define("web/static/src/js/views/graph/graph_renderer", function (require) {
    "use strict";

    const AbstractRenderer = require("web.AbstractRendererOwl");
    const { DateClasses } = require("web.dataComparisonUtils");
    const fieldUtils = require("web.field_utils");
    const { sortBy } = require("web.utils");

    const {
        COLORS,
        DEFAULT_BG,
        FORMAT_OPTIONS,
        MAX_LEGEND_LENGTH,
        getColor,
        getMaxWidth,
        hexToRGBA,
        shortenLabel,
    } = require("web/static/src/js/views/graph/graph_utils");

    const { useRef } = owl.hooks;
    class GraphRenderer extends AbstractRenderer {
        constructor() {
            super(...arguments);

            this.noDataLabel = [this.env._t("No data")];
            this.fakeDataLabel = [""];
            this.sampleDataTargets = [".o_graph_canvas_container"];
            this._processProps(this.props);

            this.canvasRef = useRef("canvas");
            this.containerRef = useRef("container");
        }

        async willUpdateProps(nextProps) {
            await super.willUpdateProps(...arguments);
            this._processProps(nextProps);
        }

        mounted() {
            super.mounted();
            this._renderChart();
        }

        patched() {
            super.patched();
            this._renderChart();
        }

        //---------------------------------------------------------------------
        // Getters
        //---------------------------------------------------------------------

        get measureDescription() {
            const measure = this.props.measures.find(m => m.fieldName === this.props.measure);
            return measure ? measure.description : this.props.fields[this.props.measure].string;
        }

        //---------------------------------------------------------------------
        // Private
        //---------------------------------------------------------------------

        /**
         * This function aims to remove a suitable number of lines from the
         * tooltip in order to make it reasonably visible. A message indicating
         * the number of lines is added if necessary.
         * @private
         * @param {Number} maxTooltipHeight this the max height in pixels of the tooltip
         */
        _adjustTooltipHeight(maxTooltipHeight) {
            const sizeOneLine = this.tooltip.querySelector("tbody tr").clientHeight;
            const tbodySize = this.tooltip.querySelector("tbody").clientHeight;
            const toKeep = Math.max(0, Math.floor(
                (maxTooltipHeight - (this.tooltip.clientHeight - tbodySize)
                ) / sizeOneLine) - 1);
            const lines = this.tooltip.querySelectorAll("tbody tr");
            const toRemove = lines.length - toKeep;
            if (toRemove > 0) {
                for (let index = toKeep; index < lines.length; ++index) {
                    lines[index].remove();
                }
                const tr = document.createElement("tr");
                const td = document.createElement("td");
                tr.classList.add("o_show_more");
                td.innerHTML = this.env._t("...");
                tr.appendChild(td);
                this.tooltip.querySelector("tbody").appendChild(tr);
            }
        }

        /**
         * Creates a bar chart config.
         * @private
         */
        _createBarChartConfig() {
            // prepare data
            const data = this._prepareData(this.processedDataPoints);

            for (let index = 0; index < data.datasets.length; ++index) {
                const dataset = data.datasets[index];
                // used when stacked
                if (this.props.stacked) {
                    dataset.stack = this.props.origins[dataset.originIndex];
                }
                // set dataset color
                dataset.backgroundColor = getColor(index);
            }

            // prepare options
            const options = this._prepareOptions(data.datasets.length);

            // create bar chart config
            return { data, options, type: "bar" };
        }

        /**
         * Returns the graph configuration object.
         * @private
         * @returns {Object}
         */
        _createConfig() {
            if (this.noContentHelperData) {
                return {};
            }
            if (this.props.comparisonFieldIndex === 0) {
                this.dateClasses = this._getDateClasses(this.processedDataPoints);
            }
            switch (this.props.mode) {
                case "bar": return this._createBarChartConfig();
                case "line": return this._createLineChartConfig();
                case "pie": return this._createPieChartConfig();
            }
        }

        /**
         * Creates a line chart config.
         * @private
         */
        _createLineChartConfig() {
            // prepare data
            const data = this._prepareData(this.processedDataPoints);
            for (let index = 0; index < data.datasets.length; ++index) {
                const dataset = data.datasets[index];
                if (
                    this.props.processedGroupBy.length <= 1 &&
                    this.props.origins.length > 1
                ) {
                    if (dataset.originIndex === 0) {
                        dataset.fill = "origin";
                        dataset.backgroundColor = hexToRGBA(COLORS[0], 0.4);
                        dataset.borderColor = hexToRGBA(COLORS[0], 1);
                    } else if (dataset.originIndex === 1) {
                        dataset.borderColor = hexToRGBA(COLORS[1], 1);
                    } else {
                        dataset.borderColor = getColor(index);
                    }
                } else {
                    dataset.borderColor = getColor(index);
                }
                if (data.labels.length === 1) {
                    // shift of the real value to right. This is done to
                    // center the points in the chart. See data.labels below in
                    // Chart parameters
                    dataset.data.unshift(undefined);
                }
                dataset.pointBackgroundColor = dataset.borderColor;
                dataset.pointBorderColor = "rgba(0,0,0,0.2)";
            }
            if (data.datasets.length === 1 && data.datasets[0].originIndex === 0) {
                const dataset = data.datasets[0];
                dataset.fill = "origin";
                dataset.backgroundColor = hexToRGBA(COLORS[0], 0.4);
            }

            // center the points in the chart (without that code they are put
            // on the left and the graph seems empty)
            data.labels = data.labels.length > 1 ?
                data.labels :
                [this.fakeDataLabel, ...data.labels, this.fakeDataLabel];

            // prepare options
            const options = this._prepareOptions(data.datasets.length);

            // create line chart config
            return { data, options, type: "line" };
        }

        /**
         * Creates a pie chart config.
         * @private
         */
        _createPieChartConfig() {
            // prepare data
            let data = {};
            const allZero = this.processedDataPoints.every(
                datapt => datapt.value === 0
            );
            if (allZero) {
                // add fake data to display a pie chart with a grey zone associated
                // with every origin
                data.labels = [this.noDataLabel];
                data.datasets = this.props.origins.map(origin => {
                    return {
                        label: origin,
                        data: [1],
                        backgroundColor: [DEFAULT_BG],
                    };
                });
            } else {
                data = this._prepareData(this.processedDataPoints);
                // give same color to same groups from different origins
                const colors = data.labels.map((_, index) => getColor(index));
                for (const dataset of data.datasets) {
                    dataset.backgroundColor = colors;
                    dataset.borderColor = "rgba(255,255,255,0.6)";
                }
                // make sure there is a zone associated with every origin
                const representedOriginIndexes = data.datasets.map(
                    dataset => dataset.originIndex
                );
                let addNoDataToLegend = false;
                const fakeData = new Array(data.labels.length).concat([1]);

                for (let index = 0; index < this.props.origins.length; ++index) {
                    const origin = this.props.origins[index];
                    if (!representedOriginIndexes.includes(index)) {
                        data.datasets.splice(index, 0, {
                            label: origin,
                            data: fakeData,
                            backgroundColor: [...colors, DEFAULT_BG],
                        });
                        addNoDataToLegend = true;
                    }
                }
                if (addNoDataToLegend) {
                    data.labels.push(this.noDataLabel);
                }
            }

            // prepare options
            const options = this._prepareOptions(data.datasets.length);

            // create pie chart config
            return { data, options, type: "pie" };
        }

        /**
         * Creates a custom HTML tooltip.
         * @private
         * @param {Object} tooltipModel see chartjs documentation
         */
        _customTooltip(tooltipModel) {
            this.el.style.cursor = "";
            this._removeTooltips();
            if (tooltipModel.opacity === 0 || tooltipModel.dataPoints.length === 0) {
                return;
            }
            if (this._isRedirectionEnabled()) {
                this.el.style.cursor = "pointer";
            }

            const chartAreaTop = this.chart.chartArea.top;
            const rendererTop = this.el.getBoundingClientRect().top;

            const innerHTML = this.env.qweb.renderToString("web.GraphRenderer.CustomTooltip", {
                maxWidth: getMaxWidth(this.chart.chartArea),
                measure: this.measureDescription,
                mode: this.props.mode,
                tooltipItems: this._getTooltipItems(tooltipModel),
            });
            const template = Object.assign(document.createElement("template"), { innerHTML });
            this.tooltip = template.content.firstChild;

            this.containerRef.el.prepend(this.tooltip);

            let top;
            const tooltipHeight = this.tooltip.clientHeight;
            const minTopAllowed = Math.floor(chartAreaTop);
            const maxTopAllowed = Math.floor(window.innerHeight - (rendererTop + tooltipHeight)) - 2;
            const y = Math.floor(tooltipModel.y);

            if (minTopAllowed <= maxTopAllowed) {
                // Here we know that the full tooltip can fit in the screen.
                // We put it in the position where Chart.js would put it
                // if two conditions are respected:
                //  1: the tooltip is not cut (because we know it is possible to not cut it)
                //  2: the tooltip does not hide the legend.
                // If it is not possible to use the Chart.js proposition (y)
                // we use the best approximated value.
                if (y <= maxTopAllowed) {
                    if (y >= minTopAllowed) {
                        top = y;
                    } else {
                        top = minTopAllowed;
                    }
                } else {
                    top = maxTopAllowed;
                }
            } else {
                // Here we know that we cannot satisfy condition 1 above,
                // so we position the tooltip at the minimal position and
                // cut it the minimum possible.
                top = minTopAllowed;
                const maxTooltipHeight = window.innerHeight - (rendererTop + chartAreaTop) - 2;
                this._adjustTooltipHeight(maxTooltipHeight);
            }

            this._fixTooltipLeftPosition(this.tooltip, tooltipModel.x);
            this.tooltip.style.top = Math.floor(top) + "px";
        }

        /**
         * Filters out some dataPoints because they would lead to bad graphics.
         * The filtering is done with respect to the graph view mode.
         * Note that the method does not alter this.state.dataPoints, since we
         * want to be able to change of mode without fetching data again:
         * we simply present the same data in a different way.
         * Note: this should be moved to the model at some point.
         * @private
         * @param {Object} props
         * @returns {Object[]}
         */
        _filterDataPoints(props) {
            let dataPoints = [];
            if (props.mode === "line") {
                let counts = 0;
                for (const dataPoint of props.dataPoints) {
                    if (dataPoint.labels[0] !== this.env._t("Undefined")) {
                        dataPoints.push(dataPoint);
                    }
                    counts += dataPoint.count;
                }
                // data points with zero count might have been created on purpose
                // we only remove them if there are no data point with positive count
                if (counts === 0) {
                    dataPoints = [];
                }
            } else {
                dataPoints = props.dataPoints.filter(
                    dataPoint => dataPoint.count > 0
                );
            }
            return dataPoints;
        }

        /**
         * Sets best left position of a tooltip approaching the proposal x.
         * @private
         * @param {DOMElement} tooltip
         * @param {number} x, left offset proposed
         */
        _fixTooltipLeftPosition(tooltip, x) {
            let left;
            const tooltipWidth = tooltip.clientWidth;
            const minLeftAllowed = Math.floor(this.chart.chartArea.left + 2);
            const maxLeftAllowed = Math.floor(this.chart.chartArea.right - tooltipWidth - 2);
            x = Math.floor(x);
            if (x <= maxLeftAllowed) {
                if (x >= minLeftAllowed) {
                    left = x;
                } else {
                    left = minLeftAllowed;
                }
            } else {
                left = maxLeftAllowed;
            }
            tooltip.style.left = left + "px";
        }

        /**
         * Used to format correctly the values in tooltips and yAxes.
         * @private
         * @param {number} value
         * @returns {string} The value formatted using fieldUtils.format.float
         */
        _formatValue(value) {
            const formatter = fieldUtils.format.float;
            const measure = this.props.fields[this.props.measure];
            const formatedValue = formatter(value, measure, FORMAT_OPTIONS);
            return formatedValue;
        }

        /**
         * Determines the initial section of the labels array over which
         * a dataset has to be completed. The section only depends on the
         * datasets origins.
         * @private
         * @param {number} originIndex
         * @param {number} defaultLength
         * @returns {number}
         */
        _getDatasetDataLength(originIndex, defaultLength) {
            if (this.props.mode !== "pie" && this.props.comparisonFieldIndex === 0) {
                return this.dateClasses.dateSets[originIndex].length;
            }
            return defaultLength;
        }

        /**
         * Determines the dataset to which the data point belongs.
         * @private
         * @param {Object} dataPoint
         * @returns {string}
         */
        _getDatasetLabel({ labels, originIndex }) {
            if (this.props.mode === "pie") {
                return this.props.origins[originIndex];
            }
            // ([origin] + second to last groupBys) or measure
            let datasetLabel = labels.slice(1).join("/");
            if (this.props.origins.length > 1) {
                datasetLabel = this.props.origins[originIndex] + (
                    datasetLabel ? ("/" + datasetLabel) : ""
                );
            }
            return datasetLabel || this.measureDescription;
        }

        /**
         * Returns a DateClasses instance used to manage equivalence of dates.
         * @private
         * @param {Object[]} dataPoints
         * @returns {DateClasses}
         */
        _getDateClasses(dataPoints) {
            const dateSets = this.props.origins.map(() => []);
            for (const { labels, originIndex } of dataPoints) {
                dateSets[originIndex].push(labels[this.props.comparisonFieldIndex]);
            }
            return new DateClasses(dateSets.map(dateSet => [...new Set(dateSet)]));
        }

        /**
         * Returns an object used to style chart elements independently from
         * the datasets.
         * @private
         * @returns {Object}
         */
        _getElementOptions() {
            const elementOptions = {};
            if (this.props.mode === "bar") {
                elementOptions.rectangle = { borderWidth: 1 };
            } else if (this.props.mode === "line") {
                elementOptions.line = {
                    tension: 0,
                    fill: false,
                };
            }
            return elementOptions;
        }

        /**
         * Gets the label over which the data point is.
         * @private
         * @param {Object} dataPoint
         * @returns {Array}
         */
        _getLabel({ labels, originIndex }) {
            const index = this.props.comparisonFieldIndex;
            if (this.props.mode !== "pie") {
                if (index === 0) {
                    return [this.dateClasses.dateClass(originIndex, labels[index])];
                } else {
                    return labels.slice(0, 1);
                }
            } else if (index === 0) {
                return [
                    this.dateClasses.dateClass(originIndex, labels[index]),
                    ...labels.slice(index + 1)
                ];
            } else {
                return labels;
            }
        }

        /**
         * Returns the options used to generate the chart legend.
         * @private
         * @param {number} datasetsCount
         * @returns {Object}
         */
        _getLegendOptions(datasetsCount) {
            const legendOptions = {
                display: datasetsCount <= MAX_LEGEND_LENGTH,
                position: "top",
                onHover: this._onlegendHover.bind(this),
                onLeave: this._onLegendLeave.bind(this),
            };
            if (this.props.mode === "line") {
                legendOptions.onClick = this._onLegendClick.bind(this);
            }
            if (this.props.mode !== "pie") {
                let referenceColor;
                if (this.props.mode === "bar") {
                    referenceColor = "backgroundColor";
                } else {
                    referenceColor = "borderColor";
                }
                legendOptions.labels = {
                    generateLabels: chart => {
                        const { data } = chart;
                        const labels = data.datasets.map((dataset, index) => {
                            return {
                                text: shortenLabel(dataset.label),
                                fullText: dataset.label,
                                fillStyle: dataset[referenceColor],
                                hidden: !chart.isDatasetVisible(index),
                                lineCap: dataset.borderCapStyle,
                                lineDash: dataset.borderDash,
                                lineDashOffset: dataset.borderDashOffset,
                                lineJoin: dataset.borderJoinStyle,
                                lineWidth: dataset.borderWidth,
                                strokeStyle: dataset[referenceColor],
                                pointStyle: dataset.pointStyle,
                                datasetIndex: index,
                            };
                        });
                        return labels;
                    },
                };
            } else {
                const { comparisonFieldIndex } = this.props;
                legendOptions.labels = {
                    generateLabels: chart => {
                        const { data } = chart;
                        const metaData = data.datasets.map(
                            (_, index) => chart.getDatasetMeta(index).data
                        );
                        const labels = data.labels.map((label, index) => {
                            const hidden = metaData.some(
                                data => data[index] && data[index].hidden
                            );
                            const fullText = this._relabelling(label, comparisonFieldIndex);
                            const text = shortenLabel(fullText);
                            const fillStyle = label === this.noDataLabel ?
                                DEFAULT_BG :
                                getColor(index);
                            return { text, fullText, fillStyle, hidden, index };
                        });
                        return labels;
                    },
                };
            }
            return legendOptions;
        }

        /**
         * Determines whether the data are good, and displays an error message
         * if this is not the case.
         * @private
         * @returns {Object | null}
         */
        _getNoContentHelper() {
            if (this.props.mode === "pie") {
                const dataPoints = this.processedDataPoints;
                const someNegative = dataPoints.some(dataPt => dataPt.value < 0);
                const somePositive = dataPoints.some(dataPt => dataPt.value > 0);
                if (someNegative && somePositive) {
                    return {
                        title: this.env._t("Invalid data"),
                        description: [
                            this.env._t("Pie chart cannot mix positive and negative numbers. "),
                            this.env._t("Try to change your domain to only display positive results")
                        ].join("")
                    };
                }
            }
            return null;
        }

        /**
         * Returns the options used to generate the chart axes.
         * @private
         * @returns {Object}
         */
        _getScaleOptions() {
            if (this.props.mode === "pie") {
                return {};
            }
            const { comparisonFieldIndex } = this.props;
            const xAxes = [{
                type: "category",
                scaleLabel: {
                    display: this.props.processedGroupBy.length && !this.props.isEmbedded,
                    labelString: this.props.processedGroupBy.length ?
                        this.props.fields[this.props.processedGroupBy[0].split(":")[0]].string :
                        "",
                },
                ticks: { callback: label => this._relabelling(label, comparisonFieldIndex) },
            }];
            const yAxes = [{
                type: "linear",
                scaleLabel: {
                    display: !this.props.isEmbedded,
                    labelString: this.measureDescription,
                },
                ticks: {
                    callback: value => this._formatValue(value),
                    suggestedMax: 0,
                    suggestedMin: 0,
                },
            }];
            return { xAxes, yAxes };
        }

        /**
         * Extracts the important information from a tooltipItem generated by
         * Charts.js (a tooltip item corresponds to a line (different from
         * measure name) of a tooltip).
         * @private
         * @param {Object} item
         * @param {Object} data
         * @returns {Object}
         */
        _getTooltipItemContent(item, data) {
            const { comparisonFieldIndex } = this.props;
            const dataset = data.datasets[item.datasetIndex];
            const id = item.index;
            let label = data.labels[item.index];
            let value;
            let boxColor;
            let percentage;
            if (this.props.mode === "pie") {
                if (label === this.noDataLabel) {
                    value = this._formatValue(0);
                } else {
                    value = this._formatValue(dataset.data[item.index]);
                    const totalData = dataset.data.reduce((a, b) => a + b, 0);
                    percentage = totalData && ((dataset.data[item.index] * 100) / totalData).toFixed(2);
                }
                label = this._relabelling(label, comparisonFieldIndex, dataset.originIndex);
                if (this.props.origins.length > 1) {
                    label = `${dataset.label}/${label}`;
                }
                boxColor = dataset.backgroundColor[item.index];
            } else {
                label = this._relabelling(label, comparisonFieldIndex, dataset.originIndex);
                if (
                    this.props.processedGroupBy.length > 1 ||
                    this.props.origins.length > 1
                ) {
                    label = `${label}/${dataset.label}`;
                }
                value = this._formatValue(item.yLabel);
                boxColor = this.props.mode === "bar" ?
                    dataset.backgroundColor :
                    dataset.borderColor;
            }
            return { id, label, value, boxColor, percentage };
        }

        /**
         * This function extracts the information from the data points in
         * tooltipModel.dataPoints (corresponding to datapoints over a given
         * label determined by the mouse position) that will be displayed in a
         * custom tooltip.
         * @private
         * @param {Object} tooltipModel see chartjs documentation
         * @return {Object[]}
         */
        _getTooltipItems(tooltipModel) {
            const { data } = this.chart.config;
            const sortedDataPoints = sortBy(tooltipModel.dataPoints, "yLabel", "desc");
            return sortedDataPoints.map(
                item => this._getTooltipItemContent(item, data)
            );
        }

        /**
         * Returns the options used to generate chart tooltips.
         * @private
         * @returns {Object}
         */
        _getTooltipOptions() {
            const tooltipOptions = {
                // disable Chart.js tooltips
                enabled: false,
                custom: this._customTooltip.bind(this),
            };
            if (this.props.mode === "line") {
                tooltipOptions.mode = "index";
                tooltipOptions.intersect = false;
            }
            return tooltipOptions;
        }

        /**
         * Returns true iff the current graph can be clicked on to redirect to
         * the list of records.
         * @private
         * @returns {boolean}
         */
        _isRedirectionEnabled() {
            return !this.props.disableLinking && this.props.mode !== "line";
        }

        /**
         * Separates dataPoints coming from the read_group(s) into different
         * datasets. This function returns the parameters data and labels used
         * to produce the charts.
         * @param {Object[]} dataPoints
         * @returns {Object}
         */
        _prepareData(dataPoints) {
            const labelMap = {};
            const labels = [];
            for (const dataPt of dataPoints) {
                const label = this._getLabel(dataPt);
                const labelKey = `${dataPt.resId}:${JSON.stringify(label)}`;
                const index = labelMap[labelKey];
                if (index === undefined) {
                    labelMap[labelKey] = dataPt.labelIndex = labels.length;
                    labels.push(label);
                } else {
                    dataPt.labelIndex = index;
                }
            }

            // dataPoints --> datasets
            const datasetsTmp = {};
            for (const dp of dataPoints) {
                const datasetLabel = this._getDatasetLabel(dp);
                if (!(datasetLabel in datasetsTmp)) {
                    const dataLength = this._getDatasetDataLength(dp.originIndex, labels.length);
                    datasetsTmp[datasetLabel] = {
                        data: new Array(dataLength).fill(0),
                        domain: new Array(dataLength).fill([]),
                        label: datasetLabel,
                        originIndex: dp.originIndex,
                    };
                }
                const labelIndex = dp.labelIndex;
                datasetsTmp[datasetLabel].data[labelIndex] = dp.value;
                datasetsTmp[datasetLabel].domain[labelIndex] = dp.domain;
            }
            // sort by origin
            const datasets = sortBy(Object.values(datasetsTmp), "originIndex");
            return { datasets, labels };
        }

        /**
         * Prepares options for the chart according to the current mode
         * (= chart type). This function returns the parameter options used to
         * instantiate the chart.
         * @private
         * @param {number} datasetsCount
         * @returns {Object} the chart options used for the current mode
         */
        _prepareOptions(datasetsCount) {
            const options = {
                maintainAspectRatio: false,
                scales: this._getScaleOptions(),
                legend: this._getLegendOptions(datasetsCount),
                tooltips: this._getTooltipOptions(),
                elements: this._getElementOptions(),
            };
            if (this._isRedirectionEnabled()) {
                options.onClick = ev => this._onGraphClicked(ev);
            }
            return options;
        }

        /**
         * Computes various information from the given props object.
         * @param {Object} props
         */
        _processProps(props) {
            const filteredDataPoints = this._filterDataPoints(props);
            this.processedDataPoints = this._sortDataPoints(filteredDataPoints, props);
            this.noContentHelperData = this._getNoContentHelper(props.mode);
        }

        /**
         * Determines how to relabel a label according to a given origin. The
         * idea is that the getLabel function is in general not invertible but
         * it is when restricted to the set of dataPoints coming from a same
         * origin.
         * @private
         * @param {Array} label
         * @param {number} index
         * @param {Array} [originIndex]
         * @returns {string}
         */
        _relabelling(label, index, originIndex) {
            if (label === this.noDataLabel || label === this.fakeDataLabel) {
                return label[0];
            }
            if (this.props.mode !== "pie" && index === 0) {
                // here label is an array of length 1 and contains a number
                return this.dateClasses.representative(label, originIndex) || "";
            } else if (this.props.mode === "pie" && index === 0) {
                // here label is an array of length at least one containing string or numbers
                const labelCopy = label.slice();
                let newLabel;
                if (originIndex === undefined) {
                    newLabel = this.dateClasses.dateClassMembers(label[index]);
                } else {
                    newLabel = this.dateClasses.representative(label[index], originIndex);
                }
                labelCopy.splice(index, 1, newLabel);
                return labelCopy.join("/");
            }
            // here label is an array containing strings or numbers.
            return label.join("/") || this.env._t("Total");
        }

        /**
         * Removes all existing tooltips.
         * @private
         */
        _removeTooltips() {
            if (this.tooltip) {
                this.tooltip.remove();
                this.tooltip = null;
            }
            if (this.legendTooltip) {
                this.legendTooltip.remove();
                this.legendTooltip = null;
            }
        }

        /**
         * Instantiates a Chart (Chart.js lib) to render the graph according to
         * the current config.
         * @private
         */
        _renderChart() {
            if (this.noContentHelperData) {
                return;
            }
            if (this.chart) {
                this.chart.destroy();
            }
            const config = this._createConfig();
            const canvasContext = this.canvasRef.el.getContext("2d");
            this.chart = new Chart(canvasContext, config);
            // To perform its animations, ChartJS will perform each animation
            // step in the next animation frame. The initial rendering itself
            // is delayed for consistency. We can avoid this by manually
            // advancing the animation service.
            Chart.animationService.advance();
        }

        /**
         * Sorts datapoints according to the current order (ASC or DESC).
         * Note: this should be moved to the model at some point.
         * @private
         * @param {Object[]} dataPoints
         * @param {Object} props
         * @returns {Object[]} sorted dataPoints if orderby set on state
         */
        _sortDataPoints(dataPoints, props) {
            if (
                props.domains.length === 1 &&
                props.orderBy &&
                props.mode !== "pie" &&
                props.processedGroupBy.length
            ) {
                // group data by their x-axis value, and then sort datapoints
                // based on the sum of values by group in ascending/descending order
                const [groupByFieldName] = props.processedGroupBy[0].split(":");
                const { type } = props.fields[groupByFieldName];
                const groupedDataPoints = {};
                for (const dataPt of dataPoints) {
                    const key = type === "many2one" ? dataPt.resId : dataPt.labels[0];
                    if (!groupedDataPoints[key]) {
                        groupedDataPoints[key] = [];
                    }
                    groupedDataPoints[key].push(dataPt);
                }
                const groupTotal = group => group.reduce((sum, { value }) => sum + value, 0);
                dataPoints = sortBy(
                    Object.values(groupedDataPoints),
                    groupTotal,
                    props.orderBy
                ).flat();
            }
            return dataPoints;
        }

        //---------------------------------------------------------------------
        // Handlers
        //---------------------------------------------------------------------

        /**
         * @private
         * @param {MouseEvent} ev
         */
        _onGraphClicked(ev) {
            const [activeElement] = this.chart.getElementAtEvent(ev);
            if (!activeElement) {
                return;
            }
            const { _datasetIndex, _index } = activeElement;
            const { domain } = this.chart.data.datasets[_datasetIndex];
            if (domain) {
                this.trigger("open_view", { domain: domain[_index] });
            }
        }

        /**
         * Overrides the default legend 'onClick' behaviour. This is done to
         * remove all existing tooltips right before updating the chart.
         * @private
         * @param {MouseEvent} ev
         * @param {Object} legendItem
         */
        _onLegendClick(ev, legendItem) {
            this._removeTooltips();
            // Default 'onClick' fallback. See web/static/lib/Chart/Chart.js#15138
            const index = legendItem.datasetIndex;
            const meta = this.chart.getDatasetMeta(index);
            meta.hidden = meta.hidden === null ? !this.chart.data.datasets[index].hidden : null;
            this.chart.update();
        }

        /**
         * If the text of a legend item has been shortened and the user mouse
         * hovers that item (actually the event type is mousemove), a tooltip
         * with the item full text is displayed.
         * @private
         * @param {MouseEvent} ev
         * @param {Object} legendItem
         */
        _onlegendHover(ev, legendItem) {
            this.canvasRef.el.style.cursor = "pointer";
            /**
             * The string legendItem.text is an initial segment of legendItem.fullText.
             * If the two coincide, no need to generate a tooltip. If a tooltip
             * for the legend already exists, it is already good and doesn't
             * need to be recreated.
             */
            if (legendItem.text === legendItem.fullText || this.legendTooltip) {
                return;
            }

            const rendererTop = this.el.getBoundingClientRect().top;

            this.legendTooltip = Object.assign(document.createElement("div"), {
                className: "o_tooltip_legend",
                innerText: legendItem.fullText,
            });
            this.legendTooltip.style.top = (ev.clientY - rendererTop) + "px";
            this.legendTooltip.style.maxWidth = getMaxWidth(this.chart.chartArea);

            this.containerRef.el.appendChild(this.legendTooltip);

            this._fixTooltipLeftPosition(this.legendTooltip, ev.clientX);
        }

        /**
         * If there's a legend tooltip and the user mouse out of the
         * corresponding legend item, the tooltip is removed.
         * @private
         */
        _onLegendLeave() {
            this.canvasRef.el.style.cursor = "";
            if (this.legendTooltip) {
                this.legendTooltip.remove();
                this.legendTooltip = null;
            }
        }
    }

    GraphRenderer.template = "web.Legacy.GraphRenderer";
    GraphRenderer.props = {
        arch: {
            type: Object,
            shape: {
                children: { type: Array, element: Object },
                attrs: Object,
                tag: { validate: t => t === "graph" },
            },
        },
        comparisonFieldIndex: Number,
        context: Object,
        dataPoints: { type: Array, element: Object },
        disableLinking: Boolean,
        domain: [Array, String],
        domains: { type: Array, element: [Array, String] },
        fields: Object,
        groupBy: { type: Array, element: String },
        isEmbedded: Boolean,
        isSample: { type: Boolean, optional: 1 },
        measure: String,
        measures: { type: Array, element: Object },
        mode: { validate: m => ["bar", "line", "pie"].includes(m) },
        origins: { type: Array, element: String },
        processedGroupBy: { type: Array, element: String },
        stacked: Boolean,
        timeRanges: Object,
        noContentHelp: { type: String, optional: 1 },
        orderBy: { type: [String, Boolean], optional: 1 },
        title: { type: String, optional: 1 },
        withSearchPanel: { type: Boolean, optional: 1 },
    };

    return GraphRenderer;

});
;

/*******************************************************************
*  Filepath: /web/static/src/legacy/js/views/graph/graph_utils.js  *
*  Bundle: web.assets_backend_legacy_lazy                          *
*  Lines: 86                                                       *
*******************************************************************/
odoo.define('web/static/src/js/views/graph/graph_utils', function (require) {
"use strict";

const { device } = require("web.config");

const COLORS = [
    "#1f77b4", "#ff7f0e", "#aec7e8", "#ffbb78", "#2ca02c", "#98df8a", "#d62728",
    "#ff9896", "#9467bd", "#c5b0d5", "#8c564b", "#c49c94", "#e377c2", "#f7b6d2",
    "#7f7f7f", "#c7c7c7", "#bcbd22", "#dbdb8d", "#17becf", "#9edae5",
];
const DEFAULT_BG = "#d3d3d3";
// used to format values in tooltips and yAxes.
const FORMAT_OPTIONS = {
    // allow to decide if utils.human_number should be used
    humanReadable: value => Math.abs(value) >= 1000,
    // with the choices below, 1236 is represented by 1.24k
    minDigits: 1,
    decimals: 2,
    // avoid comma separators for thousands in numbers when human_number is used
    formatterCallback: str => str,
};
// hide top legend when too many items for device size
const MAX_LEGEND_LENGTH = 4 * Math.max(1, device.size_class);
const RGB_REGEX = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i;

/**
 * @param {number} index
 * @returns {string}
 */
function getColor(index) {
    return COLORS[index % COLORS.length];
}

/**
 * @param {Object} chartArea
 * @returns {string}
 */
function getMaxWidth({ left, right }) {
    return Math.floor((right - left) / 1.618) + "px";
}

/**
 * @param {string} hex
 * @param {number} opacity
 * @returns {string}
 */
function hexToRGBA(hex, opacity) {
    const rgb = RGB_REGEX
        .exec(hex)
        .slice(1, 4)
        .map(n => parseInt(n, 16))
        .join(",");
    return `rgba(${rgb},${opacity})`;
}

/**
 * Used to avoid too long legend items.
 * @param {string} label
 * @returns {string} shortened version of the input label
 */
function shortenLabel(label) {
    // string returned could be wrong if a groupby value contain a "/"!
    const groups = label.split("/");
    let shortLabel = groups.slice(0, 3).join("/");
    if (shortLabel.length > 30) {
        shortLabel = `${shortLabel.slice(0, 30)}...`;
    } else if (groups.length > 3) {
        shortLabel = `${shortLabel}/...`;
    }
    return shortLabel;
}

return {
    COLORS,
    DEFAULT_BG,
    FORMAT_OPTIONS,
    MAX_LEGEND_LENGTH,
    RGB_REGEX,
    getColor,
    getMaxWidth,
    hexToRGBA,
    shortenLabel,
};

});

;

/******************************************************************
*  Filepath: /web/static/src/legacy/js/views/graph/graph_view.js  *
*  Bundle: web.assets_backend_legacy_lazy                         *
*  Lines: 175                                                     *
******************************************************************/
odoo.define('web.GraphView', function (require) {
"use strict";

/**
 * The Graph View is responsible to display a graphical (meaning: chart)
 * representation of the current dataset.  As of now, it is currently able to
 * display data in three types of chart: bar chart, line chart and pie chart.
 */

var AbstractView = require('web.AbstractView');
var core = require('web.core');
var GraphModel = require('web.GraphModel');
var Controller = require('web.GraphController');
const GraphRenderer = require("web/static/src/js/views/graph/graph_renderer");
const RendererWrapper = require("web.RendererWrapper");
const viewRegistry = require("web.view_registry");

var _t = core._t;
var _lt = core._lt;

var searchUtils = require('web.searchUtils');
var GROUPABLE_TYPES = searchUtils.GROUPABLE_TYPES;

var GraphView = AbstractView.extend({
    display_name: _lt('Graph'),
    icon: 'fa-bar-chart',
    jsLibs: [
        '/web/static/lib/Chart/Chart.js',
    ],
    config: _.extend({}, AbstractView.prototype.config, {
        Model: GraphModel,
        Controller: Controller,
        Renderer: GraphRenderer,
    }),
    viewType: 'graph',
    searchMenuTypes: ['filter', 'groupBy', 'comparison', 'favorite'],

    /**
     * @override
     */
    init: function (viewInfo, params) {
        this._super.apply(this, arguments);

        const additionalMeasures = params.additionalMeasures || [];
        let measure;
        const measures = {};
        const measureStrings = {};
        let groupBys = [];
        const groupableFields = {};
        this.fields.__count__ = { string: _t("Count"), type: 'integer' };

        this.arch.children.forEach(field => {
            let fieldName = field.attrs.name;
            if (fieldName === "id") {
                return;
            }
            const interval = field.attrs.interval;
            if (interval) {
                fieldName = fieldName + ':' + interval;
            }
            if (field.attrs.type === 'measure') {
                const { string } = this.fields[fieldName];
                measure = fieldName;
                measures[fieldName] = {
                    description: string,
                    fieldName,
                    groupNumber: 0,
                    isActive: false,
                    itemType: 'measure',
                };
            } else {
                groupBys.push(fieldName);
            }
            if (field.attrs.string) {
                measureStrings[fieldName] = field.attrs.string;
            }
        });

        for (const name in this.fields) {
            const field = this.fields[name];
            if (name !== 'id' && field.store === true) {
                if (
                    ['integer', 'float', 'monetary'].includes(field.type) ||
                    additionalMeasures.includes(name)
                ) {
                    measures[name] = {
                        description: field.string,
                        fieldName: name,
                        groupNumber: 0,
                        isActive: false,
                        itemType: 'measure',
                    };
                }
                if (GROUPABLE_TYPES.includes(field.type)) {
                    groupableFields[name] = field;
                }
            }
        }
        for (const name in measureStrings) {
            if (measures[name]) {
                measures[name].description = measureStrings[name];
            }
        }

        // Remove invisible fields from the measures
        this.arch.children.forEach(field => {
            let fieldName = field.attrs.name;
            if (field.attrs.invisible && py.eval(field.attrs.invisible)) {
                groupBys = groupBys.filter(groupBy => groupBy !== fieldName);
                if (fieldName in groupableFields) {
                    delete groupableFields[fieldName];
                }
                if (!additionalMeasures.includes(fieldName)) {
                    delete measures[fieldName];
                }
            }
        });

        const sortedMeasures = Object.values(measures).sort((a, b) => {
                const descA = a.description.toLowerCase();
                const descB = b.description.toLowerCase();
                return descA > descB ? 1 : descA < descB ? -1 : 0;
            });
        const countMeasure = {
            description: _t("Count"),
            fieldName: '__count__',
            groupNumber: 1,
            isActive: false,
            itemType: 'measure',
        };
        this.controllerParams.withButtons = params.withButtons !== false;
        this.controllerParams.measures = [...sortedMeasures, countMeasure];
        this.controllerParams.groupableFields = groupableFields;
        this.controllerParams.title = params.title || this.arch.attrs.string || _t("Untitled");
        // retrieve form and list view ids from the action to open those views
        // when the graph is clicked
        function _findView(views, viewType) {
            const view = views.find(view => {
                return view.type === viewType;
            });
            return [view ? view.viewID : false, viewType];
        }
        this.controllerParams.views = [
            _findView(params.actionViews, 'list'),
            _findView(params.actionViews, 'form'),
        ];

        this.rendererParams.fields = this.fields;
        this.rendererParams.measures = this.controllerParams.measures;
        this.rendererParams.title = this.arch.attrs.title; // TODO: use attrs.string instead
        this.rendererParams.disableLinking = !!JSON.parse(this.arch.attrs.disable_linking || '0');

        this.loadParams.mode = this.arch.attrs.type || 'bar';
        this.loadParams.orderBy = this.arch.attrs.order;
        this.loadParams.measure = measure || '__count__';
        this.loadParams.groupBys = groupBys;
        this.loadParams.fields = this.fields;
        this.loadParams.comparisonDomain = params.comparisonDomain;
        this.loadParams.stacked = this.arch.attrs.stacked !== "False";
    },

     /**
     *
     * @override
     */
    getRenderer(parent, props) {
        props = Object.assign(props || {}, this.rendererParams);
        return new RendererWrapper(null, this.config.Renderer, props);
    },
});

viewRegistry.add("graph", GraphView);
return GraphView;

});
;

/************************************************************************
*  Filepath: /web/static/src/legacy/js/views/pivot/pivot_controller.js  *
*  Bundle: web.assets_backend_legacy_lazy                               *
*  Lines: 332                                                           *
************************************************************************/
odoo.define('@web/legacy/js/views/pivot/pivot_controller', async function (require) {
'use strict';
let __exports = {};
/** @odoo-module alias=web.PivotController **/

    /**
     * Odoo Pivot Table Controller
     *
     * This class is the Controller for the pivot table view.  It has to coordinate
     * the actions coming from the search view (through the update method), from
     * the renderer, from the model, and from the control panel.
     *
     * It can display action buttons in the control panel, to select a different
     * measure, or to perform some other actions such as download/expand/flip the
     * view.
     */

    const AbstractController = require("@web/legacy/js/views/abstract_controller")[Symbol.for("default")];
    const core = require('web.core');
    const framework = require('web.framework');
    const session = require('web.session');

    const _t = core._t;
    const QWeb = core.qweb;

    const PivotController = AbstractController.extend({
        custom_events: Object.assign({}, AbstractController.prototype.custom_events, {
            closed_header_click: '_onClosedHeaderClicked',
            open_view: '_onOpenView',
            opened_header_click: '_onOpenedHeaderClicked',
            sort_rows: '_onSortRows',
            groupby_menu_selection: '_onGroupByMenuSelection',
        }),

        /**
         * @override
         * @param parent
         * @param model
         * @param renderer
         * @param {Object} params
         */
        init: function (parent, model, renderer, params) {
            this._super(...arguments);

            this.disableLinking = params.disableLinking;
            this.measures = params.measures;
            this.title = params.title;
            // views to use in the action triggered when a data cell is clicked
            this.views = params.views;
            this.groupSelected = null;
        },
        /**
         * @override
         */
        destroy: function () {
            if (this.$buttons) {
                // remove jquery's tooltip() handlers
                this.$buttons.find('button').off();
            }
            return this._super(...arguments);
        },

        //--------------------------------------------------------------------------
        // Public
        //--------------------------------------------------------------------------

        /**
         * Returns the current measures and groupbys, so we can restore the view
         * when we save the current state in the search view, or when we add it to
         * the dashboard.
         *
         * @override method from AbstractController
         * @returns {Object}
         */
        getOwnedQueryParams: function () {
            const state = this.model.get({ raw: true });
            return {
                context: {
                    pivot_measures: state.measures,
                    pivot_column_groupby: state.colGroupBys,
                    pivot_row_groupby: state.rowGroupBys,
                }
            };
        },
        /**
         * Render the buttons according to the PivotView.buttons template and
         * add listeners on it.
         * Set this.$buttons with the produced jQuery element
         *
         * @override
         * @param {jQuery} [$node] a jQuery node where the rendered buttons should
         *   be inserted. $node may be undefined, in which case the PivotView
         *   does nothing
         */
        renderButtons: function ($node) {
            const context = this._getRenderButtonContext();
            this.$buttons = $(QWeb.render('PivotView.buttons', context));
            this.$buttons.click(this._onButtonClick.bind(this));
            this.$buttons.find('button').tooltip();
            if ($node) {
                this.$buttons.appendTo($node);
            }
        },
        /**
         * @override
         */
        updateButtons: function () {
            if (!this.$buttons) {
                return;
            }
            const state = this.model.get({ raw: true });
            Object.entries(this.measures).forEach(elt => {
                const name = elt[0];
                const isSelected = state.measures.includes(name);
                this.$buttons.find('.dropdown-item[data-field="' + name + '"]')
                    .toggleClass('selected', isSelected);

            });
            const noDataDisplayed = !state.hasData || !state.measures.length;
            this.$buttons.find('.o_pivot_flip_button').prop('disabled', noDataDisplayed);
            this.$buttons.find('.o_pivot_expand_button').prop('disabled', noDataDisplayed);
            this.$buttons.find('.o_pivot_download').prop('disabled', noDataDisplayed);
        },

        //--------------------------------------------------------------------------
        // Private
        //--------------------------------------------------------------------------

        /**
         * Export the current pivot table data in a xls file. For this, we have to
         * serialize the current state, then call the server /web/pivot/export_xlsx.
         * Force a reload before exporting to ensure to export up-to-date data.
         *
         * @private
         */
        _downloadTable: function () {
            if (this.model.getTableWidth() > 16384) {
                this.call('crash_manager', 'show_message', _t("For Excel compatibility, data cannot be exported if there are more than 16384 columns.\n\nTip: try to flip axis, filter further or reduce the number of measures."));
                framework.unblockUI();
                return;
            }
            const table = this.model.exportData();
            table.title = this.title;
            table.model = this.modelName;
            session.get_file({
                url: '/web/pivot/export_xlsx',
                data: { data: JSON.stringify(table) },
                complete: framework.unblockUI,
                error: (error) => this.call('crash_manager', 'rpc_error', error),
            });
        },

        //--------------------------------------------------------------------------
        // Handlers
        //--------------------------------------------------------------------------

        /**
         * This handler is called when the user clicked on a button in the control
         * panel.  We then have to react properly: it can either be a change in the
         * current measures, or a request to flip/expand/download data.
         *
         * @private
         * @param {MouseEvent} ev
         */
        _onButtonClick: async function (ev) {
            const $target = $(ev.target);
            if ($target.hasClass('o_pivot_flip_button')) {
                this.model.flip();
                this.update({}, { reload: false });
            }
            if ($target.hasClass('o_pivot_expand_button')) {
                await this.model.expandAll();
                this.update({}, { reload: false });
            }
            if (ev.target.closest('.o_pivot_measures_list')) {
                ev.preventDefault();
                ev.stopPropagation();
                const field = ev.target.dataset.field;
                if (field) {
                    this.update({ measure: field });
                }
            }
            if ($target.hasClass('o_pivot_download')) {
                this._downloadTable();
            }

            await this._addIncludedButtons(ev);
        },

        /**
         * Declared to be overwritten in includes of pivot controller
         *
         * @param {MouseEvent} ev
         * @returns {Promise<void>}
         * @private
         */
        _addIncludedButtons: async function(ev) {},
        /**
         * Get the context of rendering of the buttons
         *
         * @returns {Object}
         * @private
         */
        _getRenderButtonContext: function () {
            return {
                measures: Object.entries(this.measures)
                .filter(x => x[0] !== '__count')
                .sort((a, b) => a[1].string.toLowerCase() > b[1].string.toLowerCase() ? 1 : -1),
            };
        },
        /**
         *
         * @private
         * @param {OdooEvent} ev
         */
        _onCloseGroup: function (ev) {
            this.model.closeGroup(ev.data.groupId, ev.data.type);
            this.update({}, { reload: false });
        },
        /**
         * @param {CustomEvent} ev
         * @private
         * */
        _onOpenedHeaderClicked: function (ev) {
            this.model.closeGroup(ev.data.cell.groupId, ev.data.type);
            this.update({}, { reload: false });
        },
        /**
         * @param {CustomEvent} ev
         * @private
         * */
        _onClosedHeaderClicked: async function (ev) {
            const cell = ev.data.cell;
            const groupId = cell.groupId;
            const type = ev.data.type;

            const group = {
                rowValues: groupId[0],
                colValues: groupId[1],
                type: type
            };

            const state = this.model.get({ raw: true });
            const groupValues = type === 'row' ? groupId[0] : groupId[1];
            const groupBys = type === 'row' ?
                state.rowGroupBys :
                state.colGroupBys;
            this.selectedGroup = group;
            if (groupValues.length < groupBys.length) {
                const groupBy = groupBys[groupValues.length];
                await this.model.expandGroup(this.selectedGroup, groupBy);
                this.update({}, { reload: false });
            }
        },
        /**
         * This handler is called when the user selects a groupby in the dropdown menu.
         *
         * @private
         * @param {CustomEvent} ev
         */
        _onGroupByMenuSelection: async function (ev) {
            ev.stopPropagation();

            const { fieldName, interval } = ev.data;
            let groupBy = fieldName;
            if (interval) {
                groupBy = `${groupBy}:${interval}`;
            }
            this.model.addGroupBy(groupBy, this.selectedGroup.type);
            await this.model.expandGroup(this.selectedGroup, groupBy);
            this.update({}, { reload: false });
        },
        /**
         * @private
         * @param {CustomEvent} ev
         */
        _onOpenView: function (ev) {
            ev.stopPropagation();
            const cell = ev.data;
            if (cell.value === undefined || this.disableLinking) {
                return;
            }

            const context = Object.assign({}, this.model.data.context);
            Object.keys(context).forEach(x => {
                if (x === 'group_by' || x.startsWith('search_default_')) {
                    delete context[x];
                }
            });

            const group = {
                rowValues: cell.groupId[0],
                colValues: cell.groupId[1],
                originIndex: cell.originIndexes[0]
            };

            const domain = this.model._getGroupDomain(group);

            this.do_action({
                type: 'ir.actions.act_window',
                name: this.title,
                res_model: this.modelName,
                views: this.views,
                view_mode: 'list',
                target: 'current',
                context: context,
                domain: domain,
            });
        },
        /**
         * @private
         * @param {CustomEvent} ev
         */
        _onSortRows: function (ev) {
            this.model.sortRows({
                groupId: ev.data.groupId,
                measure: ev.data.measure,
                order: (ev.data.order || 'desc') === 'asc' ? 'desc' : 'asc',
                originIndexes: ev.data.originIndexes,
            });
            this.update({}, { reload: false });
        },
    });

    __exports[Symbol.for("default")] = PivotController;

return __exports;
});

odoo.define(`web.PivotController`, async function(require) {
                        return require('@web/legacy/js/views/pivot/pivot_controller')[Symbol.for("default")];
                        });
;

/*******************************************************************
*  Filepath: /web/static/src/legacy/js/views/pivot/pivot_model.js  *
*  Bundle: web.assets_backend_legacy_lazy                          *
*  Lines: 1555                                                     *
*******************************************************************/
odoo.define('@web/legacy/js/views/pivot/pivot_model', async function (require) {
'use strict';
let __exports = {};
/** @odoo-module alias=web.PivotModel **/

/**
 * Pivot Model
 *
 * The pivot model keeps an in-memory representation of the pivot table that is
 * displayed on the screen.  The exact layout of this representation is not so
 * simple, because a pivot table is at its core a 2-dimensional object, but
 * with a 'tree' component: some rows/cols can be expanded so we zoom into the
 * structure.
 *
 * However, we need to be able to manipulate the data in a somewhat efficient
 * way, and to transform it into a list of lines to be displayed by the renderer.
 *
 * Basicaly the pivot table presents aggregated values for various groups of records
 * in one domain. If a comparison is asked for, two domains are considered.
 *
 * Let us consider a simple example and let us fix the vocabulary (let us suppose we are in June 2020):
 * ___________________________________________________________________________________________________________________________________________
 * |                    |   Total                                                                                                             |
 * |                    |_____________________________________________________________________________________________________________________|
 * |                    |   Sale Team 1                         |  Sale Team 2                         |                                      |
 * |                    |_______________________________________|______________________________________|______________________________________|
 * |                    |   Sales total                         |  Sales total                         |  Sales total                         |
 * |                    |_______________________________________|______________________________________|______________________________________|
 * |                    |   May 2020   | June 2020  | Variation |  May 2020   | June 2020  | Variation |  May 2020   | June 2020  | Variation |
 * |____________________|______________|____________|___________|_____________|____________|___________|_____________|____________|___________|
 * | Total              |     85       |     110    |  29.4%    |     40      |    30      |   -25%    |    125      |    140     |     12%   |
 * |    Europe          |     25       |     35     |    40%    |     40      |    30      |   -25%    |     65      |     65     |      0%   |
 * |        Brussels    |      0       |     15     |   100%    |     30      |    30      |     0%    |     30      |     45     |     50%   |
 * |        Paris       |     25       |     20     |   -20%    |     10      |     0      |  -100%    |     35      |     20     |  -42.8%   |
 * |    North America   |     60       |     75     |    25%    |             |            |           |     60      |     75     |     25%   |
 * |        Washington  |     60       |     75     |    25%    |             |            |           |     60      |     75     |     25%   |
 * |____________________|______________|____________|___________|_____________|____________|___________|_____________|____________|___________|
 *
 *
 * META DATA:
 *
 * In the above pivot table, the records have been grouped using the fields
 *
 *      continent_id, city_id
 *
 * for rows and
 *
 *      sale_team_id
 *
 * for columns.
 *
 * The measure is the field 'sales_total'.
 *
 * Two domains are considered: 'May 2020' and 'June 2020'.
 *
 * In the model,
 *
 *      - rowGroupBys is the list [continent_id, city_id]
 *      - colGroupBys is the list [sale_team_id]
 *      - measures is the list [sales_total]
 *      - domains is the list [d1, d2] with d1 and d2 domain expressions
 *          for say sale_date in May 2020 and June 2020, for instance
 *          d1 = [['sale_date', >=, 2020-05-01], ['sale_date', '<=', 2020-05-31]]
 *      - origins is the list ['May 2020', 'June 2020']
 *
 * DATA:
 *
 * Recall that a group is constituted by records (in a given domain)
 * that have the same (raw) values for a list of fields.
 * Thus the group itself is identified by this list and the domain.
 * In comparison mode, the same group (forgetting the domain part or 'originIndex')
 * can be eventually found in the two domains.
 * This defines the way in which the groups are identified or not.
 *
 * In the above table, (forgetting the domain) the following groups are found:
 *
 *      the 'row groups'
 *      - Total
 *      - Europe
 *      - America
 *      - Europe, Brussels
 *      - Europe, Paris
 *      - America, Washington
 *
 *      the 'col groups'
 *
 *      - Total
 *      - Sale Team 1
 *      - Sale Team 2
 *
 *      and all non trivial combinations of row groups and col groups
 *
 *      - Europe, Sale Team 1
 *      - Europe, Brussels, Sale Team 2
 *      - America, Washington, Sale Team 1
 *      - ...
 *
 * The list of fields is created from the concatenation of two lists of fields, the first in
 *
 * [], [f1], [f1, f2], ... [f1, f2, ..., fn]  for [f1, f2, ..., fn] the full list of groupbys
 * (called rowGroupBys) used to create row groups
 *
 * In the example: [], [continent_id], [continent_id, city_id].
 *
 * and the second in
 * [], [g1], [g1, g2], ... [g1, g2, ..., gm]  for [g1, g2, ..., gm] the full list of groupbys
 * (called colGroupBys) used to create col groups.
 *
 * In the example: [], [sale_team_id].
 *
 * Thus there are (n+1)*(m+1) lists of fields possible.
 *
 * In the example: 6 lists possible, namely [],
 *                                          [continent_id], [sale_team_id],
 *                                          [continent_id, sale_team_id], [continent_id, city_id],
 *                                          [continent_id, city_id, sale_team_id]
 *
 * A given list is thus of the form [f1,..., fi, g1,..., gj] or better [[f1,...,fi], [g1,...,gj]]
 *
 * For each list of fields possible and each domain considered, one read_group is done
 * and gives results of the form (an exception for list [])
 *
 * g = {
 *  f1: v1, ..., fi: vi,
 *  g1: w1, ..., gj: wj,
 *  m1: x1, ..., mk: xk,
 *  __count: c,
 *  __domain: d
 * }
 *
 * where v1,...,vi,w1,...,Wj are 'values' for the corresponding fields and
 * m1,...,mk are the fields selected as measures.
 *
 * For example, g = {
 *      continent_id: [1, 'Europe']
 *      sale_team_id: [1, 'Sale Team 1']
 *      sales_count: 25,
 *      __count: 4
 *      __domain: [
 *                  ['sale_date', >=, 2020-05-01], ['sale_date', '<=', 2020-05-31],
 *                  ['continent_id', '=', 1],
 *                  ['sale_team_id', '=', 1]
 *                ]
 * }
 *
 * Thus the above group g is fully determined by [[v1,...,vi], [w1,...,wj]] and the base domain
 * or the corresponding 'originIndex'.
 *
 * When j=0, g corresponds to a row group (or also row header) and is of the form [[v1,...,vi], []] or more simply [v1,...vi]
 * (not forgetting the list [v1,...vi] comes from left).
 * When i=0, g corresponds to a col group (or col header) and is of the form [[], [w1,...,wj]] or more simply [w1,...,wj].
 *
 * A generic group g as above [[v1,...,vi], [w1,...,wj]] corresponds to the two headers [[v1,...,vi], []]
 * and [[], [w1,...,wj]].
 *
 * Here is a description of the data structure manipulated by the pivot model.
 *
 * Five objects contain all the data from the read_groups
 *
 *      - rowGroupTree: contains information on row headers
 *             the nodes correspond to the groups of the form [[v1,...,vi], []]
 *             The root is [[], []].
 *             A node [[v1,...,vl], []] has as direct children the nodes of the form [[v1,...,vl,v], []],
 *             this means that a direct child is obtained by grouping records using the single field fi+1
 *
 *             The structure at each level is of the form
 *
 *             {
 *                  root: {
 *                      values: [v1,...,vl],
 *                      labels: [la1,...,lal]
 *                  },
 *                  directSubTrees: {
 *                      v => {
 *                              root: {
 *                                  values: [v1,...,vl,v]
 *                                  labels: [label1,...,labell,label]
 *                              },
 *                              directSubTrees: {...}
 *                          },
 *                      v' => {...},
 *                      ...
 *                  }
 *             }
 *
 *             (directSubTrees is a Map instance)
 *
 *             In the example, the rowGroupTree is:
 *
 *             {
 *                  root: {
 *                      values: [],
 *                      labels: []
 *                  },
 *                  directSubTrees: {
 *                      1 => {
 *                              root: {
 *                                  values: [1],
 *                                  labels: ['Europe'],
 *                              },
 *                              directSubTrees: {
 *                                  1 => {
 *                                          root: {
 *                                              values: [1, 1],
 *                                              labels: ['Europe', 'Brussels'],
 *                                          },
 *                                          directSubTrees: new Map(),
 *                                  },
 *                                  2 => {
 *                                          root: {
 *                                              values: [1, 2],
 *                                              labels: ['Europe', 'Paris'],
 *                                          },
 *                                          directSubTrees: new Map(),
 *                                  },
 *                              },
 *                          },
 *                      2 => {
 *                              root: {
 *                                  values: [2],
 *                                  labels: ['America'],
 *                              },
 *                              directSubTrees: {
 *                                  3 => {
 *                                          root: {
 *                                              values: [2, 3],
 *                                              labels: ['America', 'Washington'],
 *                                          }
 *                                          directSubTrees: new Map(),
 *                                  },
 *                              },
 *                      },
 *                  },
 *             }
 *
 *      - colGroupTree: contains information on col headers
 *              The same as above with right instead of left
 *
 *      - measurements: contains information on measure values for all the groups
 *
 *              the object keys are of the form JSON.stringify([[v1,...,vi], [w1,...,wj]])
 *              and values are arrays of length equal to number of origins containing objects of the form
 *                  {m1: x1,...,mk: xk}
 *              The structure looks like
 *
 *              {
 *                  JSON.stringify([[], []]): [{m1: x1,...,mk: xk}, {m1: x1',...,mk: xk'},...]
 *                  ....
 *                  JSON.stringify([[v1,...,vi], [w1,...,wj]]): [{m1: y1',...,mk: yk'}, {m1: y1',...,mk: yk'},...],
 *                  ....
 *                  JSON.stringify([[v1,...,vn], [w1,...,wm]]): [{m1: z1',...,mk: zk'}, {m1: z1',...,mk: zk'},...],
 *              }
 *              Thus the structure contains all information for all groups and all origins on measure values.
 *
 *
 *              this.measurments["[[], []]"][0]['foo'] gives the value of the measure 'foo' for the group 'Total' and the
 *              first domain (origin).
 *
 *              In the example:
 *                  {
 *                      "[[], []]": [{'sales_total': 125}, {'sales_total': 140}]                      (total/total)
 *                      ...
 *                      "[[1, 2], [2]]": [{'sales_total': 10}, {'sales_total': 0}]                   (Europe/Paris/Sale Team 2)
 *                      ...
 *                  }
 *
 *      - counts: contains information on the number of records in each groups
 *              The structure is similar to the above but the arrays contains numbers (counts)
 *      - groupDomains:
 *              The structure is similar to the above but the arrays contains domains
 *
 *      With this light data structures, all manipulation done by the model are eased and redundancies are limited.
 *      Each time a rendering or an export of the data has to be done, the pivot table is generated by the _getTable function.
 */

const AbstractModel = require("@web/legacy/js/views/abstract_model")[Symbol.for("default")];
const concurrency = require('web.concurrency');
const core = require('web.core');
const dataComparisonUtils = require('web.dataComparisonUtils');
const Domain = require('web.Domain');
const mathUtils = require('@web/core/utils/arrays');
const session = require('web.session');


var _t = core._t;
var cartesian = mathUtils.cartesian;
var computeVariation = dataComparisonUtils.computeVariation;
var sections = mathUtils.sections;

var PivotModel = AbstractModel.extend({
    /**
     * @override
     * @param {Object} params
     */
    init: function () {
        this._super.apply(this, arguments);
        this.numbering = {};
        this.data = null;
        this._loadDataDropPrevious = new concurrency.DropPrevious();
    },

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    /**
     * Add a groupBy to rowGroupBys or colGroupBys according to provided type.
     *
     * @param {string} groupBy
     * @param {'row'|'col'} type
     */
    addGroupBy: function (groupBy, type) {
        if (type === 'row') {
            this.data.expandedRowGroupBys.push(groupBy);
        } else {
            this.data.expandedColGroupBys.push(groupBy);
        }
    },
    /**
     * Close the group with id given by groupId. A type must be specified
     * in case groupId is [[], []] (the id of the group 'Total') because this
     * group is present in both colGroupTree and rowGroupTree.
     *
     * @param {Array[]} groupId
     * @param {'row'|'col'} type
     */
    closeGroup: function (groupId, type) {
        var groupBys;
        var expandedGroupBys;
        let keyPart;
        var group;
        var tree;
        if (type === 'row') {
            groupBys = this.data.rowGroupBys;
            expandedGroupBys = this.data.expandedRowGroupBys;
            tree = this.rowGroupTree;
            group = this._findGroup(this.rowGroupTree, groupId[0]);
            keyPart = 0;
        } else {
            groupBys = this.data.colGroupBys;
            expandedGroupBys = this.data.expandedColGroupBys;
            tree = this.colGroupTree;
            group = this._findGroup(this.colGroupTree, groupId[1]);
            keyPart = 1;
        }

        const groupIdPart = groupId[keyPart];
        const range = groupIdPart.map((_, index) => index);
        function keep(key) {
            const idPart = JSON.parse(key)[keyPart];
            return range.some(index => groupIdPart[index] !== idPart[index]) ||
                    idPart.length ===  groupIdPart.length;
        }
        function omitKeys(object) {
            const newObject = {};
            for (const key in object) {
                if (keep(key)) {
                    newObject[key] = object[key];
                }
            }
            return newObject;
        }
        this.measurements = omitKeys(this.measurements);
        this.counts = omitKeys(this.counts);
        this.groupDomains = omitKeys(this.groupDomains);

        group.directSubTrees.clear();
        delete group.sortedKeys;
        var newGroupBysLength = this._getTreeHeight(tree) - 1;
        if (newGroupBysLength <= groupBys.length) {
            expandedGroupBys.splice(0);
            groupBys.splice(newGroupBysLength);
        } else {
            expandedGroupBys.splice(newGroupBysLength - groupBys.length);
        }
    },
    /**
     * Reload the view with the current rowGroupBys and colGroupBys
     * This is the easiest way to expand all the groups that are not expanded
     *
     * @returns {Promise}
     */
    expandAll: function () {
        return this._loadData();
    },
    /**
     * Expand a group by using groupBy to split it.
     *
     * @param {Object} group
     * @param {string} groupBy
     * @returns {Promise}
     */
    expandGroup: async function (group, groupBy) {
        var leftDivisors;
        var rightDivisors;

        if (group.type === 'row') {
            leftDivisors = [[groupBy]];
            rightDivisors = sections(this._getGroupBys().colGroupBys);
        } else {
            leftDivisors = sections(this._getGroupBys().rowGroupBys);
            rightDivisors = [[groupBy]];
        }
        var divisors = cartesian(leftDivisors, rightDivisors);

        delete group.type;
        return this._subdivideGroup(group, divisors);
    },
    /**
     * Export model data in a form suitable for an easy encoding of the pivot
     * table in excell.
     *
     * @returns {Object}
     */
    exportData: function () {
        var measureCount = this.data.measures.length;
        var originCount = this.data.origins.length;

        var table = this._getTable();

        // process headers
        var headers = table.headers;
        var colGroupHeaderRows;
        var measureRow = [];
        var originRow = [];

        function processHeader(header) {
            var inTotalColumn = header.groupId[1].length === 0;
            return {
                title: header.title,
                width: header.width,
                height: header.height,
                is_bold: !!header.measure && inTotalColumn
            };
        }

        if (originCount > 1) {
            colGroupHeaderRows = headers.slice(0, headers.length - 2);
            measureRow = headers[headers.length - 2].map(processHeader);
            originRow = headers[headers.length - 1].map(processHeader);
        } else {
            colGroupHeaderRows = headers.slice(0, headers.length - 1);
            measureRow = headers[headers.length - 1].map(processHeader);
        }

        // remove the empty headers on left side
        colGroupHeaderRows[0].splice(0, 1);

        colGroupHeaderRows = colGroupHeaderRows.map(function (headerRow) {
            return headerRow.map(processHeader);
        });

        // process rows
        var tableRows = table.rows.map(function (row) {
            return {
                title: row.title,
                indent: row.indent,
                values: row.subGroupMeasurements.map(function (measurement) {
                    var value = measurement.value;
                    if (value === undefined) {
                        value = "";
                    } else if (measurement.originIndexes.length > 1) {
                        // in that case the value is a variation and a
                        // number between 0 and 1
                        value = value * 100;
                    }
                    return {
                        is_bold: measurement.isBold,
                        value: value,
                    };
                }),
            };
        });

        return {
            col_group_headers: colGroupHeaderRows,
            measure_headers: measureRow,
            origin_headers: originRow,
            rows: tableRows,
            measure_count: measureCount,
            origin_count: originCount,
        };
    },
    /**
     * Swap the pivot columns and the rows. It is a synchronous operation.
     */
    flip: function () {
        // swap the data: the main column and the main row
        var temp = this.rowGroupTree;
        this.rowGroupTree = this.colGroupTree;
        this.colGroupTree = temp;

        // we need to update the record metadata: (expanded) row and col groupBys
        temp = this.data.rowGroupBys;
        this.data.groupedBy = this.data.colGroupBys;
        this.data.rowGroupBys = this.data.colGroupBys;
        this.data.colGroupBys = temp;
        temp = this.data.expandedColGroupBys;
        this.data.expandedColGroupBys = this.data.expandedRowGroupBys;
        this.data.expandedRowGroupBys = temp;

        function twistKey(key) {
            return JSON.stringify(JSON.parse(key).reverse());
        }

        function twist(object) {
            var newObject = {};
            Object.keys(object).forEach(function (key) {
                var value = object[key];
                newObject[twistKey(key)] = value;
            });
            return newObject;
        }

        this.measurements = twist(this.measurements);
        this.counts = twist(this.counts);
        this.groupDomains = twist(this.groupDomains);
    },
    /**
     * @override
     *
     * @param {Object} [options]
     * @param {boolean} [options.raw=false]
     * @returns {Object}
     */
    __get: function (options) {
        options = options || {};
        var raw = options.raw || false;
        var groupBys = this._getGroupBys();
        var state = {
            colGroupBys: groupBys.colGroupBys,
            context: this.data.context,
            domain: this.data.domain,
            fields: this.fields,
            hasData: this._hasData(),
            isSample: this.isSampleModel,
            measures: this.data.measures,
            origins: this.data.origins,
            rowGroupBys: groupBys.rowGroupBys,
            modelName: this.modelName
        };
        if (!raw && state.hasData) {
            state.table = this._getTable();
            state.tree = this.rowGroupTree;
        }
        return state;
    },
    /**
     * Returns the total number of columns of the pivot table.
     *
     * @returns {integer}
     */
    getTableWidth: function () {
        var leafCounts = this._getLeafCounts(this.colGroupTree);
        return leafCounts[JSON.stringify(this.colGroupTree.root.values)] + 2;
    },
    /**
     * @override
     *
     * @param {Object} params
     * @param {boolean} [params.compare=false]
     * @param {Object} params.context
     * @param {Object} params.fields
     * @param {string[]} [params.groupedBy]
     * @param {string[]} params.colGroupBys
     * @param {Array[]} params.domain
     * @param {string[]} params.measures
     * @param {string[]} params.rowGroupBys
     * @param {string} [params.default_order]
     * @param {string} params.modelName
     * @param {Object} params.timeRanges
     * @returns {Promise}
     */
    __load: function (params) {
        this.initialDomain = params.domain;
        this.initialRowGroupBys = params.context.pivot_row_groupby || params.rowGroupBys;
        this.defaultGroupedBy = params.groupedBy;

        this.fields = params.fields;
        this.modelName = params.modelName;
        const measures = this._processMeasures(params.context.pivot_measures) ||
                            params.measures.map(m => m);
        this.data = {
            expandedRowGroupBys: [],
            expandedColGroupBys: [],
            domain: this.initialDomain,
            context: _.extend({}, session.user_context, params.context),
            groupedBy: params.context.pivot_row_groupby || params.groupedBy,
            colGroupBys: params.context.pivot_column_groupby || params.colGroupBys,
            measures,
            timeRanges: params.timeRanges,
        };
        this._computeDerivedParams();

        this.data.groupedBy = this.data.groupedBy.slice();
        this.data.rowGroupBys = !_.isEmpty(this.data.groupedBy) ? this.data.groupedBy : this.initialRowGroupBys.slice();

        var defaultOrder = params.default_order && params.default_order.split(' ');
        if (defaultOrder) {
            this.data.sortedColumn = {
                groupId: [[], []],
                measure: defaultOrder[0],
                order: defaultOrder[1] ? defaultOrder [1] : 'asc',
            };
        }
        return this._loadData();
    },
    /**
     * @override
     *
     * @param {any} handle this parameter is ignored
     * @param {Object} params
     * @param {boolean} [params.compare=false]
     * @param {Object} params.context
     * @param {string[]} [params.groupedBy]
     * @param {Array[]} params.domain
     * @param {string[]} params.groupBy
     * @param {string[]} params.measures
     * @param {Object} [params.timeRanges]
     * @returns {Promise}
     */
    __reload: function (handle, params) {
        var self = this;
        var oldColGroupBys = this.data.colGroupBys;
        var oldRowGroupBys = this.data.rowGroupBys;
        if ('context' in params) {
            this.data.context = params.context;
            this.data.colGroupBys = params.context.pivot_column_groupby || this.data.colGroupBys;
            this.data.groupedBy = params.context.pivot_row_groupby || this.data.groupedBy;
            this.data.measures = this._processMeasures(params.context.pivot_measures) || this.data.measures;
            this.defaultGroupedBy = this.data.groupedBy.length ? this.data.groupedBy : this.defaultGroupedBy;
        }
        if ('domain' in params) {
            this.data.domain = params.domain;
            this.initialDomain = params.domain;
        } else {
            this.data.domain = this.initialDomain;
        }
        if ('groupBy' in params) {
            this.data.groupedBy = params.groupBy.length ? params.groupBy : this.defaultGroupedBy;
        }
        if ('timeRanges' in params) {
            this.data.timeRanges = params.timeRanges;
        }
        this._computeDerivedParams();

        this.data.groupedBy = this.data.groupedBy.slice();
        this.data.rowGroupBys = !_.isEmpty(this.data.groupedBy) ? this.data.groupedBy : this.initialRowGroupBys.slice();

        if (!_.isEqual(oldRowGroupBys, self.data.rowGroupBys)) {
            this.data.expandedRowGroupBys = [];
        }
        if (!_.isEqual(oldColGroupBys, self.data.colGroupBys)) {
            this.data.expandedColGroupBys = [];
        }

        if ('measure' in params) {
            return this._toggleMeasure(params.measure);
        }

        if (!this._hasData()) {
            return this._loadData();
        }

        var oldRowGroupTree = this.rowGroupTree;
        var oldColGroupTree = this.colGroupTree;
        return this._loadData().then(function () {
            if (_.isEqual(oldRowGroupBys, self.data.rowGroupBys)) {
                self._pruneTree(self.rowGroupTree, oldRowGroupTree);
            }
            if (_.isEqual(oldColGroupBys, self.data.colGroupBys)) {
                self._pruneTree(self.colGroupTree, oldColGroupTree);
            }
        });
    },
    /**
     * Sort the rows, depending on the values of a given column.  This is an
     * in-memory sort.
     *
     * @param {Object} sortedColumn
     * @param {number[]} sortedColumn.groupId
     */
    sortRows: function (sortedColumn) {
        var self = this;
        var colGroupValues = sortedColumn.groupId[1];
        sortedColumn.originIndexes = sortedColumn.originIndexes || [0];
        this.data.sortedColumn = sortedColumn;

        var sortFunction = function (tree) {
            return function (subTreeKey) {
                var subTree = tree.directSubTrees.get(subTreeKey);
                var groupIntersectionId = [subTree.root.values, colGroupValues];
                var value = self._getCellValue(
                    groupIntersectionId,
                    sortedColumn.measure,
                    sortedColumn.originIndexes
                ) || 0;
                return sortedColumn.order === 'asc' ? value : -value;
            };
        };

        this._sortTree(sortFunction, this.rowGroupTree);
    },

    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------

    /**
     * Add labels/values in the provided groupTree. A new leaf is created in
     * the groupTree with a root object corresponding to the group with given
     * labels/values.
     *
     * @private
     * @param {Object} groupTree, either this.rowGroupTree or this.colGroupTree
     * @param {string[]} labels
     * @param {Array} values
     */
    _addGroup: function (groupTree, labels, values) {
        var tree = groupTree;
        // we assume here that the group with value value.slice(value.length - 2) has already been added.
        values.slice(0, values.length - 1).forEach(function (value) {
            tree = tree.directSubTrees.get(value);
        });
        const value = values[values.length - 1];
        if (tree.directSubTrees.has(value)) {
            return;
        }
        tree.directSubTrees.set(value, {
            root: {
                labels: labels,
                values: values,
            },
            directSubTrees: new Map(),
        });
    },
    /**
     * Compute what should be used as rowGroupBys by the pivot view
     *
     * @private
     * @returns {string[]}
     */
    _computeRowGroupBys: function () {
        return !_.isEmpty(this.data.groupedBy) ? this.data.groupedBy : this.initialRowGroupBys;
    },
    /**
     * Find a group with given values in the provided groupTree, either
     * this.rowGrouptree or this.colGroupTree.
     *
     * @private
     * @param  {Object} groupTree
     * @param  {Array} values
     * @returns {Object}
     */
    _findGroup: function (groupTree, values) {
        var tree = groupTree;
        values.slice(0, values.length).forEach(function (value) {
            tree = tree.directSubTrees.get(value);
        });
        return tree;
    },
    /**
     * In case originIndex is an array of length 1, thus a single origin
     * index, returns the given measure for a group determined by the id
     * groupId and the origin index.
     * If originIndexes is an array of length 2, we compute the variation
     * ot the measure values for the groups determined by groupId and the
     * different origin indexes.
     *
     * @private
     * @param  {Array[]} groupId
     * @param  {string} measure
     * @param  {number[]} originIndexes
     * @returns {number}
     */
    _getCellValue: function (groupId, measure, originIndexes) {
        var self = this;
        var key = JSON.stringify(groupId);
        if (!self.measurements[key]) {
            return;
        }
        var values = originIndexes.map(function (originIndex) {
            return self.measurements[key][originIndex][measure];
        });
        if (originIndexes.length > 1) {
            return computeVariation(values[1], values[0]);
        } else {
            return values[0];
        }
    },
    /**
     * Returns the rowGroupBys and colGroupBys arrays that
     * are actually used by the pivot view internally
     * (for read_group or other purpose)
     *
     * @private
     * @returns {Object} with keys colGroupBys and rowGroupBys
     */
    _getGroupBys: function () {
        return {
            colGroupBys: this.data.colGroupBys.concat(this.data.expandedColGroupBys),
            rowGroupBys: this.data.rowGroupBys.concat(this.data.expandedRowGroupBys),
        };
    },
    /**
     * Returns a domain representation of a group
     *
     * @private
     * @param  {Object} group
     * @param  {Array} group.colValues
     * @param  {Array} group.rowValues
     * @param  {number} group.originIndex
     * @returns {Array[]}
     */
    _getGroupDomain: function (group) {
        var key = JSON.stringify([group.rowValues, group.colValues]);
        return this.groupDomains[key][group.originIndex];
    },
    /**
     * Returns the group sanitized labels.
     *
     * @private
     * @param  {Object} group
     * @param  {string[]} groupBys
     * @returns {string[]}
     */
    _getGroupLabels: function (group, groupBys) {
        var self = this;
        return groupBys.map(function (groupBy) {
            return self._sanitizeLabel(group[groupBy], groupBy);
        });
    },
    /**
     * Returns a promise that returns the annotated read_group results
     * corresponding to a partition of the given group obtained using the given
     * rowGroupBy and colGroupBy.
     *
     * @private
     * @param  {Object} group
     * @param  {string[]} rowGroupBy
     * @param  {string[]} colGroupBy
     * @returns {Promise}
     */
    _getGroupSubdivision: function (group, rowGroupBy, colGroupBy) {
        var groupDomain = this._getGroupDomain(group);
        var measureSpecs = this._getMeasureSpecs();
        var groupBy = rowGroupBy.concat(colGroupBy);
        return this._rpc({
            model: this.modelName,
            method: 'read_group',
            context: this.data.context,
            domain: groupDomain,
            fields: measureSpecs,
            groupBy: groupBy,
            lazy: false,
        }).then(function (subGroups) {
            return {
                group: group,
                subGroups: subGroups,
                rowGroupBy: rowGroupBy,
                colGroupBy: colGroupBy
            };
        });
    },
    /**
     * Returns the group sanitized values.
     *
     * @private
     * @param  {Object} group
     * @param  {string[]} groupBys
     * @returns {Array}
     */
    _getGroupValues: function (group, groupBys) {
        var self = this;
        return groupBys.map(function (groupBy) {
            return self._sanitizeValue(group[groupBy]);
        });
    },
    /**
     * Returns the leaf counts of each group inside the given tree.
     *
     * @private
     * @param {Object} tree
     * @returns {Object} keys are group ids
     */
    _getLeafCounts: function (tree) {
        var self = this;
        var leafCounts = {};
        var leafCount;
        if (!tree.directSubTrees.size) {
            leafCount = 1;
        } else {
            leafCount = [...tree.directSubTrees.values()].reduce(
                function (acc, subTree) {
                    var subLeafCounts = self._getLeafCounts(subTree);
                    _.extend(leafCounts, subLeafCounts);
                    return acc + leafCounts[JSON.stringify(subTree.root.values)];
                },
                0
            );
        }

        leafCounts[JSON.stringify(tree.root.values)] = leafCount;
        return leafCounts;
    },
    /**
     * Returns the group sanitized measure values for the measures in
     * this.data.measures (that migth contain '__count', not really a fieldName).
     *
     * @private
     * @param  {Object} group
     * @returns {Array}
     */
    _getMeasurements: function (group) {
        var self = this;
        return this.data.measures.reduce(
            function (measurements, fieldName) {
                var measurement = group[fieldName];
                if (measurement instanceof Array) {
                    // case field is many2one and used as measure and groupBy simultaneously
                    measurement = 1;
                }
                if (self.fields[fieldName].type === 'boolean' && measurement instanceof Boolean) {
                    measurement = measurement ? 1 : 0;
                }
                if (self.data.origins.length > 1 && !measurement) {
                    measurement = 0;
                }
                measurements[fieldName] = measurement;
                return measurements;
            },
            {}
        );
    },
    /**
     * Returns a description of the measures row of the pivot table
     *
     * @private
     * @param {Object[]} columns for which measure cells must be generated
     * @returns {Object[]}
     */
    _getMeasuresRow: function (columns) {
        var self = this;
        var sortedColumn = this.data.sortedColumn || {};
        var measureRow = [];

        columns.forEach(function (column) {
            self.data.measures.forEach(function (measure) {
                var measureCell = {
                    groupId: column.groupId,
                    height: 1,
                    measure: measure,
                    title: self.fields[measure].string,
                    width: 2 * self.data.origins.length - 1,
                };
                if (sortedColumn.measure === measure &&
                    _.isEqual(sortedColumn.groupId, column.groupId)) {
                    measureCell.order = sortedColumn.order;
                }
                measureRow.push(measureCell);
            });
        });

        return measureRow;
    },
    /**
     * Returns the list of measure specs associated with data.measures, i.e.
     * a measure 'fieldName' becomes 'fieldName:groupOperator' where
     * groupOperator is the value specified on the field 'fieldName' for
     * the key group_operator.
     *
     * @private
     * @return {string[]}
     */
    _getMeasureSpecs: function () {
        var self = this;
        return this.data.measures.reduce(
            function (acc, measure) {
                if (measure === '__count') {
                    acc.push(measure);
                    return acc;
                }
                var type = self.fields[measure].type;
                var groupOperator = self.fields[measure].group_operator;
                if (type === 'many2one') {
                    groupOperator = 'count_distinct';
                }
                if (groupOperator === undefined) {
                    throw new Error("No aggregate function has been provided for the measure '" + measure + "'");
                }
                acc.push(measure + ':' + groupOperator);
                return acc;
            },
            []
        );
    },
    /**
     * Make sure that the labels of different many2one values are distinguished
     * by numbering them if necessary.
     *
     * @private
     * @param {Array} label
     * @param {string} fieldName
     * @returns {string}
     */
    _getNumberedLabel: function (label, fieldName) {
        var id = label[0];
        var name = label[1];
        this.numbering[fieldName] = this.numbering[fieldName] || {};
        this.numbering[fieldName][name] = this.numbering[fieldName][name] || {};
        var numbers = this.numbering[fieldName][name];
        numbers[id] = numbers[id] || _.size(numbers) + 1;
        return name + (numbers[id] > 1 ? "  (" + numbers[id] + ")" : "");
    },
    /**
     * Returns a description of the origins row of the pivot table
     *
     * @private
     * @param {Object[]} columns for which origin cells must be generated
     * @returns {Object[]}
     */
    _getOriginsRow: function (columns) {
        var self = this;
        var sortedColumn = this.data.sortedColumn || {};
        var originRow = [];

        columns.forEach(function (column) {
            var groupId = column.groupId;
            var measure = column.measure;
            var isSorted = sortedColumn.measure === measure &&
                _.isEqual(sortedColumn.groupId, groupId);
            var isSortedByOrigin = isSorted && !sortedColumn.originIndexes[1];
            var isSortedByVariation = isSorted && sortedColumn.originIndexes[1];

            self.data.origins.forEach(function (origin, originIndex) {
                var originCell = {
                    groupId: groupId,
                    height: 1,
                    measure: measure,
                    originIndexes: [originIndex],
                    title: origin,
                    width: 1,
                };
                if (isSortedByOrigin && sortedColumn.originIndexes[0] === originIndex) {
                    originCell.order = sortedColumn.order;
                }
                originRow.push(originCell);

                if (originIndex > 0) {
                    var variationCell = {
                        groupId: groupId,
                        height: 1,
                        measure: measure,
                        originIndexes: [originIndex - 1, originIndex],
                        title: _t('Variation'),
                        width: 1,
                    };
                    if (isSortedByVariation && sortedColumn.originIndexes[1] === originIndex) {
                        variationCell.order = sortedColumn.order;
                    }
                    originRow.push(variationCell);
                }

            });
        });

        return originRow;
    },

    /**
     * Returns a description of the pivot table.
     *
     * @private
     * @returns {Object}
     */
    _getTable: function () {
        var headers = this._getTableHeaders();
        return {
            headers: headers,
            rows: this._getTableRows(this.rowGroupTree, headers[headers.length - 1]),
        };
    },
    /**
     * Returns the list of header rows of the pivot table: the col group rows
     * (depending on the col groupbys), the measures row and optionnaly the
     * origins row (if there are more than one origins).
     *
     * @private
     * @returns {Object[]}
     */
    _getTableHeaders: function () {
        var colGroupBys = this._getGroupBys().colGroupBys;
        var height = colGroupBys.length + 1;
        var measureCount = this.data.measures.length;
        var originCount = this.data.origins.length;
        var leafCounts = this._getLeafCounts(this.colGroupTree);
        var headers = [];
        var measureColumns = []; // used to generate the measure cells

        // 1) generate col group rows (total row + one row for each col groupby)
        var colGroupRows = (new Array(height)).fill(0).map(function () {
            return [];
        });
        // blank top left cell
        colGroupRows[0].push({
            height: height + 1 + (originCount > 1 ? 1 : 0), // + measures rows [+ origins row]
            title: "",
            width: 1,
        });

        // col groupby cells with group values
        /**
         * Recursive function that generates the header cells corresponding to
         * the groups of a given tree.
         *
         * @param {Object} tree
         */
        function generateTreeHeaders(tree, fields) {
            var group = tree.root;
            var rowIndex = group.values.length;
            var row = colGroupRows[rowIndex];
            var groupId = [[], group.values];
            var isLeaf = !tree.directSubTrees.size;
            var leafCount = leafCounts[JSON.stringify(tree.root.values)];
            var cell = {
                groupId: groupId,
                height: isLeaf ? (colGroupBys.length + 1 - rowIndex) : 1,
                isLeaf: isLeaf,
                isFolded: isLeaf && colGroupBys.length > group.values.length,
                label: rowIndex === 0 ? undefined : fields[colGroupBys[rowIndex - 1].split(':')[0]].string,
                title: group.labels[group.labels.length - 1] || _t('Total'),
                width: leafCount * measureCount * (2 * originCount - 1),
            };
            row.push(cell);
            if (isLeaf) {
                measureColumns.push(cell);
            }

            [...tree.directSubTrees.values()].forEach(function (subTree) {
                generateTreeHeaders(subTree, fields);
            });
        }

        generateTreeHeaders(this.colGroupTree, this.fields);
        // blank top right cell for 'Total' group (if there is more that one leaf)
        if (leafCounts[JSON.stringify(this.colGroupTree.root.values)] > 1) {
            var groupId = [[], []];
            var totalTopRightCell = {
                groupId: groupId,
                height: height,
                title: "",
                width: measureCount * (2 * originCount - 1),
            };
            colGroupRows[0].push(totalTopRightCell);
            measureColumns.push(totalTopRightCell);
        }
        headers = headers.concat(colGroupRows);

        // 2) generate measures row
        var measuresRow = this._getMeasuresRow(measureColumns);
        headers.push(measuresRow);

        // 3) generate origins row if more than one origin
        if (originCount > 1) {
            headers.push(this._getOriginsRow(measuresRow));
        }

        return headers;
    },
    /**
     * Returns the list of body rows of the pivot table for a given tree.
     *
     * @private
     * @param {Object} tree
     * @param {Object[]} columns
     * @returns {Object[]}
     */
    _getTableRows: function (tree, columns) {
        var self = this;

        var rows = [];
        var group = tree.root;
        var rowGroupId = [group.values, []];
        var title = group.labels[group.labels.length - 1] || _t('Total');
        var indent = group.labels.length;
        var isLeaf = !tree.directSubTrees.size;
        var rowGroupBys = this._getGroupBys().rowGroupBys;

        var subGroupMeasurements = columns.map(function (column) {
            var colGroupId = column.groupId;
            var groupIntersectionId = [rowGroupId[0], colGroupId[1]];
            var measure = column.measure;
            var originIndexes = column.originIndexes || [0];

            var value = self._getCellValue(groupIntersectionId, measure, originIndexes);

            var measurement = {
                groupId: groupIntersectionId,
                originIndexes: originIndexes,
                measure: measure,
                value: value,
                isBold: !groupIntersectionId[0].length || !groupIntersectionId[1].length,
            };
            return measurement;
        });

        rows.push({
            title: title,
            label: indent === 0 ? undefined : this.fields[rowGroupBys[indent - 1].split(':')[0]].string,
            groupId: rowGroupId,
            indent: indent,
            isLeaf: isLeaf,
            isFolded: isLeaf && rowGroupBys.length > group.values.length,
            subGroupMeasurements: subGroupMeasurements
        });

        var subTreeKeys = tree.sortedKeys || [...tree.directSubTrees.keys()];
        subTreeKeys.forEach(function (subTreeKey) {
            var subTree = tree.directSubTrees.get(subTreeKey);
            rows = rows.concat(self._getTableRows(subTree, columns));
        });

        return rows;
    },
    /**
     * returns the height of a given groupTree
     *
     * @private
     * @param  {Object} tree, a groupTree
     * @returns {number}
     */
    _getTreeHeight: function (tree) {
        var subTreeHeights = [...tree.directSubTrees.values()].map(this._getTreeHeight.bind(this));
        return Math.max(0, Math.max.apply(null, subTreeHeights)) + 1;
    },
    /**
     * @private
     * @returns {boolean}
     */
    _hasData: function () {
        return (this.counts[JSON.stringify([[], []])] || []).some(function (count) {
            return count > 0;
        });
    },
    /**
     * @override
     */
    _isEmpty() {
        return !this._hasData();
    },
    /**
     * Initilize/Reinitialize this.rowGroupTree, colGroupTree, measurements,
     * counts and subdivide the group 'Total' as many times it is necessary.
     * A first subdivision with no groupBy (divisors.slice(0, 1)) is made in
     * order to see if there is data in the intersection of the group 'Total'
     * and the various origins. In case there is none, nonsupplementary rpc
     * will be done (see the code of subdivideGroup).
     * Once the promise resolves, this.rowGroupTree, colGroupTree,
     * measurements, counts are correctly set.
     *
     * @private
     * @return {Promise}
     */
    _loadData: function () {
        var self = this;

        this.rowGroupTree = { root: { labels: [], values: [] }, directSubTrees: new Map() };
        this.colGroupTree = { root: { labels: [], values: [] }, directSubTrees: new Map() };
        this.measurements = {};
        this.counts = {};

        var key = JSON.stringify([[], []]);
        this.groupDomains = {};
        this.groupDomains[key] = this.data.domains.slice(0);


        var group = { rowValues: [], colValues: [] };
        var groupBys = this._getGroupBys();
        var leftDivisors = sections(groupBys.rowGroupBys);
        var rightDivisors = sections(groupBys.colGroupBys);
        var divisors = cartesian(leftDivisors, rightDivisors);

        return this._subdivideGroup(group, divisors.slice(0, 1)).then(function () {
            return self._subdivideGroup(group, divisors.slice(1));
        });
    },
    /**
     * Extract the information in the read_group results (groupSubdivisions)
     * and develop this.rowGroupTree, colGroupTree, measurements, counts, and
     * groupDomains.
     * If a column needs to be sorted, the rowGroupTree corresponding to the
     * group is sorted.
     *
     * @private
     * @param  {Object} group
     * @param  {Object[]} groupSubdivisions
     */
    _prepareData: function (group, groupSubdivisions) {
        var self = this;

        var groupRowValues = group.rowValues;
        var groupRowLabels = [];
        var rowSubTree = this.rowGroupTree;
        var root;
        if (groupRowValues.length) {
            // we should have labels information on hand! regretful!
            rowSubTree = this._findGroup(this.rowGroupTree, groupRowValues);
            root = rowSubTree.root;
            groupRowLabels = root.labels;
        }

        var groupColValues = group.colValues;
        var groupColLabels = [];
        if (groupColValues.length) {
            root = this._findGroup(this.colGroupTree, groupColValues).root;
            groupColLabels = root.labels;
        }

        groupSubdivisions.forEach(function (groupSubdivision) {
            groupSubdivision.subGroups.forEach(function (subGroup) {

                var rowValues = groupRowValues.concat(self._getGroupValues(subGroup, groupSubdivision.rowGroupBy));
                var rowLabels = groupRowLabels.concat(self._getGroupLabels(subGroup, groupSubdivision.rowGroupBy));

                var colValues = groupColValues.concat(self._getGroupValues(subGroup, groupSubdivision.colGroupBy));
                var colLabels = groupColLabels.concat(self._getGroupLabels(subGroup, groupSubdivision.colGroupBy));

                if (!colValues.length && rowValues.length) {
                    self._addGroup(self.rowGroupTree, rowLabels, rowValues);
                }
                if (colValues.length && !rowValues.length) {
                    self._addGroup(self.colGroupTree, colLabels, colValues);
                }

                var key = JSON.stringify([rowValues, colValues]);
                var originIndex = groupSubdivision.group.originIndex;

                if (!(key in self.measurements)) {
                    self.measurements[key] = self.data.origins.map(function () {
                        return self._getMeasurements({});
                    });
                }
                self.measurements[key][originIndex] = self._getMeasurements(subGroup);

                if (!(key in self.counts)) {
                    self.counts[key] = self.data.origins.map(function () {
                        return 0;
                    });
                }
                self.counts[key][originIndex] = subGroup.__count;

                if (!(key in self.groupDomains)) {
                    self.groupDomains[key] = self.data.origins.map(function () {
                        return Domain.FALSE_DOMAIN;
                    });
                }
                // if __domain is not defined this means that we are in the
                // case where
                // groupSubdivision.rowGroupBy = groupSubdivision.rowGroupBy = []
                if (subGroup.__domain) {
                    self.groupDomains[key][originIndex] = subGroup.__domain;
                }
            });
        });

        if (this.data.sortedColumn) {
            this.sortRows(this.data.sortedColumn, rowSubTree);
        }
    },
    /**
     * In the preview implementation of the pivot view (a.k.a. version 2),
     * the virtual field used to display the number of records was named
     * __count__, whereas __count is actually the one used in xml. So
     * basically, activating a filter specifying __count as measures crashed.
     * Unfortunately, as __count__ was used in the JS, all filters saved as
     * favorite at that time were saved with __count__, and not __count.
     * So in order the make them still work with the new implementation, we
     * handle both __count__ and __count.
     *
     * This function replaces in the given array of measures occurences of
     * '__count__' by '__count'.
     *
     * @private
     * @param {Array[string] || undefined} measures
     * @returns {Array[string] || undefined}
     */
    _processMeasures: function (measures) {
        if (measures) {
            return _.map(measures, function (measure) {
                return measure === '__count__' ? '__count' : measure;
            });
        }
    },
    /**
     * Determine this.data.domains and this.data.origins from
     * this.data.domain and this.data.timeRanges;
     *
     * @private
     */
    _computeDerivedParams: function () {
        const { range, rangeDescription, comparisonRange, comparisonRangeDescription } = this.data.timeRanges;
        if (range) {
            this.data.domains = [this.data.domain.concat(comparisonRange), this.data.domain.concat(range)];
            this.data.origins = [comparisonRangeDescription, rangeDescription];
        } else {
            this.data.domains = [this.data.domain];
            this.data.origins = [""];
        }
    },
    /**
     * Make any group in tree a leaf if it was a leaf in oldTree.
     *
     * @private
     * @param {Object} tree
     * @param {Object} oldTree
     */
    _pruneTree: function (tree, oldTree) {
        if (!oldTree.directSubTrees.size) {
            tree.directSubTrees.clear();
            delete tree.sortedKeys;
            return;
        }
        var self = this;
        [...tree.directSubTrees.keys()].forEach(function (subTreeKey) {
            var subTree = tree.directSubTrees.get(subTreeKey);
            if (!oldTree.directSubTrees.has(subTreeKey)) {
                subTree.directSubTrees.clear();
                delete subTreeKey.sortedKeys;
            } else {
                var oldSubTree = oldTree.directSubTrees.get(subTreeKey);
                self._pruneTree(subTree, oldSubTree);
            }
        });
    },
    /**
     * Toggle the active state for a given measure, then reload the data
     * if this turns out to be necessary.
     *
     * @param {string} fieldName
     * @returns {Promise}
     */
    _toggleMeasure: function (fieldName) {
        var index = this.data.measures.indexOf(fieldName);
        if (index !== -1) {
            this.data.measures.splice(index, 1);
            // in this case, we already have all data in memory, no need to
            // actually reload a lesser amount of information
            return Promise.resolve();
        } else {
            this.data.measures.push(fieldName);
        }
        return this._loadData();
    },
    /**
     * Extract from a groupBy value a label.
     *
     * @private
     * @param  {any} value
     * @param  {string} groupBy
     * @returns {string}
     */
    _sanitizeLabel: function (value, groupBy) {
        var fieldName = groupBy.split(':')[0];
        if (value === false) {
            return _t("Undefined");
        }
        if (value instanceof Array) {
            return this._getNumberedLabel(value, fieldName);
        }
        if (fieldName && this.fields[fieldName] && (this.fields[fieldName].type === 'selection')) {
            var selected = _.where(this.fields[fieldName].selection, { 0: value })[0];
            return selected ? selected[1] : value;
        }
        return value;
    },
    /**
     * Extract from a groupBy value the raw value of that groupBy (discarding
     * a label if any)
     *
     * @private
     * @param {any} value
     * @returns {any}
     */
    _sanitizeValue: function (value) {
        if (value instanceof Array) {
            return value[0];
        }
        return value;
    },
    /**
     * Get all partitions of a given group using the provided list of divisors
     * and enrich the objects of this.rowGroupTree, colGroupTree,
     * measurements, counts.
     *
     * @private
     * @param {Object} group
     * @param {Array[]} divisors
     * @returns
     */
    _subdivideGroup: function (group, divisors) {
        var self = this;

        var key = JSON.stringify([group.rowValues, group.colValues]);

        var proms = this.data.origins.reduce(
            function (acc, origin, originIndex) {
                // if no information on group content is available, we fetch data.
                // if group is known to be empty for the given origin,
                // we don't need to fetch data fot that origin.
                if (!self.counts[key] || self.counts[key][originIndex] > 0) {
                    var subGroup = {
                        rowValues: group.rowValues,
                        colValues: group.colValues,
                        originIndex: originIndex
                    };
                    divisors.forEach(function (divisor) {
                        acc.push(self._getGroupSubdivision(subGroup, divisor[0], divisor[1]));
                    });
                }
                return acc;
            },
            []
        );
        return this._loadDataDropPrevious.add(Promise.all(proms)).then(function (groupSubdivisions) {
            if (groupSubdivisions.length) {
                self._prepareData(group, groupSubdivisions);
            }
        });
    },
    /**
     * Sort recursively the subTrees of tree using sortFunction.
     * In the end each node of the tree has its direct children sorted
     * according to the criterion reprensented by sortFunction.
     *
     * @private
     * @param  {Function} sortFunction
     * @param  {Object} tree
     */
    _sortTree: function (sortFunction, tree) {
        var self = this;
        tree.sortedKeys = _.sortBy([...tree.directSubTrees.keys()], sortFunction(tree));
        [...tree.directSubTrees.values()].forEach(function (subTree) {
            self._sortTree(sortFunction, subTree);
        });
    },
});

__exports[Symbol.for("default")] = PivotModel;

return __exports;
});

odoo.define(`web.PivotModel`, async function(require) {
                        return require('@web/legacy/js/views/pivot/pivot_model')[Symbol.for("default")];
                        });
;

/**********************************************************************
*  Filepath: /web/static/src/legacy/js/views/pivot/pivot_renderer.js  *
*  Bundle: web.assets_backend_legacy_lazy                             *
*  Lines: 301                                                         *
**********************************************************************/
odoo.define('@web/legacy/js/views/pivot/pivot_renderer', async function (require) {
'use strict';
let __exports = {};
/** @odoo-module alias=web.PivotRenderer **/

    const { useEffect } = require("@web/core/utils/hooks");
    const OwlAbstractRenderer = require("@web/legacy/js/views/abstract_renderer_owl")[Symbol.for("default")];
    const field_utils = require('web.field_utils');
    const { DEFAULT_INTERVAL, INTERVAL_OPTIONS, getIntervalOptions } = require('web.searchUtils');

    const { Component, hooks } = owl;
    const { useExternalListener, useState } = hooks;

    class PivotCustomGroupByItem extends Component {
        constructor() {
            super(...arguments);
            this.canBeOpened = true;
            this.state = useState({ fieldName: this.props.fields[0].name });
        }

        //---------------------------------------------------------------------
        // Handlers
        //---------------------------------------------------------------------

        /**
         * @private
         */
        onApply() {
            const { fieldName } = this.state;
            const { type } = this.props.fields.find(f => f.name === fieldName);
            let interval = null;
            if (['date', 'datetime'].includes(type)) {
                interval = DEFAULT_INTERVAL;
            }
            this.trigger('groupby-menu-selection', { fieldName, interval, custom: true });
            this.state.open = false;
        }
    }

    PivotCustomGroupByItem.template = "web.CustomGroupByItem";
    PivotCustomGroupByItem.props = { fields: Array };

    const PivotGroupByMenu = __exports.PivotGroupByMenu = class PivotGroupByMenu extends Component {

        constructor() {
            super(...arguments);
            this.intervalOptions = INTERVAL_OPTIONS;
            this.openedSubMenus = {};
        }

        //---------------------------------------------------------------------
        // Getters
        //---------------------------------------------------------------------

        /**
         * @override
         */
        get items() {
            let items = this.props.fields;
            if (this.props.hasSearchArchGroupBys) {
                items = this.props.searchModel.get('filters', f => f.type === 'groupBy');
                let groupNumber = 1 + Math.max(...items.map(g => g.groupNumber), 0);
                for (const [_, customGroupBy] of this.props.customGroupBys) {
                    customGroupBy.groupNumber = groupNumber++;
                    items.push(customGroupBy);
                }
            }
            return items.map((item) => ({
                ...item,
                id: item.id || item.name,
                fieldName: item.fieldName || item.name,
                description: item.description || item.string,
                isActive: false,
                options:
                    item.options || ["date", "datetime"].includes(item.type)
                        ? getIntervalOptions()
                        : undefined,
            }));
        }

        //---------------------------------------------------------------------
        // Handlers
        //---------------------------------------------------------------------

        /**
         * @param {string} fieldName
         * @param {string|null} interval
        */
        _onClickMenuGroupBy(fieldName, interval) {
            this.trigger('groupby-menu-selection', { fieldName, interval });
        }

        _toggleMenu(id) {
            this.openedSubMenus[id] = !this.openedSubMenus[id];
            this.render();
        }
    }

    PivotGroupByMenu.template = "web.legacy.PivotGroupByMenu";
    PivotGroupByMenu.components = { PivotCustomGroupByItem };
    PivotGroupByMenu.props = {
        customGroupBys: Map,
        fields: Object,
        hasSearchArchGroupBys: Boolean,
        searchModel: true,
    };

    /**
     * Here is a basic example of the structure of the Pivot Table:
     *
     * ┌─────────────────────────┬─────────────────────────────────────────────┬─────────────────┐
     * │                         │ - web.PivotHeader                           │                 │
     * │                         ├──────────────────────┬──────────────────────┤                 │
     * │                         │ + web.PivotHeader    │ + web.PivotHeader    │                 │
     * ├─────────────────────────┼──────────────────────┼──────────────────────┼─────────────────┤
     * │                         │ web.PivotMeasure     │ web.PivotMeasure     │                 │
     * ├─────────────────────────┼──────────────────────┼──────────────────────┼─────────────────┤
     * │ ─ web.PivotHeader       │                      │                      │                 │
     * ├─────────────────────────┼──────────────────────┼──────────────────────┼─────────────────┤
     * │    + web.PivotHeader    │                      │                      │                 │
     * ├─────────────────────────┼──────────────────────┼──────────────────────┼─────────────────┤
     * │    + web.PivotHeader    │                      │                      │                 │
     * └─────────────────────────┴──────────────────────┴──────────────────────┴─────────────────┘
     *
     */

    class PivotRenderer extends OwlAbstractRenderer {
        /**
         * @override
         * @param {boolean} props.disableLinking Disallow opening records by clicking on a cell
         * @param {Object} props.widgets Widgets defined in the arch
         */
        constructor() {
            super(...arguments);
            this.sampleDataTargets = ['table'];
            this.state = useState({
                activeNodeHeader: {
                    groupId: false,
                    isXAxis: false,
                    click: false
                },
            });

            const searchArchGroupBys = this.props.searchModel.get(
                'filters',
                f => f.type === 'groupBy' && !f.custom
            );
            // searchArchGroupBys is not an array when the control panel model
            // extension is not installed (e.g. in an embedded pivot view)
            this.hasSearchArchGroupBys = Boolean(searchArchGroupBys && searchArchGroupBys.length);
            this.customGroupBys = new Map();

            useEffect(() => this._updateTooltip());
            useExternalListener(window, 'click', this._resetState);
        }

        //----------------------------------------------------------------------
        // Private
        //----------------------------------------------------------------------

        /**
         * Get the formatted value of the cell
         *
         * @private
         * @param {Object} cell
         * @returns {string} Formatted value
         */
        _getFormattedValue(cell) {
            const type = this.props.widgets[cell.measure] ||
                (this.props.fields[cell.measure].type === 'many2one' ? 'integer' : this.props.fields[cell.measure].type);
            const formatter = field_utils.format[type];
            return formatter(cell.value, this.props.fields[cell.measure]);
        }

        /**
         * Get the formatted variation of a cell
         *
         * @private
         * @param {Object} cell
         * @returns {string} Formatted variation
         */
        _getFormattedVariation(cell) {
            const value = cell.value;
            return isNaN(value) ? '-' : field_utils.format.percentage(value, this.props.fields[cell.measure]);
        }

        /**
         * Retrieves the padding of a left header
         *
         * @private
         * @param {Object} cell
         * @returns {Number} Padding
         */
        _getPadding(cell) {
            return 5 + cell.indent * 30;
        }

        /**
         * Reset the state of the node.
         *
         * @private
         */
        _resetState() {
            // This check is used to avoid the destruction of the dropdown.
            // The click on the header bubbles to window in order to hide
            // all the other dropdowns (in this component or other components).
            // So we need isHeaderClicked to cancel this behaviour.
            if (this.isHeaderClicked) {
                this.isHeaderClicked = false;
                return;
            }
            this.state.activeNodeHeader = {
                groupId: false,
                isXAxis: false,
                click: false
            };
        }

        /**
         * Configure the tooltips on the headers.
         *
         * @private
         */
        _updateTooltip() {
            $(this.el).find('.o_pivot_header_cell_opened, .o_pivot_header_cell_closed').tooltip();
        }

        //----------------------------------------------------------------------
        // Handlers
        //----------------------------------------------------------------------

        /**
         * @private
         * @param {OwlEvent} ev
         */
        _onGroupByMenuSelection(ev) {
            if (this.hasSearchArchGroupBys) {
                const { custom, fieldName } = ev.detail;
                if (custom && !this.customGroupBys.has(fieldName)) {
                    const field = this.props.groupableFields.find(g => g.fieldName === fieldName)
                    this.customGroupBys.set(fieldName, field);
                }
            }
        }

        /**
         * Handles a click on a header node
         *
         * @private
         * @param {Object} cell
         * @param {string} type col or row
         */
        _onHeaderClick(cell, type) {
            const groupValues = cell.groupId[type === 'col' ? 1 : 0];
            const groupByLength = type === 'col' ? this.props.colGroupBys.length : this.props.rowGroupBys.length;
            if (cell.isLeaf && groupValues.length >= groupByLength) {
                this.isHeaderClicked = true;
                this.state.activeNodeHeader = {
                    groupId: cell.groupId,
                    isXAxis: type === 'col',
                    click: 'leftClick'
                };
            }
            this.trigger(cell.isLeaf ? 'closed_header_click' : 'opened_header_click', { cell, type });
        }

        /**
         * Hover the column in which the mouse is.
         *
         * @private
         * @param {MouseEvent} ev
         */
        _onMouseEnter(ev) {
            var index = [...ev.currentTarget.parentNode.children].indexOf(ev.currentTarget);
            if (ev.currentTarget.tagName === 'TH') {
                index += 1;
            }
            this.el.querySelectorAll('td:nth-child(' + (index + 1) + ')').forEach(elt => elt.classList.add('o_cell_hover'));
        }

        /**
         * Remove the hover on the columns.
         *
         * @private
         */
        _onMouseLeave() {
            this.el.querySelectorAll('.o_cell_hover').forEach(elt => elt.classList.remove('o_cell_hover'));
        }
    }

    PivotRenderer.template = 'web.legacy.PivotRenderer';
    PivotRenderer.components = { PivotGroupByMenu };

    __exports[Symbol.for("default")] = PivotRenderer;

return __exports;
});

odoo.define(`web.PivotRenderer`, async function(require) {
                        return require('@web/legacy/js/views/pivot/pivot_renderer')[Symbol.for("default")];
                        });
;

/******************************************************************
*  Filepath: /web/static/src/legacy/js/views/pivot/pivot_view.js  *
*  Bundle: web.assets_backend_legacy_lazy                         *
*  Lines: 175                                                     *
******************************************************************/
odoo.define('@web/legacy/js/views/pivot/pivot_view', async function (require) {
'use strict';
let __exports = {};
/** @odoo-module alias=web.PivotView **/

    /**
     * The Pivot View is a view that represents data in a 'pivot grid' form. It
     * aggregates data on 2 dimensions and displays the result, allows the user to
     * 'zoom in' data.
     */

    const AbstractView = require("@web/legacy/js/views/abstract_view")[Symbol.for("default")];
    const config = require('web.config');
    const core = require('web.core');
    const PivotModel = require('web.PivotModel');
    const PivotController = require('web.PivotController');
    const PivotRenderer = require("@web/legacy/js/views/pivot/pivot_renderer")[Symbol.for("default")];
    const RendererWrapper = require('web.RendererWrapper');
    const { sortBy } = require('web.utils');
    const viewRegistry = require("web.view_registry");

    const _t = core._t;
    const _lt = core._lt;

    const searchUtils = require('web.searchUtils');
    const GROUPABLE_TYPES = searchUtils.GROUPABLE_TYPES;

    const PivotView = AbstractView.extend({
        display_name: _lt('Pivot'),
        icon: 'fa-table',
        config: Object.assign({}, AbstractView.prototype.config, {
            Model: PivotModel,
            Controller: PivotController,
            Renderer: PivotRenderer,
        }),
        viewType: 'pivot',
        searchMenuTypes: ['filter', 'groupBy', 'comparison', 'favorite'],

        /**
         * @override
         * @param {Object} params
         * @param {Array} params.additionalMeasures
         */
        init: function (viewInfo, params) {
            this._super.apply(this, arguments);

            const activeMeasures = []; // Store the defined active measures
            const colGroupBys = []; // Store the defined group_by used on cols
            const rowGroupBys = []; // Store the defined group_by used on rows
            const measures = {}; // All the available measures
            const groupableFields = {}; // The fields which can be used to group data
            const widgets = {}; // Wigdets defined in the arch
            const additionalMeasures = params.additionalMeasures || [];

            this.fields.__count = { string: _t("Count"), type: "integer" };

            //Compute the measures and the groupableFields
            Object.keys(this.fields).forEach(name => {
                const field = this.fields[name];
                if (name !== 'id' && field.store === true) {
                    if (['integer', 'float', 'monetary'].includes(field.type) || additionalMeasures.includes(name)) {
                        measures[name] = field;
                    }
                    if (GROUPABLE_TYPES.includes(field.type)) {
                        groupableFields[name] = Object.assign({
                            description: field.string,
                            fieldName: name,
                            fieldType: field.type,
                            name,
                        }, field);
                    }
                }
            });
            measures.__count = { string: _t("Count"), type: "integer" };


            this.arch.children.forEach(field => {
                let name = field.attrs.name;
                // Remove invisible fields from the measures if not in additionalMeasures
                if (field.attrs.invisible && py.eval(field.attrs.invisible)) {
                    if (name in groupableFields) {
                        delete groupableFields[name];
                    }
                    if (!additionalMeasures.includes(name)) {
                        delete measures[name];
                        return;
                    }
                }
                if (field.attrs.interval) {
                    name += ':' + field.attrs.interval;
                }
                if (field.attrs.widget) {
                    widgets[name] = field.attrs.widget;
                }
                // add active measures to the measure list.  This is very rarely
                // necessary, but it can be useful if one is working with a
                // functional field non stored, but in a model with an overrided
                // read_group method.  In this case, the pivot view could work, and
                // the measure should be allowed.  However, be careful if you define
                // a measure in your pivot view: non stored functional fields will
                // probably not work (their aggregate will always be 0).
                if (field.attrs.type === 'measure' && !(name in measures)) {
                    measures[name] = this.fields[name];
                }
                if (field.attrs.string && name in measures) {
                    measures[name].string = field.attrs.string;
                }
                if (field.attrs.type === 'measure' || 'operator' in field.attrs) {
                    activeMeasures.push(name);
                    measures[name] = this.fields[name];
                }
                if (field.attrs.type === 'col') {
                    colGroupBys.push(name);
                }
                if (field.attrs.type === 'row') {
                    rowGroupBys.push(name);
                }
            });
            if ((!activeMeasures.length) || this.arch.attrs.display_quantity) {
                activeMeasures.splice(0, 0, '__count');
            }

            this.loadParams.measures = activeMeasures;
            this.loadParams.colGroupBys = config.device.isMobile ? [] : colGroupBys;
            this.loadParams.rowGroupBys = rowGroupBys;
            this.loadParams.fields = this.fields;
            this.loadParams.default_order = params.default_order || this.arch.attrs.default_order;

            const disableLinking = !!(this.arch.attrs.disable_linking &&
                                        JSON.stringify(this.arch.attrs.disable_linking));

            this.rendererParams.widgets = widgets;
            this.rendererParams.disableLinking = disableLinking;
            const { searchModel } = this.controllerParams;
            this.rendererParams.searchModel = searchModel;
            this.rendererParams.groupableFields = sortBy(Object.values(groupableFields), (f) => f.description);

            this.controllerParams.disableLinking = disableLinking;
            this.controllerParams.title = params.title || this.arch.attrs.string || _t("Untitled");
            this.controllerParams.measures = measures;

            // retrieve form and list view ids from the action to open those views
            // when a data cell of the pivot view is clicked
            this.controllerParams.views = [
                _findView(params.actionViews, 'list'),
                _findView(params.actionViews, 'form'),
            ];

            function _findView(views, viewType) {
                const view = views.find(view => {
                    return view.type === viewType;
                });
                return [view ? view.viewID : false, viewType];
            }
        },

        /**
         *
         * @override
         */
        getRenderer(parent, state) {
            state = Object.assign(state || {}, this.rendererParams);
            return new RendererWrapper(parent, this.config.Renderer, state);
        },
    });
    viewRegistry.add("pivot", PivotView);

    __exports[Symbol.for("default")] = PivotView;

return __exports;
});

odoo.define(`web.PivotView`, async function(require) {
                        return require('@web/legacy/js/views/pivot/pivot_view')[Symbol.for("default")];
                        });
;

/***************************************************************************
*  Filepath: /web_enterprise/static/src/legacy/js/views/pivot_renderer.js  *
*  Bundle: web.assets_backend_legacy_lazy                                  *
*  Lines: 42                                                               *
***************************************************************************/
odoo.define('@web_enterprise/legacy/js/views/pivot_renderer', async function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const config = require("web.config");
const PivotRenderer = require("@web/legacy/js/views/pivot/pivot_renderer")[Symbol.for("default")];
const { PivotGroupByMenu } = require("@web/legacy/js/views/pivot/pivot_renderer");
const { patch } = require("web.utils");

if (config.device.isMobile) {
    patch(PivotRenderer.prototype, "pivot_mobile", {
        /**
         * Do not compute the tooltip on mobile
         * @override
         */
        _updateTooltip() {},

        /**
         * @override
         */
        _getPadding(cell) {
            return 5 + cell.indent * 5;
        },
    });

    patch(PivotGroupByMenu.prototype, "pivot_mobile", {
        /**
         * @override
         */
        _onClickMenuGroupBy(fieldName, interval, ev) {
            if (!ev.currentTarget.classList.contains("o_pivot_field_selection")) {
                this._super(...arguments);
            } else {
                ev.stopPropagation();
            }
        },
    });
}

return __exports;
});
;

/**************************************************************
*  Filepath: /web_map/static/src/legacy/js/map_controller.js  *
*  Bundle: web.assets_backend_legacy_lazy                     *
*  Lines: 143                                                 *
**************************************************************/
odoo.define('web_map.MapController', function (require) {
"use strict";

const AbstractController = require('web.AbstractController');
const core = require('web.core');
const qweb = core.qweb;

const MapController = AbstractController.extend({
    custom_events: _.extend({}, AbstractController.prototype.custom_events, {
        'pin_clicked': '_onPinClick',
        'get_itinerary_clicked': '_onGetItineraryClicked',
        'open_clicked': '_onOpenClicked',
        'pager_changed': '_onPagerChanged',
        'coordinate_fetched': '_onCoordinateFetched',
    }),

    /**
     * @constructor
     */
    init: function (parent, model, renderer, params) {
        this._super.apply(this, arguments);
        this.actionName = params.actionName;
    },

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    /**
     * @override
     * @param {jQuery} [$node]
     */
    renderButtons: function ($node) {
        this.$buttons = $(qweb.render("web_map.legacy.buttons"), { widget: this });
        this._updateGoogleMapUrl();
        this.$buttons.appendTo($node);
    },
    /**
     * @override
     */
    update: async function () {
        await this._super(...arguments);
        this._updatePaging();
        this._updateGoogleMapUrl();
    },
    /**
     * When the records dataset is updated, the URL to Google Maps need to be updated as well
     * to reflect the new recordset.
     * This will redirect the user to the displayed records even if he filters them using the search bar.
     *
     * @private
     */
    _updateGoogleMapUrl: function () {
        var url = 'https://www.google.com/maps/dir/?api=1';
        if (this.model.data.records.length) {
            url += '&waypoints=';
            var all_coord = this.model.data.records.filter((record) => record.partner && record.partner.partner_latitude && record.partner.partner_longitude);
            _.uniq(all_coord, function (record) { return record.partner.partner_latitude + '_' + record.partner.partner_longitude; })
                .forEach((record) => {
                    url += record.partner.partner_latitude + ',' + record.partner.partner_longitude + '|';
                });
            url = url.slice(0, -1);
        }
        this.$buttons.find('a.btn.btn-primary').attr('href', url);
    },

    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------

    /**
     * Return the params (currentMinimum, limit and size) to pass to the pager,
     * according to the current state.
     *
     * @private
     * @returns {Object}
     */
    _getPagingInfo: function () {
        const state = this.model.get();
        return {
            currentMinimum: state.offset + 1,
            limit: state.limit,
            size: state.count,
        };
    },

    //--------------------------------------------------------------------------
    // Handlers
    //--------------------------------------------------------------------------

    /**
     * @private
     * @param {OdooEvent} ev
     */
    _onCoordinateFetched: function (ev) {
        ev.stopPropagation();
        this.update({}, { reload: false });
    },
    /**
     * Redirects to google maps with all the records' coordinates.
     *
     * @private
     * @param {MouseEvent} ev
     */
    _onGetItineraryClicked: function (ev) {
        window.open(`https://www.google.com/maps/dir/?api=1&destination=${ev.data.lat},${ev.data.lon}`);
    },
    /**
     * Redirects to views when clicked on open button in marker popup.
     *
     * @private
     * @param {MouseEvent} ev
     */
    _onOpenClicked: function (ev) {
        if (ev.data.ids.length > 1) {
            this.do_action({
                type: 'ir.actions.act_window',
                name: this.actionName,
                views: [[false, 'list'], [false, 'form']],
                res_model: this.modelName,
                domain: [['id', 'in', ev.data.ids]],
            });
        } else {
            this.trigger_up('switch_view', {
                view_type: 'form',
                res_id: ev.data.ids[0],
                mode: 'readonly',
                model: this.modelName
            });
        }
    },
    /**
     * @private
     * @param {OdooEvent} ev
     */
    async _onPagerChanged(ev) {
        const { currentMinimum, limit } = ev.data;
        await this.reload({ limit, offset: currentMinimum - 1 });
    },
});

return MapController;
});
;

/*********************************************************
*  Filepath: /web_map/static/src/legacy/js/map_model.js  *
*  Bundle: web.assets_backend_legacy_lazy                *
*  Lines: 532                                            *
*********************************************************/
odoo.define('web_map.MapModel', function (require) {
"use strict";

const AbstractModel = require('web.AbstractModel');
const session = require('web.session');
const core = require('web.core');
const _t = core._t;

const MapModel = AbstractModel.extend({
    // Used in _openStreetMapAPIAsync to add delay between coordinates fetches
    // We need this delay to not get banned from OSM.
    COORDINATE_FETCH_DELAY: 1000,

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    /**
     * @constructor
     */
    init: function () {
        this._super.apply(this, arguments);
        this.data = {};
        this.data.mapBoxToken = session.map_box_token;
    },
    __get: function () {
        return this.data;
    },
    __load: function (params) {
        this.data.count = 0;
        this.data.offset = 0;
        this.data.limit = params.limit;
        this.partnerToCache = [];
        this.partnerIds = [];
        this.resPartnerField = params.resPartnerField;
        this.model = params.modelName;
        this.context = params.context;
        this.fields = params.fieldNames;
        this.fieldsInfo = params.fieldsInfo;
        this.domain = params.domain;
        this.params = params;
        this.orderBy = params.orderBy;
        this.routing = params.routing;
        this.numberOfLocatedRecords = 0;
        this.coordinateFetchingTimeoutHandle = undefined;
        this.data.shouldUpdatePosition = true;
        this.data.fetchingCoordinates = false;
        this.data.groupBy = params.groupedBy.length ? params.groupedBy[0] : false;
        return this._fetchData();
    },
    __reload: function (handle, params) {
        const options = params || {};
        this.partnerToCache = [];
        this.partnerIds = [];
        this.numberOfLocatedRecords = 0;
        this.data.shouldUpdatePosition = true;
        this.data.fetchingCoordinates = false;
        if (this.coordinateFetchingTimeoutHandle !== undefined) {
            clearInterval(this.coordinateFetchingTimeoutHandle);
            this.coordinateFetchingTimeoutHandle = undefined;
        }
        if (options.domain !== undefined) {
            this.domain = options.domain;
        }
        if (options.limit !== undefined) {
            this.data.limit = options.limit;
        }
        if (options.offset !== undefined) {
            this.data.offset = options.offset;
        }
        if (options.groupBy !== undefined && options.groupBy[0] !== this.data.groupBy) {
            this.data.groupBy = options.groupBy.length ? options.groupBy[0] : false;
        }
        return this._fetchData();
    },

    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------

    /**
     * Adds the corresponding partner to a record.
     *
     * @private
     */
    _addPartnerToRecord: function () {
        this.data.records.forEach((record) => {
            this.data.partners.forEach((partner) => {
                let recordPartnerId;
                if (this.model === "res.partner" && this.resPartnerField === "id") {
                    recordPartnerId = record.id;
                } else {
                    recordPartnerId = record[this.resPartnerField][0];
                }

                if (recordPartnerId == partner.id) {
                    record.partner = partner;
                    this.numberOfLocatedRecords++;
                }
            });
        });
    },
    /**
     * The partner's coordinates should be between -90 <= latitude <= 90 and -180 <= longitude <= 180.
     *
     * @private
     * @param {Object} partner
     * @param {float} partner.partner_latitude latitude of the partner
     * @param {float} partner.partner_longitude longitude of the partner
     * @returns {boolean}
     */
    _checkCoordinatesValidity: function (partner) {
        if (partner.partner_latitude && partner.partner_longitude &&
            partner.partner_latitude >= -90 && partner.partner_latitude <= 90 &&
            partner.partner_longitude >= -180 && partner.partner_longitude <= 180) {
            return true;
        }
        return false;
    },
    /**
     * This function convert the addresses to coordinates using the mapbox API.
     *
     * @private
     * @param {Object} record this object contains the record fetched from the database.
     * @returns {Promise<result>} result.query contains the query the the api received
     *      result.features contains results in descendant order of relevance
     */
    _fetchCoordinatesFromAddressMB: function (record) {
        const address = encodeURIComponent(record.contact_address_complete);
        const token = this.data.mapBoxToken;
        const encodedUrl = `https://api.mapbox.com/geocoding/v5/mapbox.places/${address}.json?access_token=${token}&cachebuster=1552314159970&autocomplete=true`;
        return new Promise((resolve, reject) => {
            $.get(encodedUrl).then(resolve).catch(reject);
        });
    },
    /**
     * This function convert the addresses to coordinates using the openStreetMap api.
     *
     * @private
     * @param {Object} record this object contains the record fetched from the database.
     * @returns {Promise<result>} result is an array that contains the result in descendant order of relevance
     *      result[i].lat is the latitude of the converted address
     *      result[i].lon is the longitude of the converted address
     *      result[i].importance is a float that the relevance of the result the closer the float is to one the best it is.
     */
    _fetchCoordinatesFromAddressOSM: function (record) {
        const address = encodeURIComponent(record.contact_address_complete.replace('/', ' '));
        const encodedUrl = `https://nominatim.openstreetmap.org/search/${address}?format=jsonv2`;
        return new Promise(function (resolve, reject) {
            $.get(encodedUrl).then(resolve).catch(reject);
        });
    },
    /**
     * Handles the case of an empty map.
     * Handles the case where the model is res_partner.
     * Fetches the records according to the model given in the arch.
     * If the records has no partner_id field it is sliced from the array.
     *
     * @private
     * @return {Promise}
     */
    _fetchData: async function () {
        //case of empty map
        if (!this.resPartnerField) {
            this.data.recordGroups = [];
            this.data.records = [];
            this.data.routeInfo = { routes: [] };
            return;
        }
        const results = await this._fetchRecordData();
        this.data.records = results.records;
        this.data.count = results.length;
        if (this.data.groupBy) {
            this.data.recordGroups = this._getRecordGroups();
        } else {
            this.data.recordGroups = {};
        }

        this.partnerIds = [];
        if (this.model === "res.partner" && this.resPartnerField === "id") {
            this.data.records.forEach((record) => {
                this.partnerIds.push(record.id);
                record.partner_id = [record.id];
            });
        } else {
            this._fillPartnerIds(this.data.records);
        }

        this.partnerIds = _.uniq(this.partnerIds);
        return this._partnerFetching(this.partnerIds);
    },
    /**
     * Fetch the records for a given model.
     *
     * @private
     * @returns {Promise<results>}
     */
    async _fetchRecordData() {
        const groupBy = this.data.groupBy ? this.data.groupBy.split(':')[0] : false;
        const results = await this._rpc({
            route: '/web/dataset/search_read',
            model: this.model,
            context: this.context,
            fields: groupBy ?
                this.fields.concat(groupBy) :
                this.fields,
            domain: this.domain,
            orderBy: this.orderBy,
            limit: this.data.limit,
            offset: this.data.offset
        })
        if (results && groupBy && ["one2many", "many2many"].includes(this.fieldsInfo[groupBy].type)) {
            const ids = new Set(results.records.flatMap((record) => record[groupBy]));
            const groupbyRecords = await this._rpc({
                method: 'name_get',
                model: this.fieldsInfo[groupBy].relation,
                context: this.context,
                args: [[...ids]],
            })
            const labelPerRecordId = Object.fromEntries(groupbyRecords);
            for (const record of results.records) {
                record[groupBy] = record[groupBy].map(
                    val =>
                        val && val in labelPerRecordId
                            ? [val, labelPerRecordId[val]]
                            : false
                );
            }
        }
        return results;
    },
    /**
     * @private
     * @returns {Object} the fetched records grouped by the groupBy field.
     */
    _getRecordGroups: function () {
        const [fieldName, subGroup] = this.data.groupBy.split(':');
        const dateGroupFormats = {
            year: 'YYYY',
            quarter: '[Q]Q YYYY',
            month: 'MMMM YYYY',
            week: '[W]WW YYYY',
            day: 'DD MMM YYYY',
        };
        const groups = {};
        for (const record of this.data.records) {
            const vals = ["one2many", "many2many"].includes(this.fieldsInfo[fieldName].type)
                ? record[fieldName] : [record[fieldName]];

            for(const val of vals){
                let id, name;
                if (['date', 'datetime'].includes(this.fieldsInfo[fieldName].type)) {
                    const date = moment(val);
                    id = name = date.format(dateGroupFormats[subGroup]);
                } else {
                    id = Array.isArray(val) ? val[0] : val;
                    name = Array.isArray(val) ? val[1] : val;
                }
                if (!groups[id]) {
                    groups[id] = {
                        name,
                        records: [],
                    };
                }
                groups[id].records.push(record);
            }
        }
        return groups;
    },
    /**
     * @private
     * @param {Number[]} ids contains the ids from the partners
     * @returns {Promise}
     */
    _fetchRecordsPartner: function (ids) {
        return this._rpc({
            model: 'res.partner',
            method: 'search_read',
            fields: ['contact_address_complete', 'partner_latitude', 'partner_longitude'],
            domain: [['contact_address_complete', '!=', 'False'], ['id', 'in', ids]],
        });
    },
    /**
     * Fetch the route from the mapbox api.
     *
     * @private
     * @returns {Promise<results>}
     *      results.geometry.legs[i] contains one leg (i.e: the trip between two markers).
     *      results.geometry.legs[i].steps contains the sets of coordinates to follow to reach a point from an other.
     *      results.geometry.legs[i].distance: the distance in meters to reach the destination
     *      results.geometry.legs[i].duration the duration of the leg
     *      results.geometry.coordinates contains the sets of coordinates to go from the first to the last marker without the notion of waypoint
     */
    _fetchRoute: function () {
        const coordinatesParam = this.data.records
            .filter(record => record.partner.partner_latitude && record.partner.partner_longitude)
            .map(record => record.partner.partner_longitude + ',' + record.partner.partner_latitude);
        const address = encodeURIComponent(coordinatesParam.join(';'));
        const token = this.data.mapBoxToken;
        const encodedUrl = `https://api.mapbox.com/directions/v5/mapbox/driving/${address}?access_token=${token}&steps=true&geometries=geojson`;
        return new Promise(function (resolve, reject) {
            $.get(encodedUrl).then(resolve).catch(reject);
        });
    },
    /**
     * @private
     * @param {Object[]} records the records that are going to be filtered
     * @returns {Object[]} Array of records that contains a partner_id
     */
    _fillPartnerIds: function (records) {
        return records.forEach(record => {
            if (record[this.resPartnerField]) {
                this.partnerIds.push(record[this.resPartnerField][0]);
            }
        });
    },
    /**
     * Converts a MapBox error message into a custom translatable one.
     *
     * @private
     * @param {string} message
     */
    _getErrorMessage: function (message) {
        const ERROR_MESSAGES = {
            'Too many coordinates; maximum number of coordinates is 25': _t("Too many routing points (maximum 25)"),
            'Route exceeds maximum distance limitation': _t("Some routing points are too far apart"),
            'Too Many Requests': _t("Too many requests, try again in a few minutes"),
        };
        return ERROR_MESSAGES[message];
    },
    /**
     * Handles the case where the selected api is MapBox.
     * Iterates on all the partners and fetches their coordinates when they're not set.
     *
     * @private
     * @return {Promise<routeResult> | Promise<>} if there's more than 2 located records and the routing option is activated it returns a promise that fetches the route
     *      resultResult is an object that contains the computed route
     *      or if either of these conditions are not respected it returns an empty promise
     */
    _maxBoxAPI: function () {
        const promises = [];
        this.data.partners.forEach(partner => {
            if (partner.contact_address_complete && (!partner.partner_latitude || !partner.partner_longitude)) {
                promises.push(this._fetchCoordinatesFromAddressMB(partner).then(coordinates => {
                    if (coordinates.features.length) {
                        partner.partner_longitude = coordinates.features[0].geometry.coordinates[0];
                        partner.partner_latitude = coordinates.features[0].geometry.coordinates[1];
                        this.partnerToCache.push(partner);
                    }
                }));
            } else if (!this._checkCoordinatesValidity(partner)) {
                partner.partner_latitude = undefined;
                partner.partner_longitude = undefined;
            }
        });
        return Promise.all(promises).then(() => {
            this.data.routeInfo = { routes: [] };
            if (this.numberOfLocatedRecords > 1 && this.routing && !this.data.groupBy) {
                return this._fetchRoute().then(routeResult => {
                    if (routeResult.routes) {
                        this.data.routeInfo = routeResult;
                    } else {
                        this.data.routingError = this._getErrorMessage(routeResult.message);
                    }
                });
            } else {
                return Promise.resolve();
            }
        });
    },
    /**
     * Handles the displaying of error message according to the error.
     *
     * @private
     * @param {Object} err contains the error returned by the requests
     * @param {Number} err.status contains the status_code of the failed http request
     */
    _mapBoxErrorHandling: function (err) {
        switch (err.status) {
            case 401:
                this.displayNotification({
                    title: _t('Token invalid'),
                    message: _t('The view has switched to another provider but functionalities will be limited'),
                    type: 'danger',
                });
                break;
            case 403:
                this.displayNotification({
                    title: _t('Unauthorized connection'),
                    message: _t('The view has switched to another provider but functionalities will be limited'),
                    type: 'danger',
                });
                break;
            case 422:   // Max. addresses reached
            case 429:   // Max. requests reached
                this.data.routingError = this._getErrorMessage(err.responseJSON.message);
                break;
            case 500:
                this.displayNotification({
                    title: _t('MapBox servers unreachable'),
                    message: _t('The view has switched to another provider but functionalities will be limited'),
                    type: 'danger',
                });
        }
    },
    /**
     * Notifies the fetched coordinates to server and controller.
     *
     * @private
     */
    _notifyFetchedCoordinate: function () {
        this._writeCoordinatesUsers();
        this.data.shouldUpdatePosition = false;
        this.trigger_up('coordinate_fetched');
    },
    /**
     * Calls (without awaiting) _openStreetMapAPIAsync with a delay of 1000ms
     * to not get banned from openstreetmap's server.
     *
     * Tests should patch this function to wait for coords to be fetched.
     *
     * @see _openStreetMapAPIAsync
     * @private
     * @return {Promise}
     */
    _openStreetMapAPI: function () {
        this._openStreetMapAPIAsync();
        return Promise.resolve();
    },
    /**
     * Handles the case where the selected api is open street map.
     * Iterates on all the partners and fetches their coordinates when they're not set.
     *
     * @private
     * @returns {Promise}
     */
    _openStreetMapAPIAsync: function () {
        // Group partners by address to reduce address list
        const addressPartnerMap = new Map();
        for (const partner of this.data.partners) {
            if (partner.contact_address_complete && (!partner.partner_latitude || !partner.partner_longitude)) {
                if (!addressPartnerMap.has(partner.contact_address_complete)) {
                    addressPartnerMap.set(partner.contact_address_complete, []);
                }
                addressPartnerMap.get(partner.contact_address_complete).push(partner);
                partner.fetchingCoordinate = true;
            } else if (!this._checkCoordinatesValidity(partner)) {
                partner.partner_latitude = undefined;
                partner.partner_longitude = undefined;
            }
        }

        // `fetchingCoordinates` is used to display the "fetching banner"
        // We need to check if there are coordinates to fetch before reload the
        // view to prevent flickering
        this.data.fetchingCoordinates = addressPartnerMap.size > 0;
        const fetch = async () => {
            const partnersList = Array.from(addressPartnerMap.values());
            for (let i = 0; i < partnersList.length; i++) {
                const partners = partnersList[i];
                try {
                    const coordinates = await this._fetchCoordinatesFromAddressOSM(partners[0]);
                    if (coordinates.length) {
                        for (const partner of partners) {
                            partner.partner_longitude = coordinates[0].lon;
                            partner.partner_latitude = coordinates[0].lat;
                            this.partnerToCache.push(partner);
                        }
                    }
                } finally {
                    for (const partner of partners) {
                        partner.fetchingCoordinate = false;
                    }
                    this.data.fetchingCoordinates = (i < partnersList.length - 1);
                    this._notifyFetchedCoordinate();
                    await new Promise((resolve) => {
                        this.coordinateFetchingTimeoutHandle =
                            setTimeout(resolve, this.COORDINATE_FETCH_DELAY);
                    });
                }
            }
        }
        return fetch();
    },
    /**
     * Fetches the partner which ids are contained in the the array partnerids
     * if the token is set it uses the mapBoxApi to fetch address and route
     * if not is uses the openstreetmap api to fetch the address.
     *
     * @private
     * @param {number[]} partnerIds this array contains the ids from the partner that are linked to records
     * @returns {Promise}
     */
    _partnerFetching: async function (partnerIds) {
        this.data.partners = partnerIds.length ? await this._fetchRecordsPartner(partnerIds) : [];
        this._addPartnerToRecord();
        if (this.data.mapBoxToken) {
            return this._maxBoxAPI()
                .then(() => {
                    this._writeCoordinatesUsers();
                }).catch((err) => {
                    this._mapBoxErrorHandling(err);
                    this.data.mapBoxToken = '';
                    return this._openStreetMapAPI();
                });
        } else {
            return this._openStreetMapAPI().then(() => {
                this._writeCoordinatesUsers();
            });
        }
    },
    /**
     * Writes partner_longitude and partner_latitude of the res.partner model.
     *
     * @private
     * @return {Promise}
     */
    _writeCoordinatesUsers: function () {
        if (this.partnerToCache.length) {
            this._rpc({
                model: 'res.partner',
                method: 'update_latitude_longitude',
                context: this.context,
                args: [this.partnerToCache]
            });
            this.partnerToCache = [];
        }
    },
});

return MapModel;
});
;

/************************************************************
*  Filepath: /web_map/static/src/legacy/js/map_renderer.js  *
*  Bundle: web.assets_backend_legacy_lazy                   *
*  Lines: 474                                               *
************************************************************/
/* global L */
// L is the object of leaflet
odoo.define('web_map.MapRenderer', function (require) {
    "use strict";

    const AbstractRendererOwl = require('web.AbstractRendererOwl');
    const { format } = require("web.field_utils");

    const { useRef, useState } = owl.hooks;

    const apiTilesRouteWithToken =
        'https://api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}?access_token={accessToken}';
    const apiTilesRouteWithoutToken = 'https://a.tile.openstreetmap.org/{z}/{x}/{y}.png';

    const colors = [
        '#F06050',
        '#6CC1ED',
        '#F7CD1F',
        '#814968',
        '#30C381',
        '#D6145F',
        '#475577',
        '#F4A460',
        '#EB7E7F',
        '#2C8397',
    ];

    const mapTileAttribution = `
        © <a href="https://www.mapbox.com/about/maps/">Mapbox</a>
        © <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a>
        <strong>
            <a href="https://www.mapbox.com/map-feedback/" target="_blank">
                Improve this map
            </a>
        </strong>`;

    class MapRenderer extends AbstractRendererOwl {
        /**
         * @constructor
         */
        constructor() {
            super(...arguments);
            this.leafletMap = null;
            this.markers = [];
            this.polylines = [];
            this.mapContainerRef = useRef('mapContainer');
            this.state = useState({
                closedGroupIds: [],
            });
        }
        /**
         * Load marker icons.
         *
         * @override
         */
        async willStart() {
            const p = { method: 'GET' };
            [this._pinCircleSVG, this._pinNoCircleSVG] = await Promise.all([
                this.env.services.httpRequest('web_map/static/img/pin-circle.svg', p, 'text'),
                this.env.services.httpRequest('web_map/static/img/pin-no-circle.svg', p, 'text'),
            ]);
            return super.willStart(...arguments);
        }
        /**
         * Initialize and mount map.
         *
         * @override
         */
        mounted() {
            this.leafletMap = L.map(this.mapContainerRef.el, {
                maxBounds: [L.latLng(180, -180), L.latLng(-180, 180)],
            });
            L.tileLayer(this.apiTilesRoute, {
                attribution: mapTileAttribution,
                tileSize: 512,
                zoomOffset: -1,
                minZoom: 2,
                maxZoom: 19,
                id: 'mapbox/streets-v11',
                accessToken: this.props.mapBoxToken,
            }).addTo(this.leafletMap);
            this._updateMap();
            super.mounted(...arguments);
        }
        /**
         * Update position in the map, markers and routes.
         *
         * @override
         */
        patched() {
            this._updateMap();
            super.patched(...arguments);
        }
        /**
         * Update group opened/closed state.
         *
         * @override
         */
        willUpdateProps(nextProps) {
            if (this.props.groupBy !== nextProps.groupBy) {
                this.state.closedGroupIds = [];
            }
            return super.willUpdateProps(...arguments);
        }
        /**
         * Remove map and the listeners on its markers and routes.
         *
         * @override
         */
        willUnmount() {
            for (const marker of this.markers) {
                marker.off('click');
            }
            for (const polyline of this.polylines) {
                polyline.off('click');
            }
            this.leafletMap.remove();
            super.willUnmount(...arguments);
        }

        //----------------------------------------------------------------------
        // Getters
        //----------------------------------------------------------------------

        /**
         * Return the route to the tiles api with or without access token.
         *
         * @returns {string}
         */
        get apiTilesRoute() {
            return this.props.mapBoxToken ? apiTilesRouteWithToken : apiTilesRouteWithoutToken;
        }

        //----------------------------------------------------------------------
        // Private
        //----------------------------------------------------------------------

        /**
         * If there's located records, adds the corresponding marker on the map.
         * Binds events to the created markers.
         *
         * @private
         */
        _addMarkers() {
            this._removeMarkers();

            const markersInfo = {};
            let records = this.props.records;
            if (this.props.groupBy) {
                records = Object.entries(this.props.recordGroups)
                    .filter(([key]) => !this.state.closedGroupIds.includes(key))
                    .flatMap(([, value]) => value.records);
            }

            for (const record of records) {
                const partner = record.partner;
                if (partner && partner.partner_latitude && partner.partner_longitude) {
                    const key = `${partner.partner_latitude}-${partner.partner_longitude}`;
                    if (key in markersInfo) {
                        markersInfo[key].record = record;
                        markersInfo[key].ids.push(record.id);
                    } else {
                        markersInfo[key] = { record: record, ids: [record.id] };
                    }
                }
            }

            for (const markerInfo of Object.values(markersInfo)) {
                const params = {
                    count: markerInfo.ids.length,
                    isMulti: markerInfo.ids.length > 1,
                    number: this.props.records.indexOf(markerInfo.record) + 1,
                    numbering: this.props.numbering,
                    pinSVG: (this.props.numbering ? this._pinNoCircleSVG : this._pinCircleSVG),
                };

                if (this.props.groupBy) {
                    const group = Object.entries(this.props.recordGroups)
                        .find(([, value]) => value.records.includes(markerInfo.record));
                    params.color = this._getGroupColor(group[0]);
                    params.number = group[1].records.indexOf(markerInfo.record) + 1;
                }

                // Icon creation
                const iconInfo = {
                    className: 'o_map_marker',
                    html: this.env.qweb.renderToString('web_map.legacy.marker', params),
                };

                // Attach marker with icon and popup
                const marker = L.marker([
                    markerInfo.record.partner.partner_latitude,
                    markerInfo.record.partner.partner_longitude
                ], { icon: L.divIcon(iconInfo) });
                marker.addTo(this.leafletMap);
                marker.on('click', () => {
                    this._createMarkerPopup(markerInfo);
                });
                this.markers.push(marker);
            }
        }
        /**
         * If there are computed routes, create polylines and add them to the map.
         * each element of this.props.routeInfo[0].legs array represent the route between
         * two waypoints thus each of these must be a polyline.
         *
         * @private
         */
        _addRoutes() {
            this._removeRoutes();
            if (!this.props.mapBoxToken || !this.props.routeInfo.routes.length) {
                return;
            }

            for (const leg of this.props.routeInfo.routes[0].legs) {
                const latLngs = [];
                for (const step of leg.steps) {
                    for (const coordinate of step.geometry.coordinates) {
                        latLngs.push(L.latLng(coordinate[1], coordinate[0]));
                    }
                }

                const polyline = L.polyline(latLngs, {
                    color: 'blue',
                    weight: 5,
                    opacity: 0.3,
                }).addTo(this.leafletMap);

                const polylines = this.polylines;
                polyline.on('click', function () {
                    for (const polyline of polylines) {
                        polyline.setStyle({ color: 'blue', opacity: 0.3 });
                    }
                    this.setStyle({ color: 'darkblue', opacity: 1.0 });
                });
                this.polylines.push(polyline);
            }
        }
        /**
         * Create a popup for the specified marker.
         *
         * @private
         * @param {Object} markerInfo
         */
        _createMarkerPopup(markerInfo) {
            const popupFields = this._getMarkerPopupFields(markerInfo);
            const partner = markerInfo.record.partner;
            const popupHtml = this.env.qweb.renderToString('web_map.legacy.markerPopup', {
                fields: popupFields,
                hasFormView: this.props.hasFormView,
                url: `https://www.google.com/maps/dir/?api=1&destination=${partner.partner_latitude},${partner.partner_longitude}`,
            });

            const popup = L.popup({ offset: [0, -30] })
                .setLatLng([partner.partner_latitude, partner.partner_longitude])
                .setContent(popupHtml)
                .openOn(this.leafletMap);

            const openBtn = popup.getElement().querySelector('button.o_open');
            if (openBtn) {
                openBtn.onclick = () => {
                    this.trigger('open_clicked', { ids: markerInfo.ids });
                };
            }
            return popup;
        }
        /**
         * @private
         * @param {Number} groupId
         */
        _getGroupColor(groupId) {
            const index = Object.keys(this.props.recordGroups).indexOf(groupId);
            return colors[index % colors.length];
        }
        /**
         * Creates an array of latLng objects if there is located records.
         *
         * @private
         * @returns {latLngBounds|boolean} objects containing the coordinates that
         *          allows all the records to be shown on the map or returns false
         *          if the records does not contain any located record.
         */
        _getLatLng() {
            const tabLatLng = [];
            for (const record of this.props.records) {
                const partner = record.partner;
                if (partner && partner.partner_latitude && partner.partner_longitude) {
                    tabLatLng.push(L.latLng(partner.partner_latitude, partner.partner_longitude));
                }
            }
            if (!tabLatLng.length) {
                return false;
            }
            return L.latLngBounds(tabLatLng);
        }
        /**
         * Get the fields' name and value to display in the popup.
         *
         * @private
         * @param {Object} markerInfo
         * @returns {Object} value contains the value of the field and string
         *                   contains the value of the xml's string attribute
         */
        _getMarkerPopupFields(markerInfo) {
            const record = markerInfo.record;
            const fieldsView = [];
            // Only display address in multi coordinates marker popup
            if (markerInfo.ids.length > 1) {
                if (!this.props.hideAddress) {
                    fieldsView.push({
                        value: record.partner.contact_address_complete,
                        string: this.env._t("Address"),
                    });
                }
                return fieldsView;
            }
            if (!this.props.hideName) {
                fieldsView.push({
                    value: record.display_name,
                    string: this.env._t("Name"),
                });
            }
            if (!this.props.hideAddress) {
                fieldsView.push({
                    value: record.partner.contact_address_complete,
                    string: this.env._t("Address"),
                });
            }
            for (const field of this.props.fieldNamesMarkerPopup) {
                if (record[field.fieldName]) {
                    let fieldName = record[field.fieldName] instanceof Array ?
                        record[field.fieldName][1] :
                        record[field.fieldName];

                    if (["date", "datetime"].includes(field.type)) {
                        const date = moment.utc(fieldName);
                        fieldName = format[field.type](date);
                    }

                    fieldsView.push({
                        value: fieldName,
                        string: field.string,
                    });
                }
            }
            return fieldsView;
        }
        /**
         * Remove the markers from the map and empty the markers array.
         *
         * @private
         */
        _removeMarkers() {
            for (const marker of this.markers) {
                this.leafletMap.removeLayer(marker);
            }
            this.markers = [];
        }
        /**
         * Remove the routes from the map and empty the the polyline array.
         *
         * @private
         */
        _removeRoutes() {
            for (const polyline of this.polylines) {
                this.leafletMap.removeLayer(polyline);
            }
            this.polylines = [];
        }
        /**
         * Update position in the map, markers and routes.
         *
         * @private
         */
        _updateMap() {
            if (this.props.shouldUpdatePosition) {
                const initialCoord = this._getLatLng();
                if (initialCoord) {
                    this.leafletMap.flyToBounds(initialCoord, { animate: false });
                } else {
                    this.leafletMap.fitWorld();
                }
                this.leafletMap.closePopup();
            }
            this._addMarkers();
            this._addRoutes();
        }

        //----------------------------------------------------------------------
        // Handlers
        //----------------------------------------------------------------------

        /**
         * Center the map on a certain pin and open the popup linked to it.
         *
         * @private
         * @param {Object} record
         */
        _centerAndOpenPin(record) {
            const popup = this._createMarkerPopup({
                record: record,
                ids: [record.id],
            });
            const px = this.leafletMap.project([record.partner.partner_latitude, record.partner.partner_longitude]);
            const popupHeight = popup.getElement().offsetHeight;
            px.y -= popupHeight / 2;
            const latlng = this.leafletMap.unproject(px);
            this.leafletMap.panTo(latlng, { animate: true });
        }
        /**
         * @private
         * @param {Number} id
         */
        _toggleGroup(id) {
            if (this.state.closedGroupIds.includes(id)) {
                const index = this.state.closedGroupIds.indexOf(id);
                this.state.closedGroupIds.splice(index, 1);
            } else {
                this.state.closedGroupIds.push(id);
            }
        }
    }
    MapRenderer.props = {
        arch: Object,
        count: Number,
        defaultOrder: {
            type: String,
            optional: true,
        },
        fetchingCoordinates: Boolean,
        fieldNamesMarkerPopup: {
            type: Array,
            element: {
                type: Object,
                shape: {
                    fieldName: String,
                    string: String,
                    type: String,
                },
            },
        },
        groupBy: [String, Boolean],
        hasFormView: Boolean,
        hideAddress: Boolean,
        hideName: Boolean,
        isEmbedded: Boolean,
        limit: Number,
        mapBoxToken: { type: [Boolean, String], optional: 1 },
        noContentHelp: {
            type: String,
            optional: true,
        },
        numbering: Boolean,
        hideTitle: Boolean,
        panelTitle: String,
        offset: Number,
        partners: { type: [Array, Boolean], optional: 1 },
        recordGroups: Object,
        records: Array,
        routeInfo: {
            type: Object,
            optional: true,
        },
        routing: Boolean,
        routingError: {
            type: String,
            optional: true,
        },
        shouldUpdatePosition: Boolean,
    };
    MapRenderer.template = 'web_map.legacy.MapRenderer';

    return MapRenderer;
});
;

/********************************************************
*  Filepath: /web_map/static/src/legacy/js/map_view.js  *
*  Bundle: web.assets_backend_legacy_lazy               *
*  Lines: 88                                            *
********************************************************/
odoo.define('web_map.MapView', function (require) {
"use strict";

const MapModel = require('web_map.MapModel');
const MapController = require('web_map.MapController');
const MapRenderer = require('web_map.MapRenderer');
const AbstractView = require('web.AbstractView');
const RendererWrapper = require('web.RendererWrapper');
const utils = require('web.utils');
const viewRegistry = require('web.view_registry');
const _t = require('web.core')._t;

const MapView = AbstractView.extend({
    jsLibs: [
        '/web_map/static/lib/leaflet/leaflet.js',
    ],
    config: _.extend({}, AbstractView.prototype.config, {
        Model: MapModel,
        Controller: MapController,
        Renderer: MapRenderer,
    }),
    icon: 'fa-map-marker',
    display_name: 'Map',
    viewType: 'map',
    mobile_friendly: true,
    searchMenuTypes: ['filter', 'groupBy', 'favorite'],

    init: function (viewInfo, params) {
        this._super.apply(this, arguments);

        const fieldNames = [];
        const fieldNamesMarkerPopup = [];

        this.loadParams.resPartnerField = this.arch.attrs.res_partner;
        fieldNames.push(this.arch.attrs.res_partner);
        fieldNames.push('display_name');

        if (this.arch.attrs.default_order) {
            this.loadParams.orderBy = [{ name: this.arch.attrs.default_order || 'display_name', asc: true }];
        }

        const routing = ["true", "True", "1"].includes(this.arch.attrs.routing);

        this.loadParams.limit = this.arch.attrs.limit ?
            parseInt(this.arch.attrs.limit, 10) :
            params.limit || 80;
        this.loadParams.routing = routing;
        this.rendererParams.routing = routing;
        this.rendererParams.numbering = this.arch.attrs.routing ? true : false;
        this.rendererParams.defaultOrder = this.arch.attrs.default_order;
        this.rendererParams.panelTitle = this.arch.attrs.panel_title || params.displayName || _t('Items');
        this.rendererParams.hideTitle = utils.toBoolElse(this.arch.attrs.hide_title || '', false);

        const hideName = utils.toBoolElse(this.arch.attrs.hide_name || '', false);
        this.rendererParams.hideName = hideName;
        if (!hideName) {
            fieldNames.push('display_name');
        }
        this.rendererParams.hideAddress = utils.toBoolElse(this.arch.attrs.hide_address || '', false);

        this.arch.children.forEach(node => {
            if (node.tag === 'field') {
                fieldNames.push(node.attrs.name);
                fieldNamesMarkerPopup.push({ fieldName: node.attrs.name, string: node.attrs.string, type: this.fields[node.attrs.name].type});
            }
        });

        this.loadParams.fieldsInfo = this.fields;
        this.loadParams.fieldNames = _.uniq(fieldNames);
        this.rendererParams.fieldNamesMarkerPopup = fieldNamesMarkerPopup;

        this.rendererParams.hasFormView = params.actionViews.some(view => view.type === "form");

        this.controllerParams.actionName = params.action ? params.action.name : _t("Untitled");
    },
    /**
     * @override
     */
    getRenderer(parent, state) {
        state = Object.assign({}, state, this.rendererParams);
        return new RendererWrapper(null, this.config.Renderer, state);
    },
});

viewRegistry.add('map', MapView);

return MapView;
});
;

/********************************************************************
*  Filepath: /web_cohort/static/src/legacy/js/cohort_controller.js  *
*  Bundle: web.assets_backend_legacy_lazy                           *
*  Lines: 208                                                       *
********************************************************************/
odoo.define('web_cohort.CohortController', function (require) {
'use strict';

const AbstractController = require('web.AbstractController');
const config = require('web.config');
const core = require('web.core');
const framework = require('web.framework');
const session = require('web.session');

const qweb = core.qweb;
const _t = core._t;

var CohortController = AbstractController.extend({
    custom_events: Object.assign({}, AbstractController.prototype.custom_events, {
        row_clicked: '_onRowClicked',
    }),
    /**
     * @override
     * @param {Widget} parent
     * @param {CohortModel} model
     * @param {CohortRenderer} renderer
     * @param {Object} params
     * @param {string} params.modelName
     * @param {string} params.title
     * @param {Object} params.measures
     * @param {Object} params.intervals
     * @param {string} params.dateStartString
     * @param {string} params.dateStopString
     * @param {string} params.timeline
     * @param {Array[]} params.views
     */
    init: function (parent, model, renderer, params) {
        this._super.apply(this, arguments);
        this.title = params.title;
        this.measures = params.measures;
        this.intervals = params.intervals;
        this.dateStartString = params.dateStartString;
        this.dateStopString = params.dateStopString;
        this.timeline = params.timeline;
        this.views = params.views;
    },

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    /**
     * Returns the current mode, measure and groupbys, so we can restore the
     * view when we save the current state in the search view, or when we add it
     * to the dashboard.
     *
     * @override
     * @returns {Object}
     */
    getOwnedQueryParams: function () {
        var state = this.model.get();
        return {
            context: {
                cohort_measure: state.measure,
                cohort_interval: state.interval,
            }
        };
    },

    /**
     * @override
     * @param {jQuery} [$node]
     */
    renderButtons: function ($node) {
        this.$buttons = $(qweb.render('CohortView.buttons', {
            measures: _.sortBy(_.pairs(this.measures), function(x){ return x[1].toLowerCase(); }),
            intervals: this.intervals,
            isMobile: config.device.isMobile
        }));
        this.$measureList = this.$buttons.find('.o_cohort_measures_list');
        this.$buttons.on('click', 'button', this._onButtonClick.bind(this));
        if ($node) {
            this.$buttons.appendTo($node);
        }
    },
    /**
     * Makes sure that the buttons in the control panel matches the current
     * state (so, correct active buttons and stuff like that);
     *
     * @override
     */
    updateButtons: function () {
        if (!this.$buttons) {
            return;
        }
        var data = this.model.get();
        // Hide download button if no cohort data
        var noData = !data.report.rows.length &&
                    (!data.comparisonReport ||
                    !data.comparisonReport.rows.length);
        this.$buttons.find('.o_cohort_download_button').toggleClass(
            'd-none',
            noData
        );
        if (config.device.isMobile) {
            var $activeInterval = this.$buttons
                .find('.o_cohort_interval_button[data-interval="' + data.interval + '"]');
            this.$buttons.find('.dropdown_cohort_content').text($activeInterval.text());
        }
        this.$buttons.find('.o_cohort_interval_button').removeClass('active');
        this.$buttons
            .find('.o_cohort_interval_button[data-interval="' + data.interval + '"]')
            .addClass('active');
        _.each(this.$measureList.find('.dropdown-item'), function (el) {
            var $el = $(el);
            $el.toggleClass('selected', $el.data('field') === data.measure);
        });
    },

    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------

    /**
     * Export cohort data in Excel file
     *
     * @private
     */
    _downloadExcel: function () {
        var data = this.model.get();
        data = _.extend(data, {
            title: this.title,
            model: this.modelName,
            interval_string: this.intervals[data.interval].toString(), // intervals are lazy-translated
            measure_string: this.measures[data.measure] || _t('Count'),
            date_start_string: this.dateStartString,
            date_stop_string: this.dateStopString,
            timeline: this.timeline,
        });
        framework.blockUI();
        session.get_file({
            url: '/web/cohort/export',
            data: {data: JSON.stringify(data)},
            complete: framework.unblockUI,
            error: (error) => this.call('crash_manager', 'rpc_error', error),
        });
    },
    /**
     * @private
     * @param {string} interval
     */
    _setInterval: function (interval) {
      this.update({interval: interval});
    },
    /**
     * @private
     * @param {string} measure should be a valid (and aggregatable) field name
     */
    _setMeasure: function (measure) {
        this.update({measure: measure});
    },
    /**
     * @override
     * @private
     * @returns {Promise}
     */
    _update: function () {
      this.updateButtons();
      return this._super.apply(this, arguments);
    },

    //--------------------------------------------------------------------------
    // Handlers
    //--------------------------------------------------------------------------

    /**
     * Do what need to be done when a button from the control panel is clicked.
     *
     * @private
     * @param {MouseEvent} ev
     */
    _onButtonClick: function (ev) {
        var $btn = $(ev.currentTarget);
        if ($btn.hasClass('o_cohort_interval_button')) {
            this._setInterval($btn.data('interval'));
        } else if ($btn.hasClass('o_cohort_download_button')) {
            this._downloadExcel();
        } else if ($btn.closest('.o_cohort_measures_list').length) {
            ev.preventDefault();
            ev.stopPropagation();
            this._setMeasure($btn.data('field'));
        }
    },
    /**
     * Open view when clicked on row
     *
     * @private
     * @param {OdooEvent} event
     */
    _onRowClicked: function (event) {
        this.do_action({
            type: 'ir.actions.act_window',
            name: this.title,
            res_model: this.modelName,
            views: this.views,
            domain: event.data.domain,
        });
    },
});

return CohortController;

});
;

/***************************************************************
*  Filepath: /web_cohort/static/src/legacy/js/cohort_model.js  *
*  Bundle: web.assets_backend_legacy_lazy                      *
*  Lines: 144                                                  *
***************************************************************/
odoo.define('web_cohort.CohortModel', function (require) {
'use strict';

var AbstractModel = require('web.AbstractModel');
const { processMeasure } = require("@web/views/helpers/utils");

var CohortModel = AbstractModel.extend({
    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    /**
    * @override
    * @returns {Object}
    */
    __get: function () {
        const { rangeDescription, comparisonRangeDescription } = this.timeRanges;
        return Object.assign({}, this.data, {
            hasContent: !this._isEmpty(),
            isSample: this.isSampleModel,
            rangeDescription,
            comparisonRangeDescription
        });
    },
    /**
     * @override
     * @param {Object} params
     * @param {string} params.modelName
     * @param {string} params.dateStart
     * @param {string} params.dateStop
     * @param {string} params.measure
     * @param {string} params.interval
     * @param {Array[]} params.domain
     * @param {string} params.mode
     * @param {string} params.timeline
     * @param {Object} params.timeRanges
     * @returns {Promise}
     */
    __load: function (params) {
        this.modelName = params.modelName;
        this.dateStart = params.dateStart;
        this.dateStop = params.dateStop;
        this.measure = processMeasure(params.measure);
        this.interval = params.interval;
        this.domain = params.domain;
        this.mode = params.mode;
        this.timeline = params.timeline;
        this.data = {
            measure: this.measure,
            interval: this.interval,
        };
        this.context = params.context;
        this.timeRanges = params.timeRanges;
        return this._fetchData();
    },
    /**
     * Reload data.
     *
     * @param {any} handle
     * @param {Object} params
     * @param {string} [params.measure]
     * @param {string} [params.interval]
     * @param {Array[]} [params.domain]
     * @param {Object} [params.timeRanges]
     * @returns {Promise}
     */
    __reload: function (handle, params) {
        if ('measure' in params) {
            this.data.measure = processMeasure(params.measure);
        }
        if ('interval' in params) {
            this.data.interval = params.interval;
        }
        if ('domain' in params) {
            this.domain = params.domain;
        }
        if ('timeRanges' in params) {
            this.timeRanges = params.timeRanges;
        }
        return this._fetchData();
    },

    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------

    /**
     * Fetch cohort data.
     *
     * @private
     * @returns {Promise}
     */
    _fetchData: function () {
        const domains = this._getDomains();
        const proms = domains.map(domain => {
            return this._rpc({
                model: this.modelName,
                method: 'get_cohort_data',
                kwargs: {
                    date_start: this.dateStart,
                    date_stop: this.dateStop,
                    measure: this.data.measure,
                    interval: this.data.interval,
                    domain: domain,
                    mode: this.mode,
                    timeline: this.timeline,
                    context: this.context
                }
            });
        });
        return Promise.all(proms).then(([report, comparisonReport]) => {
            this.data.report = report;
            this.data.comparisonReport = comparisonReport;
        });
    },
    /**
     * @private
     * @returns {Array[]}
     */
    _getDomains: function () {
        const { range, comparisonRange } = this.timeRanges;
        if (!range) {
            return [this.domain];
        }
        return [
            this.domain.concat(range),
            this.domain.concat(comparisonRange),
        ];
    },
    /**
     * @override
     */
    _isEmpty() {
        let rowCount = this.data.report.rows.length;
        if (this.data.comparisonReport) {
            rowCount += this.data.comparisonReport.rows.length;
        }
        return rowCount === 0;
    },
});

return CohortModel;

});
;

/******************************************************************
*  Filepath: /web_cohort/static/src/legacy/js/cohort_renderer.js  *
*  Bundle: web.assets_backend_legacy_lazy                         *
*  Lines: 83                                                      *
******************************************************************/
odoo.define('web_cohort.CohortRenderer', function (require) {
    'use strict';

    const OwlAbstractRenderer = require('web.AbstractRendererOwl');
    const field_utils = require('web.field_utils');

    class CohortRenderer extends OwlAbstractRenderer {

        constructor() {
            super(...arguments);
            this.sampleDataTargets = ['table'];
        }

        //--------------------------------------------------------------------------
        // Private
        //--------------------------------------------------------------------------

        /**
         * @param {integer} value
         * @returns {Array} first integers from 0 to value-1
         */
        _range(value) {
            return _.range(value);
        }
        /**
         * @param {float} value
         * @returns {string} formatted value with 1 digit
         */
        _formatFloat(value) {
            return field_utils.format.float(value, null, {
                digits: [42, 1],
            });
        }
        /**
         * @param {float} value
         * @returns {string} formatted value with 1 digit
         */
        _formatPercentage(value) {
            return field_utils.format.percentage(value, null, {
                digits: [42, 1],
            });
        }

        //--------------------------------------------------------------------------
        // Handlers
        //--------------------------------------------------------------------------

        /**
         * @private
         * @param {MouseEvent} ev
         */
        _onClickRow(ev) {
            if (!ev.target.classList.contains('o_cohort_value')) {
                return;
            }
            const rowData = ev.currentTarget.dataset;
            const rowIndex = rowData.rowIndex;
            const colIndex = ev.target.dataset.colIndex; // pas de colIndex dans le template
            // TODO: [SAD] fixme in master (type is always data because set unconditionally in template)
            const row = (rowData.type === 'data') ?
                this.props.report.rows[rowIndex] :
                this.props.comparisonReport.rows[rowIndex];
            const rowDomain = row ? row.domain : [];
            const cellContent = row ? row.columns[colIndex] : false;
            const cellDomain = cellContent ? cellContent.domain : [];

            const fullDomain = rowDomain.concat(cellDomain);
            if (cellDomain.length) {
                fullDomain.unshift('&');
            }
            if (fullDomain.length) {
                this.trigger('row_clicked', {
                    domain: fullDomain
                });
            }
        }
    }

    CohortRenderer.template = 'web_cohort.Legacy.CohortRenderer';

    return CohortRenderer;

});
;

/**************************************************************
*  Filepath: /web_cohort/static/src/legacy/js/cohort_view.js  *
*  Bundle: web.assets_backend_legacy_lazy                     *
*  Lines: 139                                                 *
**************************************************************/
odoo.define('web_cohort.CohortView', function (require) {
'use strict';

var AbstractView = require('web.AbstractView');
var core = require('web.core');
var CohortController = require('web_cohort.CohortController');
var CohortModel = require('web_cohort.CohortModel');
var CohortRenderer = require('web_cohort.CohortRenderer');
const RendererWrapper = require('web.RendererWrapper');
const legacyViewRegistry = require("web.view_registry");

var _t = core._t;
var _lt = core._lt;

var intervals = {
    day: _lt('Day'),
    week: _lt('Week'),
    month: _lt('Month'),
    year: _lt('Year'),
};

var CohortView = AbstractView.extend({
    display_name: _lt('Cohort'),
    icon: 'fa-signal',
    config: _.extend({}, AbstractView.prototype.config, {
        Model: CohortModel,
        Controller: CohortController,
        Renderer: CohortRenderer,
    }),
    viewType: 'cohort',
    searchMenuTypes: ['filter', 'comparison', 'favorite'],

    /**
     * @override
     */
    init: function (viewInfo, params) {
        this._super.apply(this, arguments);

        var fields = this.fields;
        var attrs = this.arch.attrs;
        const additionalMeasures = params.additionalMeasures || [];

        if (!attrs.date_start) {
            throw new Error(_lt('Cohort view has not defined "date_start" attribute.'));
        }
        if (!attrs.date_stop) {
            throw new Error(_lt('Cohort view has not defined "date_stop" attribute.'));
        }


        // Renderer Parameters
        var measures = {};
        _.each(fields, function (field, name) {
            if (name !== 'id' && field.store === true && _.contains(['integer', 'float', 'monetary'], field.type)) {
                measures[name] = field.string;
            }
        });

        this.arch.children.forEach(field => {
            let fieldName = field.attrs.name;
            // Remove invisible fields from the measures
            if (
                !additionalMeasures.includes(fieldName) &&
                field.attrs.invisible && py.eval(field.attrs.invisible)
            ) {
                delete measures[fieldName];
                return;
            }
            if (fieldName in measures && field.attrs.string) {
                measures[fieldName] = field.attrs.string;
            }
        });

        measures.__count = _t('Count');
        this.rendererParams.measures = measures;
        this.rendererParams.intervals = intervals;

        // Controller Parameters
        this.controllerParams.measures = _.omit(measures, '__count');
        this.controllerParams.intervals = intervals;
        this.controllerParams.title = params.title || attrs.string || _t('Untitled');
        // Used in export
        // Retrieve form and list view ids from the action to open those views
        // when a row of the cohort view is clicked
        this.controllerParams.views = [
            _findViewID('list'),
            _findViewID('form'),
        ];
        function _findViewID(viewType) {
            var action = params.action;

            if (action === undefined) {
                return [false, viewType];
            }
            var contextID = viewType === 'list' ? action.context.list_view_id : action.context.form_view_id;
            if (contextID) {
                return [contextID, viewType];
            } else {
                const result = action._views ? action._views.find((v) => v[1] === viewType) : undefined;
                return result || [false, viewType];
            }
        }
    },


    _updateMVCParams: function () {
        this._super.apply(this, arguments);
        // Model Parameters
        var context = this.loadParams.context;
        var attrs = this.arch.attrs;
        this.loadParams.dateStart = context.cohort_date_start ||  attrs.date_start;
        this.loadParams.dateStop = context.cohort_date_stop ||  attrs.date_stop;
        this.loadParams.mode = context.cohort_mode || attrs.mode || 'retention';
        this.loadParams.timeline = context.cohort_timeline || attrs.timeline || 'forward';
        this.loadParams.measure = context.cohort_measure ||  attrs.measure || '__count';
        this.loadParams.interval = context.cohort_interval || attrs.interval || 'day';

        this.rendererParams.mode = this.loadParams.mode;
        this.rendererParams.timeline = this.loadParams.timeline;
        this.rendererParams.dateStartString = this.fields[this.loadParams.dateStart].string;
        this.rendererParams.dateStopString = this.fields[this.loadParams.dateStop].string;

        this.controllerParams.dateStartString = this.rendererParams.dateStartString;
        this.controllerParams.dateStopString = this.rendererParams.dateStopString;
        this.controllerParams.timeline = this.rendererParams.timeline;
    },
     /**
     * @override
     */
    getRenderer(parent, state) {
        state = Object.assign({}, state, this.rendererParams);
        return new RendererWrapper(null, this.config.Renderer, state);
    },
});

legacyViewRegistry.add("cohort", CohortView); // Compatibility with Studio!
return CohortView;

});
;

/****************************************************************
*  Filepath: /web_cohort/static/src/legacy/js/sample_server.js  *
*  Bundle: web.assets_backend_legacy_lazy                       *
*  Lines: 92                                                    *
****************************************************************/
odoo.define('web_cohort/static/src/js/sample_server.js', function (require) {
    "use strict";

    const SampleServer = require('web.SampleServer');

    /**
     * This function mocks calls to the 'get_cohort_data' method. It is
     * registered to the SampleServer's mockRegistry, so it is called with a
     * SampleServer instance as "this".
     * @private
     * @param {Object} params
     * @param {string} params.model
     * @param {Object} params.kwargs
     * @returns {Object}
     */
    function _mockGetCohortData(params) {
        const { model } = params;
        const { date_start, interval, measure, mode, timeline } = params.kwargs;

        const columns_avg = {};
        const rows = [];
        let initialChurnValue = 0;

        const groups = this._mockReadGroup({ model, fields: [date_start], groupBy: [date_start + ':' + interval] });
        const totalCount = groups.length;
        let totalValue = 0;
        for (const group of groups) {
            const format = SampleServer.FORMATS[interval];
            const displayFormat = SampleServer.DISPLAY_FORMATS[interval];
            const date = moment(group[date_start + ':' + interval], format);
            const now = moment();
            let colStartDate = date.clone();
            if (timeline === 'backward') {
                colStartDate = colStartDate.subtract(15, interval);
            }

            let value = measure === '__count' ?
                            this._getRandomInt(SampleServer.MAX_INTEGER) :
                            this._generateFieldValue(model, measure);
            value = value || 25;
            totalValue += value;
            let initialValue = value;
            let max = value;

            const columns = [];
            for (let column = 0; column <= 15; column++) {
                if (!columns_avg[column]) {
                    columns_avg[column] = { percentage: 0, count: 0 };
                }
                if (colStartDate.clone().add(column, interval) > now) {
                    columns.push({ value: '-', churn_value: '-', percentage: '' });
                    continue;
                }
                let colValue = 0;
                if (max > 0) {
                    colValue = Math.min(Math.round(Math.random() * max), max);
                    max -= colValue;
                }
                if (timeline === 'backward' && column === 0) {
                    initialValue = Math.min(Math.round(Math.random() * value), value);
                    initialChurnValue = value - initialValue;
                }
                const previousValue = column === 0 ? initialValue : columns[column - 1].value;
                const remainingValue = previousValue - colValue;
                const previousChurnValue = column === 0 ? initialChurnValue : columns[column - 1].churn_value;
                const churn_value = colValue + previousChurnValue;
                let percentage = value ? parseFloat(remainingValue / value) : 0;
                if (mode === 'churn') {
                    percentage = 1 - percentage;
                }
                percentage = Number((100 * percentage).toFixed(1));
                columns_avg[column].percentage += percentage;
                columns_avg[column].count += 1;
                columns.push({
                    value: remainingValue,
                    churn_value,
                    percentage,
                    period: column, // used as a t-key but we don't care about value itself
                });
            }
            const keepRow = columns.some(c => c.percentage !== '');
            if (keepRow) {
                rows.push({ date: date.format(displayFormat), value, columns });
            }
        }
        const avg_value = totalCount ? (totalValue / totalCount) : 0;
        const avg = { avg_value, columns_avg };
        return { rows, avg };
    }

    SampleServer.mockRegistry.add('get_cohort_data', _mockGetCohortData);
});
;

/**************************************************************************
*  Filepath: /web_dashboard/static/src/legacy/js/dashboard_controller.js  *
*  Bundle: web.assets_backend_legacy_lazy                                 *
*  Lines: 100                                                             *
**************************************************************************/
odoo.define('web_dashboard.DashboardController', function (require) {
"use strict";

var AbstractController = require('web.AbstractController');
var BasicController = require('web.BasicController');
var core = require('web.core');
var Domain = require('web.Domain');

var _t = core._t;

var DashboardController = AbstractController.extend({
	custom_events: _.extend({}, BasicController.prototype.custom_events, {
        open_view: '_onOpenView',
    }),

    /**
     * @override
     */
    init: function (parent, model, renderer, params) {
        this._super.apply(this, arguments);
        // the dashboard view can trigger domain changes (when fields with a
        // domain attribute are clicked) ; this array registers the current -
        // clicked field specific - filters, so that they can be removed if
        // another field is clicked.
        this.actionDomain = params.actionDomain;
        this.currentFilterIDs = [];
    },

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    /**
     * @override
     */
    getOwnedQueryParams: function () {
        return {context: this.renderer.getsubControllersContext()};
    },

    //--------------------------------------------------------------------------
    // Handlers
    //--------------------------------------------------------------------------

    /**
     * Opens the requested view in an other action, so that it is displayed in
     * full screen.
     *
     * @private
     * @param {OdooEvent} ev
     * @param {string[]} [ev.data.additionalMeasures] view options to specify
     *  additional fields to consider for measures.
     * @param {Object} ev.data.context
     * @param {string} ev.data.viewType
     */
    _onOpenView: function (ev) {
        ev.stopPropagation();
        var data = ev.data;
        var action = {
            domain: this.actionDomain,
            context: data.context,
            name: _.str.sprintf(_t('%s Analysis'), _.str.capitalize(data.viewType)),
            res_model: this.modelName,
            type: 'ir.actions.act_window',
            views: [[false, data.viewType]],
            useSampleModel: false, // disable sample data when zooming on a sub view
        };
        if (!_.isEmpty(ev.data.additionalMeasures)) {
            action.flags = {
                additionalMeasures: ev.data.additionalMeasures
            };
        }
        this.do_action(action);
    },
    /**
     * Handles a reload request (it occurs when a field is clicked). If this
     * field as a domain attribute, a new filter for this domain is added to the
     * search view. If another field with a domain attribute has been clicked
     * previously, the corresponding filter is removed from the search view.
     * Finally, triggers a reload of the dashboard with the new combined domain.
     *
     * @override
     * @private
     * @param {OdooEvent} ev
     * @param {Array[]} ev.data.domain
     * @param {string} ev.data.domainLabel
     */
    _onReload: async function (ev) {
        ev.stopPropagation();
        const dashboardDomain = {};
        if (ev.data.domain && ev.data.domain.length) {
            dashboardDomain.domain = Domain.prototype.arrayToString(ev.data.domain);
            dashboardDomain.label = ev.data.domainLabel;
        }
        this.searchModel.dispatch("updateDashboardDomain", dashboardDomain);
    },
});

return DashboardController;

});
;

/*********************************************************************
*  Filepath: /web_dashboard/static/src/legacy/js/dashboard_model.js  *
*  Bundle: web.assets_backend_legacy_lazy                            *
*  Lines: 224                                                        *
*********************************************************************/
odoo.define('web_dashboard.DashboardModel', function (require) {
"use strict";

/**
 * This module defines the DashboardModel, an extension of the BasicModel.
 * Unlike the BasicModel, the DashboardModel only keep a single dataPoint (there
 * is no relational data in this model), and this dataPoint contains two
 * additional keys: aggregates and formulas, which gather the information
 * about the <aggregate> and <formula> occurrences in the dashboard arch.
 */

var BasicModel = require('web.BasicModel');
var dataComparisonUtils = require('web.dataComparisonUtils');
var Domain = require('web.Domain');
var pyUtils = require('web.py_utils');

var computeVariation = dataComparisonUtils.computeVariation;

var DashboardModel = BasicModel.extend({

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    /**
     * @override
     */
    __get: function () {
        var record = this._super.apply(this, arguments);
        record.timeRanges = this.dataPoint.timeRanges;
        record.timeRange = this.dataPoint.timeRange;
        record.comparisonTimeRange = this.dataPoint.comparisonTimeRange;
        record.compare = this.dataPoint.compare;
        record.comparisonData = this.dataPoint.comparisonData;
        record.variationData = this.dataPoint.variationData;
        record.isSample = this.isSampleModel;
        return record;
     },
    /**
     * @override
     */
    __load: function (params) {
        params.type = 'record';
        this.dataPoint = this._makeDataPoint(params);
        return this._load(this.dataPoint);
    },
    /**
     * @override
     */
    __reload: function (id, options) {
        options = options || {};
        if (options.domain !== undefined) {
            this.dataPoint.domain = options.domain;
        }
        if ('timeRanges' in options) {
            this._processTimeRanges(this.dataPoint, options.timeRanges);
        }
        return this._load(this.dataPoint);
    },

    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------

    /**
     * Evaluates formulas of the dataPoint with its values.
     *
     * @private
     * @param {Object} dataPoint
     */
    _evaluateFormulas: function (dataPoint) {
        _.each(dataPoint.formulas, function (formula, formulaID) {
            try {
                dataPoint.data[formulaID] = pyUtils.py_eval(formula.value, {
                    record: dataPoint.data
                });
                if (!isFinite(dataPoint.data[formulaID])) {
                    dataPoint.data[formulaID] = NaN;
                }
            } catch (e) {
                dataPoint.data[formulaID] = NaN;
            }
            if (dataPoint.compare) {
                try {
                    dataPoint.comparisonData[formulaID] = pyUtils.py_eval(formula.value, {
                        record: dataPoint.comparisonData
                    });
                    if (!isFinite(dataPoint.comparisonData[formulaID])) {
                        dataPoint.comparisonData[formulaID] = NaN;
                    }
                } catch (e) {
                    dataPoint.comparisonData[formulaID] = NaN;
                }
            }
        });
    },
    /**
     * @param  {Array[]} aggregateDomain
     * @param  {Array[]} range
     * @return {Array[]}
     */
    _getReadGroupDomain: function (aggregateDomain, range) {
        return Domain.prototype.normalizeArray(this.dataPoint.domain)
            .concat(range)
            .concat(Domain.prototype.normalizeArray(new Domain(aggregateDomain).toArray()));
    },
    /**
     * @override
     */
    _isEmpty() {
        return this.dataPoint.count === 0;
    },
    /**
     * @override
     * @private
     */
    _load: function (dataPoint) {
        var self = this;

        let count = 0;
        const domainMapping = {};
        if (this.useSampleModel) {
            // force to do a read_group RPC without domain to determine if there is data to display
            domainMapping['[]'] = [];
        }
        var fieldsInfo = dataPoint.fieldsInfo.dashboard;
        _.each(dataPoint.aggregates, function (aggregateName) {
            var domain = fieldsInfo[aggregateName].domain;
            if (domain in domainMapping) {
                domainMapping[domain].push(aggregateName);
            } else {
                domainMapping[domain] = [aggregateName];
            }
        });

        var defs = [];
        _.each(domainMapping, function (aggregateNames, domain) {
            var fields = _.map(aggregateNames, function (aggregateName) {
                var fieldName = fieldsInfo[aggregateName].field;
                var groupOperator = fieldsInfo[aggregateName].group_operator;
                return aggregateName + ':' + groupOperator + '(' + fieldName + ')';
            });

            defs.push(self._readGroup({
                domain: self._getReadGroupDomain(domain, self.dataPoint.timeRange),
                fields: fields,
            }).then(function (result) {
                count = count + (domain === '[]' ? result.__count : 0);
                _.extend(self.dataPoint.data, _.pick(result, aggregateNames));
            }));
            if (dataPoint.compare) {
                defs.push(self._readGroup({
                    domain: self._getReadGroupDomain(domain, self.dataPoint.comparisonTimeRange),
                    fields: fields,
                }).then(function (result) {
                    count = count + (domain === '[]' ? result.__count : 0);
                    _.extend(self.dataPoint.comparisonData, _.pick(result, aggregateNames));
                }));
            }
        });

        return Promise.all(defs).then(function () {
            self.dataPoint.count = count;
            self._evaluateFormulas(dataPoint);
            if (dataPoint.compare) {
                var value, comparisonValue;
                for (var statisticName in dataPoint.data) {
                    value = dataPoint.data[statisticName];
                    comparisonValue = dataPoint.comparisonData[statisticName];
                    dataPoint.variationData[statisticName] = computeVariation(value, comparisonValue);
                }
            } else {
                dataPoint.comparisonData = {};
                dataPoint.variationData = {};
            }
            return dataPoint.id;
        });
    },
    /**
     * @override
     * @private
     */
    _makeDataPoint: function (params) {
        var dataPoint = this._super.apply(this, arguments);
        dataPoint.aggregates = params.aggregates;
        dataPoint.count = 0;
        dataPoint.formulas = params.formulas;
        dataPoint.comparisonData = {};
        dataPoint.variationData = {};
        this._processTimeRanges(dataPoint, params.timeRanges);
        return dataPoint;
    },
    /**
     * @param  {Object} args
     * @returns {Promise}
     */
    _readGroup: function (args) {
        var readGroupArgs = _.extend({
            context: this.dataPoint.getContext(),
            groupBy: [],
            lazy: true,
            method: 'read_group',
            model: this.dataPoint.model,
            orderBy: [],
        }, args);
        return this._rpc(readGroupArgs).then(function (result) {
            result = result[0];
            return _.mapObject(result, function (value) {
                return value || 0;
            });
        });
    },
    _processTimeRanges: function (dataPoint, timeRanges) {
        const { range, comparisonRange } = timeRanges;
        dataPoint.timeRanges = timeRanges;
        dataPoint.timeRange = range || [];
        dataPoint.comparisonTimeRange = comparisonRange || [];
        dataPoint.compare = Boolean(dataPoint.comparisonTimeRange.length);
    },
});

return DashboardModel;

});
;

/*******************************************************************************
*  Filepath: /web_dashboard/static/src/legacy/js/dashboard_model_extension.js  *
*  Bundle: web.assets_backend_legacy_lazy                                      *
*  Lines: 87                                                                   *
*******************************************************************************/
odoo.define("web_dashboard/static/src/js/dashboard_model_extension.js", function (require) {
    "use strict";

    const ActionModel = require("web.ActionModel");

    const DASHBOARD_FACET_ID = "dashboard";

    class DashboardModelExtension extends ActionModel.Extension {

        //---------------------------------------------------------------------
        // Public
        //---------------------------------------------------------------------

        /**
         * @override
         */
        prepareState() {
            this.state.domain = null;
            this.state.facets = null;
        }

        /**
         * @override
         * @returns {any}
         */
        get(property) {
            switch (property) {
                case "domain": return this.getDomain();
                case "facets": return this.getFacets();
            }
        }

        //---------------------------------------------------------------------
        // Actions / Getters
        //---------------------------------------------------------------------

        /**
         * Removes the dashboard group facet if the right ID is given.
         * @param {number | string} groupId
         */
        deactivateGroup(groupId) {
            if (groupId === DASHBOARD_FACET_ID) {
                this.state.domain = null;
                this.state.facets = null;
            }
        }

        /**
         * Returns the current dashboard domain.
         * @returns {Array[] | null}
         */
        getDomain() {
            return this.state.domain;
        }

        /**
         * Returns the current dashboard facet.
         * @returns {Object | null}
         */
        getFacets() {
            return this.state.facets;
        }

        /**
         * Updates the current dashboard domain and creates a facet based on
         * the given label.
         * @param {Object} params
         * @param {Array[]} params.domain
         * @param {string} params.label
         */
        updateDashboardDomain({ domain, label }) {
            this.state.domain = domain || null;
            if (domain) {
                const facet = {
                    groupId: DASHBOARD_FACET_ID,
                    type: "filter",
                    values: [label],
                };
                this.state.facets = [facet];
            } else {
                this.state.facets = null;
            }
        }
    }

    ActionModel.registry.add("Dashboard", DashboardModelExtension, 50);
});
;

/************************************************************************
*  Filepath: /web_dashboard/static/src/legacy/js/dashboard_renderer.js  *
*  Bundle: web.assets_backend_legacy_lazy                               *
*  Lines: 446                                                           *
************************************************************************/
odoo.define('web_dashboard.DashboardRenderer', function (require) {
"use strict";

var config = require('web.config');
var core = require('web.core');
var dataComparisonUtils = require('web.dataComparisonUtils');
var Domain = require('web.Domain');
var fieldUtils = require('web.field_utils');
var FormRenderer = require('web.FormRenderer');
var pyUtils = require('web.py_utils');
var viewRegistry = require('web.view_registry');

var renderComparison = dataComparisonUtils.renderComparison;
var renderVariation = dataComparisonUtils.renderVariation;

var QWeb = core.qweb;

var DashboardRenderer = FormRenderer.extend({
    className: "o_legacy_dashboard_view",
    sampleDataTargets: ['.o_subview', '.o_group'],
    events: {
        'click .o_aggregate.o_clickable': '_onAggregateClicked',
    },
    // override the defaul col attribute for groups as in the dashbard view,
    // labels and fields are displayed vertically, thus allowing to display
    // more fields on the same line
    OUTER_GROUP_COL: 6,

    /**
     * @override
     */
    init: function (parent, state, params) {
        this._super.apply(this, arguments);
        this.mode = 'readonly';
        this.subFieldsViews = params.subFieldsViews;
        this.subViewRefs = params.subViewRefs;
        this.additionalMeasures = params.additionalMeasures;
        this.subControllers = {};
        this.subControllersContext = _.pick(state.context || {}, 'pivot', 'graph', 'cohort');
        this.subcontrollersNextMeasures = {pivot: {}, graph: {}, cohort: {}};
        var session = this.getSession();
        var currency_id = session.company_currency_id;
        if (session.companies_currency_id && session.user_context.allowed_company_ids) {
            currency_id = session.companies_currency_id[session.user_context.allowed_company_ids[0]];
        }
        this.formatOptions = {
            // in the dashboard view, all monetary values are displayed in the
            // currency of the current company of the user
            currency_id: currency_id,
            // allow to decide if utils.human_number should be used
            humanReadable: function (value) {
                return Math.abs(value) >= 1000;
            },
            // with the choices below, 1236 is represented by 1.24k
            minDigits: 1,
            decimals: 2,
            // avoid comma separators for thousands in numbers when human_number is used
            formatterCallback: function (str) {
                return str;
            }
        };
    },
    /**
     * @override
     */
    on_attach_callback: function () {
        this._super.apply(this, arguments);
        this.isInDOM = true;
        _.invoke(this.subControllers, 'on_attach_callback');
    },
    /**
     * @override
     */
    on_detach_callback: function () {
        this._super.apply(this, arguments);
        this.isInDOM = false;
    },

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    /**
     * Returns a dict containing the context of sub views.
     *
     * @returns {Object}
     */
    getsubControllersContext: function () {
        return _.mapObject(this.subControllers, function (controller) {
            // for now the views embedded in a dashboard can be of type
            // cohort, graph, pivot. The getOwnedQueryParams method of their controller
            // does not export anything but a context.
            return controller.getOwnedQueryParams().context;
        });
    },
    /**
     * Overrides to update the context of sub controllers.
     *
     * @override
     */
    updateState: function (state, params) {
        var viewType;
        for (viewType in this.subControllers) {
            this.subControllersContext[viewType] = this.subControllers[viewType].getOwnedQueryParams().context;
        }
        var subControllersContext = _.pick(params.context || {}, 'pivot', 'graph', 'cohort');
        _.extend(this.subControllersContext, subControllersContext);
        for (viewType in this.subControllers) {
            _.extend(this.subControllersContext[viewType], this.subcontrollersNextMeasures[viewType]);
            this.subcontrollersNextMeasures[viewType] = {};
        }
        return this._super.apply(this, arguments);
    },

    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------

    /**
     * Add a tooltip on a $node.
     * The message can be customize using the tooltip attribute
     *
     * @param {FieldWidget} widget
     * @param {$node} $node
     */
    _addStatisticTooltip: function ($el, node) {
        $el.tooltip({
            delay: { show: 1000, hide: 0 },
            title: function () {
                return QWeb.render('web_dashboard.LegacyStatisticTooltip', {
                    debug: config.isDebug(),
                    node: node,
                });
            }
        });
    },

    /**
     * Renders an aggregate (or formula)'s label.
     *
     * @private
     * @param {Object} node
     * @returns {jQueryElement}
     */
    _renderLabel: function (node) {
        var text = node.attrs.name;
        if ('string' in node.attrs) { // allow empty string
            text = node.attrs.string;
        }
        var $result = $('<label>', {text: text});
        return $result;
    },
    /**
     * Renders a statistic (from an aggregate or a formula) with its label.
     * If a widget attribute is specified, and if there is no corresponding
     * formatter, instanciates a widget to render the value. Otherwise, simply
     * uses the corresponding formatter (with a fallback on the field's type).
     *
     * @private
     * @param {Object} node
     * @returns {jQueryElement}
     */
    _renderStatistic: function (node) {
        var self = this;
        var $label = this._renderLabel(node);

        var $el = $('<div>')
            .attr('name', node.attrs.name)
            .append($label);
        var $value;
        var statisticName = node.attrs.name;
        var variation;
        var formatter;
        var statistic = self.state.fieldsInfo.dashboard[statisticName];
        var valueLabel =  statistic.value_label ? (' ' + statistic.value_label) : '';
        if (!node.attrs.widget || (node.attrs.widget in fieldUtils.format)) {
            // use a formatter to render the value if there exists one for the
            // specified widget attribute, or there is no widget attribute
            var fieldValue = self.state.data[statisticName];
            fieldValue = _.contains(['date', 'datetime'], statistic.type) ? (fieldValue === 0 ? NaN : moment(fieldValue)) : fieldValue;
            var formatType = node.attrs.widget || statistic.type;
            formatter = fieldUtils.format[formatType];
            if (this.state.compare) {
                var comparisonValue = this.state.comparisonData[statisticName];
                comparisonValue = _.contains(['date', 'datetime'], statistic.type) ? (comparisonValue === 0 ? NaN : moment(comparisonValue)) : comparisonValue;
                variation = this.state.variationData[statisticName];
                renderComparison($el, fieldValue, comparisonValue, variation, formatter, statistic, this.formatOptions);
                $('.o_comparison', $el).append(valueLabel);

            } else {
                fieldValue = isNaN(fieldValue) ? '-' : formatter(fieldValue, statistic, this.formatOptions);
                $value = $('<div>', {class: 'o_value'}).html(fieldValue + valueLabel);
                $el.append($value);
            }
        } else {
            if (this.state.compare) {
                // use fakeState here too (to change domain)?
                var $originalValue = this._renderFieldWidget(node, this.state);
                var fakeState = _.clone(this.state);
                fakeState.data = fakeState.comparisonData;
                var $comparisonValue = this._renderFieldWidget(node, fakeState);
                variation = this.state.variationData[statisticName];
                fakeState.data[statisticName] = variation;

                $el
                .append(renderVariation(variation, statistic))
                .append($('<div>', {class: 'o_comparison'}).append(
                    $originalValue,
                    $('<span>').html(" vs "),
                    $comparisonValue
                ));
            } else {
                // instantiate a widget to render the value if there is no formatter
                $value = this._renderFieldWidget(node, this.state).addClass('o_value');
                $el.append($value);
            }
        }

        // customize border left
        if (variation) {
            if (variation > 0) {
                $el.addClass('border-success');
            } else if (variation < 0) {
                $el.addClass('border-danger');
            }
        }

        this._registerModifiers(node, this.state, $el);
        if (config.isDebug() || node.attrs.help) {
            this._addStatisticTooltip($el, node);
        }
        return $el;
    },
    /**
     * Renders the buttons of a given sub view, with an additional button to
     * open the view in full screen.
     *
     * @private
     */
    _renderSubViewButtons: async function ($el, controller) {
        var $buttons = $('<div>', {class: 'o_' + controller.viewType + '_buttons o_dashboard_subview_buttons'});

        // render the view's buttons
        controller.renderButtons($buttons);

        // we create a button's group, get the primary button(s)
        // and put it/them into this group
        var $buttonGroup = $('<div class="btn-group">');
        $buttonGroup.append($buttons.find('[aria-label="Main actions"]'));
        $buttonGroup.append($buttons.find('.dropdown:has(.o_group_by_menu)'));
        $buttonGroup.prependTo($buttons);

        // render the button to open the view in full screen
        $('<button>')
            .addClass("btn btn-outline-secondary fa fa-arrows-alt float-right o_button_switch")
            .attr({title: 'Full Screen View', viewType: controller.viewType})
            .tooltip()
            .on('click', this._onViewSwitcherClicked.bind(this))
            .appendTo($buttons);

        // select primary and interval buttons and alter their style
        $buttons.find('.btn-primary,.btn-secondary')
            .removeClass('btn-primary btn-secondary')
            .addClass("btn-outline-secondary");
        $buttons.find('[class*=interval_button]').addClass('text-muted text-capitalize');
        // remove bars icon on "Group by" button
        $buttons.find('.fa.fa-bars').removeClass('fa fa-bars');

        $buttons.prependTo($el);

        return controller.updateButtons();
    },
    /**
     * @private
     * @param {Object} node
     * @returns {jQueryElement}
     */
    _renderTagAggregate: function (node) {
        var $aggregate = this._renderStatistic(node).addClass('o_aggregate');
        var isClickable = node.attrs.clickable === undefined || pyUtils.py_eval(node.attrs.clickable);
        $aggregate.toggleClass('o_clickable', isClickable);

        var $result = $('<div>').addClass('o_aggregate_col').append($aggregate);
        this._registerModifiers(node, this.state, $result);
        return $result;
    },
    /**
     * @private
     * @param {Object} node
     * @returns {jQueryElement}
     */
    _renderTagFormula: function (node) {
        return this._renderStatistic(node).addClass('o_formula');
    },
    /**
     * In the dashboard, both inner and outer groups are rendered the same way:
     * with a div (no table), i.e. like the outer group of the form view.
     *
     * @override
     * @private
     */
    _renderTagGroup: function (node) {
        var $group = this._renderOuterGroup(node);
        if (node.children.length && node.children[0].tag === 'widget') {
            $group.addClass('o_has_widget');
        }
        return $group;
    },
    /**
     * Handles nodes with tagname 'view': instanciates the requested view,
     * renders its buttons and returns a jQuery element containing the buttons
     * and the controller's $el.
     *
     * @private
     * @param {Object} node
     * @returns {jQueryElement}
     */
    _renderTagView: function (node) {
        var self = this;
        var viewType = node.attrs.type;
        var controllerContext = this.subControllersContext[viewType];
        var searchQuery = {
            context: _.extend({}, this.state.context, controllerContext),
            domain: this.state.domain,
            groupBy: [],
            timeRanges: this.state.timeRanges,
        };
        var subViewParams = {
            modelName: this.state.model,
            withControlPanel: false,
            withSearchPanel: false,
            hasSwitchButton: true,
            isEmbedded: true,
            additionalMeasures: this.additionalMeasures,
            searchQuery: searchQuery,
            useSampleModel: Boolean(this.state.isSample),
        };
        var SubView = viewRegistry.get(viewType);
        var subView = new SubView(this.subFieldsViews[viewType], subViewParams);
        var $div = $('<div>', {class: 'o_subview', type: viewType});
        var def = subView.getController(this).then(function (controller) {
            return controller.appendTo($div).then(function () {
                return self._renderSubViewButtons($div, controller).then(() => {
                    self.subControllers[viewType] = controller;
                });
            });
        });
        this.defs.push(def);
        return $div;
    },
    /**
     * Overrides to destroy potentially previously instantiates sub views, and
     * to call 'on_attach_callback' on the new sub views and the widgets if the
     * dashboard is already in the DOM when being rendered.
     *
     * @override
     * @private
     */
    _renderView: function () {
        var self = this;
        var oldControllers = _.values(this.subControllers);
        var r = this._super.apply(this, arguments);
        return r.then(function () {
            _.invoke(oldControllers, 'destroy');
            if (self.isInDOM) {
                _.invoke(self.subControllers, 'on_attach_callback');
            }
            if (self.state.isSample) {
                self._renderNoContentHelper();
            }
        });
    },
    /**
     * Overrides to get rid of the FormRenderer logic about fields, as there is
     * no field tag in the dashboard view. Simply updates the renderer's $el.
     *
     * @private
     * @override
     */
    _updateView: function ($newContent) {
        this.$el.html($newContent);
    },

    //--------------------------------------------------------------------------
    // Handlers
    //--------------------------------------------------------------------------

    /**
     * Handles the click on a measure (i.e. a real field of the model, not a
     * formula). Activates this measure on subviews, and if there is a domain
     * specified, activates this domain on the whole dashboard.
     *
     * @private
     * @param {MouseEvent} ev
     */
    _onAggregateClicked: function (ev) {
        // update the measure(s) of potential graph and pivot subcontrollers
        // (this doesn't trigger a reload, it only updates the internal state
        // of those controllers)
        var aggregate = ev.currentTarget.getAttribute('name');
        var aggregateInfo = this.state.fieldsInfo.dashboard[aggregate];
        var measure = aggregateInfo.measure !== undefined ? aggregateInfo.measure : aggregateInfo.field;
        if (this.subControllers.pivot) {
            this.subcontrollersNextMeasures.pivot.pivot_measures = [measure];
        }
        if (this.subControllers.graph) {
            this.subcontrollersNextMeasures.graph.graph_measure = measure;
        }
        if (this.subControllers.cohort) {
            this.subcontrollersNextMeasures.cohort.cohort_measure = measure;
        }
        // update the domain and trigger a reload
        var domain = new Domain(aggregateInfo.domain);
        // I don't know if it is a good idea to use this.state.fields[measure].string
        var label = aggregateInfo.domain_label || aggregateInfo.string || aggregateInfo.name;
        this.trigger_up('reload', {
            domain: domain.toArray(),
            domainLabel: label,
        });
    },
    /**
     * Sends a request to open the given view in full screen.
     *
     * @todo; take the current domain into account, once it will be correctly
     * propagated to subviews
     * @private
     * @param {MouseEvent} ev
     */
    _onViewSwitcherClicked: function (ev) {
        ev.stopPropagation();
        var viewType = $(ev.currentTarget).attr('viewType');
        var controller = this.subControllers[viewType];
        // For now the views embedded in a dashboard can be of type cohort, graph, pivot. The
        // getOwnedQueryParams method of their controller does not export anything but a context.
        const controllerContext = controller.getOwnedQueryParams().context;
        this.trigger_up('open_view', {
            context: Object.assign({}, this.state.context, controllerContext, this.subViewRefs),
            viewType: viewType,
            additionalMeasures: this.additionalMeasures,
        });
    },
});

return DashboardRenderer;

});
;

/********************************************************************
*  Filepath: /web_dashboard/static/src/legacy/js/dashboard_view.js  *
*  Bundle: web.assets_backend_legacy_lazy                           *
*  Lines: 218                                                       *
********************************************************************/
odoo.define('web_dashboard.DashboardView', function (require) {
"use strict";

/**
 * This file defines the Dashboard view and adds it to the view registry. This
 * is a reporting that can embed graph and/or pivot views, and displays
 * aggregate values (obtained from read_group RPCs). It is based on the FormView
 * (extensions of FormRenderer, BasicView and BasicModel).
 */

var BasicView = require('web.BasicView');
var core = require('web.core');
var viewRegistry = require('web.view_registry');

var DashboardController = require('web_dashboard.DashboardController');
var DashboardModel = require('web_dashboard.DashboardModel');
var DashboardRenderer = require('web_dashboard.DashboardRenderer');

var _lt = core._lt;

var DashboardView = BasicView.extend({
    config: _.extend({}, BasicView.prototype.config, {
        Model: DashboardModel,
        Controller: DashboardController,
        Renderer: DashboardRenderer,
    }),
    display_name: _lt('Dashboard'),
    searchMenuTypes: ['filter', 'comparison', 'favorite'],
    icon: 'fa-tachometer',
    viewType: 'dashboard',

    /**
     * @override
     */
	init: function (viewInfo, params) {
        this._super.apply(this, arguments);
        this.modelName = params.modelName;

        this.controllerParams.actionDomain = (params.action && params.action.domain) || [];

        this.rendererParams.subFieldsViews = {};

        // pass all measurable fields to subviews
        var fields = this.fieldsInfo.dashboard;
        const additionalMeasures = [];
        for (const f of Object.values(fields)) {
            if (f.realType === "many2one" && !f.invisible) {
                additionalMeasures.push(f.field);
            }
        }
        this.rendererParams.additionalMeasures = additionalMeasures;

        // generate sub view refs to add in the context to fetch the adequate views
        this.subViewRefs = {};
        _.each(this.fieldsView.subViews, subView => {
            if (subView[0]) {
                this.subViewRefs[subView[1] + '_view_ref'] = subView[0];
            }
        });
        this.rendererParams.subViewRefs = this.subViewRefs;

        // replaces the xmlids by false in the views description
        this.fieldsView.subViews = _.map(this.fieldsView.subViews, function (subView) {
            return [false, subView[1]]; // e.g. [false, 'graph']
        });

        this.loadParams.aggregates = this.fieldsView.aggregates;
        this.loadParams.formulas = this.fieldsView.formulas;

	},

    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------

    /**
     * @override
     */
    _createSearchModel(params, extraExtensions = {}) {
        Object.assign(extraExtensions, { Dashboard: {} });
        return this._super(params, extraExtensions);
    },

    /**
     * Overrides to fetch the fieldsView of subviews.
     *
     * @override
     * @private
     */
    _loadData: function (model) {
        var self = this;

        var subViewsDef;
        if (this.fieldsView.subViews.length) {
            const context = Object.assign({}, this.subViewRefs, this.loadParams.context);
            subViewsDef = model
                .loadViews(this.modelName, context, this.fieldsView.subViews)
                .then(function (fieldsViews) {
                    for (var viewType in fieldsViews) {
                        self.rendererParams.subFieldsViews[viewType] = fieldsViews[viewType];
                    }
                });
        }

        var superDef = this._super.apply(this, arguments);
        return Promise.all([superDef, subViewsDef]).then(function (results) {
            // the parent expects a promise resolved with an Object of the form
            // { state, handle }, but with this override, it becomes a promise
            // resolved with an Array, whose first element is the wanted object.
            return results[0];
        });
    },
    /**
     * Processes nodes with tagName 'aggregate'. Same API as _processNode.
     *
     * @private
     * @param {Object} node
     * @param {Object} fv
     * @returns {boolean}
     */
    _processAggregateNode: function (node, fv) {
        var aggregateID = node.attrs.name;
        var field = fv.viewFields[node.attrs.field];

        var aggregate = _.defaults({}, node.attrs, {
            domain: '[]',
            group_operator: field.group_operator,
        });
        aggregate.Widget = this._getFieldWidgetClass('dashboard', field, aggregate);

        // in the dashboard views, many2one fields are fetched with the
        // group_operator 'count_distinct', which means that the values
        // manipulated client side for these fields are integers
        if (field.type === 'many2one') {
            field.type = 'integer';
            field.realType = 'many2one';
            aggregate.realType = 'many2one';
            aggregate.group_operator = 'count_distinct';
        }
        aggregate.type = field.type;

        fv.fieldsInfo.dashboard[aggregateID] = aggregate;
        fv.viewFields[node.attrs.name] = _.extend({}, field, {
            name: node.attrs.name,
        });
        fv.aggregates.push(aggregateID);
        return false;
    },
    /**
     * In the dashboard view, additional tagnames are allowed: 'view', 'formula'
     * and 'aggregate'. We override the processing of the arch to gather
     * information about the occurrences of these tagnames in the arch.
     *
     * @override
     * @private
     */
    _processArch: function (arch, fv) {
        fv.aggregates = [];
        fv.formulas = {};
        fv.subViews = [];
        // there are no field nodes in the dashboard arch, so viewFields is
        // basically a shallow copy of fields, which is the dict shared between
        // all views, and which is thus (deeply) frozen ; we here deeply clone
        // it so that we can change (in place) the type of many2one fields into
        // integer.
        fv.viewFields = $.extend(true, {}, fv.viewFields);
        this._super.apply(this, arguments);
    },
    /**
     * Processes nodes with tagName 'formula'. Same API as _processNode.
     *
     * @private
     * @param {Object} node
     * @param {Object} fv
     * @returns {boolean}
     */
    _processFormulaNode: function (node, fv) {
        var formulaID = node.attrs.name || _.uniqueId('formula_');
        node.attrs.name = formulaID;

        var formula = _.extend({}, node.attrs, {type: 'float'});
        var fakeField = {name: formulaID, type: 'float'};
        formula.Widget = this._getFieldWidgetClass('dashboard', fakeField, formula);

        fv.fieldsInfo.dashboard[formulaID] = formula;
        fv.viewFields[formulaID] = fakeField;
        fv.formulas[formulaID] = _.pick(node.attrs, 'string', 'value');
        return false;
    },
    /**
     * Overrides to handle nodes with tagname 'aggregate', 'formula' and 'view'.
     *
     * @override
     * @private
     */
    _processNode: function (node, fv) {
        var res = this._super.apply(this, arguments);

        if (node.tag === 'aggregate') {
            res = this._processAggregateNode(node, fv);
        }
        if (node.tag === 'formula') {
            res = this._processFormulaNode(node, fv);
        }
        if (node.tag === 'view') {
            fv.subViews.push([node.attrs.ref, node.attrs.type]);
            res = false;
        }

        return res;
    },
});

viewRegistry.add('dashboard', DashboardView);

return DashboardView;

});

//# sourceMappingURL=/web/assets/98-b4a8124/web.assets_backend_legacy_lazy.js.map