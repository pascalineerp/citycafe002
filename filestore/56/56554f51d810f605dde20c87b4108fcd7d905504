
/******************************************************************************
*  Filepath: /web_studio/static/src/client_action/app_creator/app_creator.js  *
*  Bundle: web_studio.studio_assets                                           *
*  Lines: 355                                                                 *
******************************************************************************/
odoo.define('@web_studio/client_action/app_creator/app_creator', async function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/
const { useAutofocus } = require("@web/core/utils/hooks");
const { ComponentAdapter, ComponentWrapper, WidgetAdapterMixin } = require("web.OwlCompatibility");
const Widget = require("web.Widget");
const { COLORS, BG_COLORS, ICONS } = require("@web_studio/utils");
const { FieldMany2One } = require("web.relational_fields");
const StandaloneFieldManagerMixin = require("web.StandaloneFieldManagerMixin");
const { ModelConfigurator } = require("web_studio.ModelConfigurator");
const { IconCreator } = require("@web_studio/client_action/icon_creator/icon_creator");

const { Component, hooks, useState } = owl;
const { useExternalListener } = hooks;

class ModelSelector extends ComponentAdapter {
    constructor(parent, props) {
        Object.assign(props, { Component: FieldMany2One });
        super(parent, props);
    }
    updateWidget(nextProps) {}
    renderWidget() {}
}

const AppCreatorWrapper = __exports.AppCreatorWrapper = Widget.extend(StandaloneFieldManagerMixin, WidgetAdapterMixin, {
    target: "fullscreen",
    /**
     * This widget is directly bound to its inner owl component and its sole purpose
     * is to instanciate it with the adequate properties: it will manually
     * mount the component when attached to the dom, will dismount it when detached
     * and destroy it when destroyed itself.
     * @constructor
     */
    init() {
        this._super(...arguments);
        StandaloneFieldManagerMixin.init.call(this);
        this.appCreatorComponent = new ComponentWrapper(this, AppCreator, {
            model: this.model,
        });
    },

    async start() {
        this.$el.css("height", "100%");
        this.$el.css("overflow", "auto");
        await this._super(...arguments);
        return this.appCreatorComponent.mount(this.el);
    },

    destroy() {
        WidgetAdapterMixin.destroy.call(this);
        this._super();
    },

    //--------------------------------------------------------------------------
    // Handlers
    //--------------------------------------------------------------------------

    /**
     * Overriden to register widgets on the fly since they have been instanciated
     * by the Component.
     * @override
     */
    _onFieldChanged(ev) {
        const targetWidget = ev.data.__targetWidget;
        this._registerWidget(ev.data.dataPointID, targetWidget.name, targetWidget);
        StandaloneFieldManagerMixin._onFieldChanged.apply(this, arguments);
    },
});

/**
 * App creator
 *
 * Action handling the complete creation of a new app. It requires the user
 * to enter an app name, to customize the app icon (@see IconCreator) and
 * to finally enter a menu name, with the option to bind the default app
 * model to an existing one.
 *
 * TODO: this component is bound to an action adapter since the action manager
 * cannot yet handle owl component. This file must be reviewed as soon as
 * the action manager is updated.
 * @extends Component
 */
class AppCreator extends Component {
    constructor() {
        super(...arguments);
        // TODO: Many2one component directly attached in XML. For now we have
        // to toggle it manually according to the state changes.
        this.state = useState({
            step: "welcome",
            appName: "",
            menuName: "",
            modelChoice: "new",
            modelOptions: [],
            modelId: false,
            iconData: {
                backgroundColor: BG_COLORS[5],
                color: COLORS[4],
                iconClass: ICONS[0],
                type: "custom_icon",
            },
        });
        this.debug = Boolean(AppCreator.env.isDebug());

        useAutofocus();
        this.invalid = useState({
            appName: false,
            menuName: false,
            modelId: false,
        });
        useExternalListener(window, "keydown", this._onKeydown);
    }

    async willStart() {
        const recordId = await this.props.model.makeRecord("ir.actions.act_window", [
            {
                name: "model",
                relation: "ir.model",
                type: "many2one",
                domain: [
                    ["transient", "=", false],
                    ["abstract", "=", false],
                ],
            },
        ]);
        this.record = this.props.model.get(recordId);
    }

    //--------------------------------------------------------------------------
    // Getters
    //--------------------------------------------------------------------------

    /**
     * @returns {boolean}
     */
    get isReady() {
        return (
            this.state.step === "welcome" ||
            (this.state.step === "app" && this.state.appName) ||
            (this.state.step === "model" &&
                this.state.menuName &&
                (this.state.modelChoice === "new" ||
                    (this.state.modelChoice === "existing" && this.state.modelId)))
        );
    }

    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------

    /**
     * Switch the current step and clean all invalid keys.
     * @private
     * @param {string} step
     */
    _changeStep(step) {
        this.state.step = step;
        for (const key in this.invalid) {
            this.invalid[key] = false;
        }
    }

    /**
     * @private
     * @returns {Promise}
     */
    async _createNewApp() {
        this.env.services.ui.block();
        const iconValue =
            this.state.iconData.type === "custom_icon"
                ? // custom icon data
                  [
                      this.state.iconData.iconClass,
                      this.state.iconData.color,
                      this.state.iconData.backgroundColor,
                  ]
                : // attachment
                  this.state.iconData.uploaded_attachment_id;

        try {
            const result = await this.rpc({
                route: "/web_studio/create_new_app",
                params: {
                    app_name: this.state.appName,
                    menu_name: this.state.menuName,
                    model_choice: this.state.modelChoice,
                    model_id: this.state.modelChoice && this.state.modelId,
                    model_options: this.state.modelOptions,
                    icon: iconValue,
                    context: this.env.session.user_context,
                },
            });
            this.trigger("new-app-created", result);
        } catch (error) {
            if (!error || !(error instanceof Error)) {
                this._onPrevious();
            } else {
                throw error;
            }
        } finally {
            this.env.services.ui.unblock();
        }
    }

    //--------------------------------------------------------------------------
    // Handlers
    //--------------------------------------------------------------------------

    /**
     * @private
     * @param {Event} ev
     */
    _onChecked(ev) {
        const modelChoice = ev.currentTarget.value;
        this.state.modelChoice = modelChoice;
        if (this.state.modelChoice === "new") {
            this.state.modelId = undefined;
        }
    }

    /**
     * @private
     * @param {OwlEvent} ev
     */
    _onModelIdChanged(ev) {
        if (this.state.modelChoice === "existing") {
            this.state.modelId = ev.detail.changes.model.id;
            this.invalid.modelId = isNaN(this.state.modelId);
        } else {
            this.state.modelId = false;
            this.invalid.modelId = false;
        }
    }

    /**
     * @private
     * @param {OwlEvent} ev
     */
    _onIconChanged(ev) {
        for (const key in this.state.iconData) {
            delete this.state.iconData[key];
        }
        Object.assign(this.state.iconData, ev.detail);
    }

    /**
     * @private
     * @param {InputEvent} ev
     */
    _onInput(ev) {
        const input = ev.currentTarget;
        if (this.invalid[input.id]) {
            this.invalid[input.id] = !input.value;
        }
        this.state[input.id] = input.value;
    }

    /**
     * @private
     * @param {KeyboardEvent} ev
     */
    _onKeydown(ev) {
        if (
            ev.key === "Enter" &&
            !(
                ev.target.classList &&
                ev.target.classList.contains("o_web_studio_app_creator_previous")
            )
        ) {
            ev.preventDefault();
            this._onNext();
        }
    }

    /**
     * Handle the confirmation of options in the modelconfigurator
     * @param {OwlEvent} ev
     */
    _onConfirmOptions(ev) {
        const options = ev.detail;
        this.state.modelOptions = Object.entries(options)
            .filter((opt) => opt[1].value)
            .map((opt) => opt[0]);
        return this._onNext();
    }

    /**
     * @private
     */
    async _onNext() {
        switch (this.state.step) {
            case "welcome":
                this._changeStep("app");
                break;
            case "app":
                if (!this.state.appName) {
                    this.invalid.appName = true;
                } else {
                    this._changeStep("model");
                }
                break;
            case "model":
                if (!this.state.menuName) {
                    this.invalid.menuName = true;
                }
                if (this.state.modelChoice === "existing" && !this.state.modelId) {
                    this.invalid.modelId = true;
                } else if (this.state.modelChoice === "new") {
                    this.invalid.modelId = false;
                }
                const isValid = Object.values(this.invalid).reduce(
                    (valid, key) => valid && !key,
                    true
                );
                if (isValid) {
                    if (this.state.modelChoice === "new") {
                        this._changeStep("model_configuration");
                    } else {
                        this._createNewApp();
                    }
                }
                break;
            case "model_configuration":
                // no validation for this step, every configuration is valid
                this._createNewApp();
                break;
        }
    }

    /**
     * @private
     */
    _onPrevious() {
        switch (this.state.step) {
            case "app":
                this._changeStep("welcome");
                break;
            case "model":
                this._changeStep("app");
                break;
            case "model_configuration":
                this._changeStep("model");
                break;
        }
    }
}

AppCreator.components = { ModelSelector, IconCreator, ModelConfigurator };
AppCreator.props = {
    model: Object,
};
AppCreator.template = "web_studio.AppCreator";

return __exports;
});
;

/********************************************************************
*  Filepath: /web_studio/static/src/client_action/editor/editor.js  *
*  Bundle: web_studio.studio_assets                                 *
*  Lines: 111                                                       *
********************************************************************/
odoo.define('@web_studio/client_action/editor/editor', async function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { StudioActionContainer } = require("@web_studio/client_action/studio_action_container");
const { actionService } = require("@web/webclient/actions/action_service");
const { useBus, useService } = require("@web/core/utils/hooks");
const { registry } = require("@web/core/registry");

const { EditorMenu } = require("@web_studio/client_action/editor/editor_menu/editor_menu");

const { mapDoActionOptionAPI } = require("@web/legacy/backend_utils");

const { Component, core, hooks } = owl;

const editorTabRegistry = registry.category("web_studio.editor_tabs");

const actionServiceStudio = {
    dependencies: ["studio"],
    start(env) {
        const action = actionService.start(env);
        const _doAction = action.doAction;

        async function doAction(actionRequest, options) {
            if (actionRequest === "web_studio.action_edit_report") {
                return env.services.studio.setParams({
                    editedReport: options.report,
                });
            }
            return _doAction(...arguments);
        }

        return Object.assign(action, { doAction });
    },
};

const Editor = __exports.Editor = class Editor extends Component {
    setup() {
        this.studio = useService("studio");

        hooks.useSubEnv({
            bus: new core.EventBus(),
        });
        this.env.services = Object.assign({}, this.env.services);
        this.env.services.router = {
            current: { hash: {} },
            pushState() {},
        };
        // Assuming synchronousness
        this.env.services.action = actionServiceStudio.start(this.env);
        this.actionService = useService("action");

        useBus(this.studio.bus, "UPDATE", async () => {
            const action = await this.getStudioAction();
            this.actionService.doAction(action, {
                clearBreadcrumbs: true,
            });
        });
    }

    async willStart() {
        this.initialAction = await this.getStudioAction();
    }

    switchView(ev) {
        const { viewType } = ev.detail;
        this.studio.setParams({ viewType, editorTab: "views" });
    }
    switchViewLegacy(ev) {
        this.studio.setParams({ viewType: ev.detail.view_type });
    }

    onSwitchTab(ev) {
        this.studio.setParams({ editorTab: ev.detail.tab });
    }

    async getStudioAction() {
        const { editorTab, editedAction, editedReport } = this.studio;
        const tab = editorTabRegistry.get(editorTab);
        if (tab.action) {
            return tab.action;
        } else if (editorTab === "reports" && editedReport) {
            return "web_studio.report_editor";
        } else {
            return this.rpc("/web_studio/get_studio_action", {
                action_name: editorTab,
                model: editedAction.res_model,
                view_id: editedAction.view_id && editedAction.view_id[0], // Not sure it is correct or desirable
            });
        }
    }

    onDoAction(ev) {
        // @legacy;
        const payload = ev.detail;
        const legacyOptions = mapDoActionOptionAPI(payload.options);
        this.actionService.doAction(
            payload.action,
            Object.assign(legacyOptions || {}, { clearBreadcrumbs: true })
        );
    }
}
Editor.template = "web_studio.Editor";
Editor.components = {
    EditorMenu,
    StudioActionContainer,
};

return __exports;
});
;

/****************************************************************************
*  Filepath: /web_studio/static/src/client_action/editor/editor_adapter.js  *
*  Bundle: web_studio.studio_assets                                         *
*  Lines: 254                                                               *
****************************************************************************/
odoo.define('@web_studio/client_action/editor/editor_adapter', async function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/
const { ComponentAdapter } = require("web.OwlCompatibility");
const { useService } = require("@web/core/utils/hooks");
const { registry } = require("@web/core/registry");
const { NewViewDialog } = require("@web_studio/client_action/editor/new_view_dialogs/new_view_dialog");
const { MapNewViewDialog } = require("@web_studio/client_action/editor/new_view_dialogs/map_new_view_dialog");
const { ConfirmationDialog } = require("@web/core/confirmation_dialog/confirmation_dialog");
const ActionEditor = require("web_studio.ActionEditor");
const { ActionEditorMain } = require("@web_studio/legacy/action_editor_main");
const { AlertDialog } = require("@web/core/confirmation_dialog/confirmation_dialog");

const { Component } = owl;

const EditorAdapter = __exports.EditorAdapter = class EditorAdapter extends ComponentAdapter {
    constructor(parent, props) {
        // force dummy Component not to crash
        props.Component = owl.Component;
        super(...arguments);
    }

    setup() {
        super.setup();
        this.studio = useService("studio");

        if (this.studio.editedViewType) {
            this.props.Component = ActionEditorMain;
        } else {
            this.props.Component = ActionEditor;
        }

        this.dialog = useService("dialog");
        this.user = useService("user");
        this.dialog = useService("dialog");
        this.viewService = useService("view");
        this.rpc = useService("rpc");
        this.env = Component.env; // use the legacy env
    }

    _trigger_up(ev) {
        const { name, data } = ev;
        if (name === "studio_new_view") {
            return this._onNewView(data);
        }
        if (name === "studio_disable_view") {
            return this._onDisableView(data);
        }
        if (name === "studio_default_view") {
            return this._onSetDefaultView(data);
        }
        if (name === "studio_restore_default_view") {
            return this._onRestoreDefaultView(data);
        }
        if (name === "studio_edit_action") {
            return this._onEditAction(data);
        }
        return super._trigger_up(...arguments);
    }

    async _onNewView(data) {
        const viewType = data.view_type;
        const activityAllowed = await this.rpc("/web_studio/activity_allowed", {
            model: this.studio.editedAction.res_model,
        });
        if (viewType === "activity" && !activityAllowed) {
            this.env.services.notification.notify({
                title: false,
                type: "danger",
                message: this.env._t("Activity view unavailable on this model"),
            });
            return;
        }

        const viewMode = this.studio.editedAction.view_mode + "," + viewType;
        const viewAdded = await this.addViewType(this.studio.editedAction, viewType, {
            view_mode: viewMode,
        });
        if (viewAdded) {
            return this.studio.reload({ viewType });
        }
    }

    /**
     * @private
     * @param {Object} action
     * @param {String} view_type
     * @param {Object} args
     * @returns {Promise}
     */
    async addViewType(action, viewType, args) {
        let viewAdded = await this.rpc("/web_studio/add_view_type", {
            action_type: action.type,
            action_id: action.id,
            res_model: action.res_model,
            view_type: viewType,
            args: args,
            context: this.user.context,
        });

        if (viewAdded !== true) {
            viewAdded = new Promise((resolve) => {
                let DialogClass;
                let dialogProps = {
                    confirm: async () => {
                        await this.editAction(action, args);
                        resolve(true);
                    },
                    cancel: () => resolve(false),
                };
                if (["gantt", "calendar", "cohort"].includes(viewType)) {
                    DialogClass = NewViewDialog;
                    dialogProps.viewType = viewType;
                } else if (viewType === "map") {
                    DialogClass = MapNewViewDialog;
                } else {
                    this.dialog.add(AlertDialog, {
                        body: this.env._lt(
                            "Creating this type of view is not currently supported in Studio."
                        ),
                    });
                    resolve(false);
                }
                this.dialog.add(DialogClass, dialogProps);
            });
        }
        return viewAdded;
    }

    /**
     * @private
     * @param {OdooEvent} event
     */
    async _onEditAction(data) {
        const args = data.args;
        if (!args) {
            return;
        }
        await this.editAction(this.studio.editedAction, args);
        this.studio.reload();
    }

    /**
     * @private
     * @param {Object} action
     * @param {Object} args
     * @returns {Promise}
     */
    async editAction(action, args) {
        this.env.bus.trigger("clear_cache");
        const result = await this.rpc("/web_studio/edit_action", {
            action_type: action.type,
            action_id: action.id,
            args: args,
            context: this.user.context,
        });
        if (result !== true) {
            this.dialog.add(AlertDialog, {
                body: result,
            });
        }
    }

    /**
     * @private
     * @param {String} view_mode
     * @returns {Promise}
     */
    async _writeViewMode(viewMode) {
        await this.editAction(this.studio.editedAction, { view_mode: viewMode });
        this.studio.reload({ viewType: null });
    }

    _onDisableView(data) {
        const viewType = data.view_type;
        const viewMode = this.studio.editedAction.view_mode
            .split(",")
            .filter((m) => m !== viewType);

        if (!viewMode.length) {
            this.dialog.add(AlertDialog, {
                body: this.env._t("You cannot deactivate this view as it is the last one active."),
            });
        } else {
            this._writeViewMode(viewMode.toString());
        }
    }

    _onSetDefaultView(data) {
        const viewType = data.view_type;
        const actionViewModes = this.studio.editedAction.view_mode.split(",");

        const viewMode = actionViewModes.filter((vt) => vt !== viewType);
        viewMode.unshift(viewType);

        return this._writeViewMode(viewMode.toString());
    }

    _onRestoreDefaultView(data) {
        const message = this.env._t(
            "Are you sure you want to restore the default view?\r\nAll customization done with studio on this view will be lost."
        );
        const { context, views, res_model } = this.studio.editedAction;
        const viewType = data.view_type;

        const confirm = async () => {
            const newContext = Object.assign({}, context, {
                studio: true,
                lang: false,
            });
            this.env.bus.trigger("clear_cache");
            // To restore the default view from an inherited one, we need first to retrieve the default view id
            const fieldsView = await this.viewService.loadViews(
                {
                    resModel: res_model,
                    views,
                    context: newContext,
                },
                { loadIrFilters: true }
            );

            return this.rpc("/web_studio/restore_default_view", {
                view_id: fieldsView[viewType].viewId,
            });
        };

        this.dialog.add(ConfirmationDialog, {
            body: message,
            confirm,
        });
    }

    get widgetArgs() {
        const { editedAction, editedViewType, editedControllerState, x2mEditorPath } = this.studio;
        if (this.props.Component === ActionEditor) {
            return [editedAction];
        } else {
            return [
                {
                    action: editedAction,
                    viewType: editedViewType,
                    controllerState: editedControllerState,
                    x2mEditorPath: x2mEditorPath,
                },
            ];
        }
    }
}

registry.category("actions").add("web_studio.action_editor", EditorAdapter);

return __exports;
});
;

/*************************************************************************************
*  Filepath: /web_studio/static/src/client_action/editor/editor_menu/editor_menu.js  *
*  Bundle: web_studio.studio_assets                                                  *
*  Lines: 204                                                                        *
*************************************************************************************/
odoo.define('@web_studio/client_action/editor/editor_menu/editor_menu', async function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

const { useBus, useService } = require("@web/core/utils/hooks");
const { _lt } = require("@web/core/l10n/translation");
const { sprintf } = require("@web/core/utils/strings");
const { localization } = require("@web/core/l10n/localization");
const { registry } = require("@web/core/registry");

const editorTabRegistry = registry.category("web_studio.editor_tabs");

const EditorMenu = __exports.EditorMenu = class EditorMenu extends owl.Component {
    setup() {
        this.l10n = localization;
        this.studio = useService("studio");
        this.rpc = useService("rpc");

        useBus(this.studio.bus, "UPDATE", async () => {
            await this.render();
            toggleSnackBar("off");
        });

        const toggleUndo = (display) => {
            const el = this.el.querySelector(".o_web_studio_undo");
            if (el) {
                el.classList.toggle("o_web_studio_active", display);
            }
        };
        const toggleRedo = (display) => {
            const el = this.el.querySelector(".o_web_studio_redo");
            if (el) {
                el.classList.toggle("o_web_studio_active", display);
            }
        };

        useBus(this.studio.bus, "undo_available", () => toggleUndo(true));
        useBus(this.studio.bus, "undo_not_available", () => toggleUndo(false));
        useBus(this.studio.bus, "redo_available", () => toggleRedo(true));
        useBus(this.studio.bus, "redo_not_available", () => toggleRedo(false));

        const toggleSnackBar = (type) => {
            const snackBarIcon = this.el.querySelector(".o_web_studio_snackbar_icon");
            const snackBarText = this.el.querySelector(".o_web_studio_snackbar_text");
            switch (type) {
                case "saved":
                    snackBarIcon.classList.remove("fa-circle-o-notch", "fa-spin");
                    snackBarIcon.classList.add("show", "fa", "fa-check");
                    snackBarText.textContent = this.env._t("Saved");
                    break;
                case "saving":
                    snackBarIcon.classList.add("show", "fa", "fa-circle-o-notch", "fa-spin");
                    snackBarText.textContent = this.env._t("Saving");
                    break;
                case "off":
                    snackBarIcon.classList.remove(
                        "fa-circle-o-notch",
                        "fa-spin",
                        "show",
                        "fa-check"
                    );
                    snackBarText.textContent = "";
                    break;
            }
        };

        useBus(this.studio.bus, "toggle_snack_bar", toggleSnackBar);
    }

    get breadcrumbs() {
        const { editorTab } = this.studio;
        const currentTab = this.editorTabs.find((tab) => tab.id === editorTab);
        const crumbs = [
            {
                name: currentTab.name,
                handler: () => this.openTab(currentTab.id),
            },
        ];
        if (currentTab.id === "views") {
            const { editedViewType, x2mEditorPath } = this.studio;
            if (editedViewType) {
                const currentViewType = this.constructor.viewTypes.find(
                    (vt) => vt.type === editedViewType
                );
                crumbs.push({
                    name: currentViewType.title,
                    handler: () =>
                        this.studio.setParams({
                            x2mEditorPath: [],
                        }),
                });
            }
            x2mEditorPath.forEach(({ x2mViewType }, index) => {
                const viewType = this.constructor.viewTypes.find((vt) => vt.type === x2mViewType);
                crumbs.push({
                    name: sprintf(
                        this.env._t("Subview %s"),
                        (viewType && viewType.title) || this.env._t("Other")
                    ),
                    handler: () =>
                        this.studio.setParams({
                            x2mEditorPath: x2mEditorPath.slice(0, index + 1),
                        }),
                });
            });
        } else if (currentTab.id === "reports" && this.studio.editedReport) {
            crumbs.push({
                name: this.studio.editedReport.data.name,
                handler: () => this.studio.setParams({}),
            });
        }
        return crumbs;
    }

    get activeViews() {
        const action = this.studio.editedAction;
        const viewTypes = (action._views || action.views).map(([id, type]) => type);
        return this.constructor.viewTypes.filter((vt) => viewTypes.includes(vt.type));
    }

    get editorTabs() {
        const entries = editorTabRegistry.getEntries();
        return entries.map((entry) => Object.assign({}, entry[1], { id: entry[0] }));
    }

    openTab(tab) {
        this.trigger("switch-tab", { tab });
    }
}
EditorMenu.template = "web_studio.EditorMenu";
EditorMenu.viewTypes = [
    {
        title: _lt("Form"),
        type: "form",
        faclass: "fa-address-card",
    },
    {
        title: _lt("List"),
        type: "list",
        faclass: "fa-list-ul",
    },
    {
        title: _lt("Kanban"),
        type: "kanban",
        faclass: "fa-th-large",
    },
    {
        title: _lt("Map"),
        type: "map",
        faclass: "fa-map-marker",
    },
    {
        title: _lt("Calendar"),
        type: "calendar",
        faclass: "fa-calendar-o",
    },
    {
        title: _lt("Graph"),
        type: "graph",
        faclass: "fa-bar-chart",
    },
    {
        title: _lt("Pivot"),
        type: "pivot",
        faclass: "fa-table",
    },
    {
        title: _lt("Gantt"),
        type: "gantt",
        faclass: "fa-tasks",
    },
    {
        title: _lt("Dashboard"),
        type: "dashboard",
        faclass: "fa-tachometer",
    },
    {
        title: _lt("Cohort"),
        type: "cohort",
        faclass: "fa-signal",
    },
    {
        title: _lt("Activity"),
        type: "activity",
        faclass: "fa-th",
    },
    {
        title: _lt("Search"),
        type: "search",
        faclass: "fa-search",
    },
];

editorTabRegistry
    .add("views", { name: _lt("Views"), action: "web_studio.action_editor" })
    .add("reports", { name: _lt("Reports") })
    .add("translations", { name: _lt("Translations") })
    .add("automations", { name: _lt("Automations") })
    .add("acl", { name: _lt("Access Control") })
    .add("filters", { name: _lt("Filter Rules") });

return __exports;
});
;

/**************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/editor/new_view_dialogs/map_new_view_dialog.js  *
*  Bundle: web_studio.studio_assets                                                               *
*  Lines: 38                                                                                      *
**************************************************************************************************/
odoo.define('@web_studio/client_action/editor/new_view_dialogs/map_new_view_dialog', async function (require) {
'use strict';
let __exports = {};
/** @odoo-module */
const { NewViewDialog } = require("@web_studio/client_action/editor/new_view_dialogs/new_view_dialog");
const { useService } = require("@web/core/utils/hooks");
const { AlertDialog } = require("@web/core/confirmation_dialog/confirmation_dialog");

const MapNewViewDialog = __exports.MapNewViewDialog = class MapNewViewDialog extends NewViewDialog {
    setup() {
        super.setup();
        this.dialog = useService("dialog");
        this.bodyTemplate = "web_studio.MapNewViewFieldsSelector";
    }

    get viewType() {
        return "map";
    }

    computeSpecificFields(fields) {
        this.partnerFields = fields.filter(
            (field) => field.type === "many2one" && field.relation === "res.partner"
        );
        if (!this.partnerFields.length) {
            this.dialog.add(AlertDialog, {
                body: this.env._t("Contact Field Required"),
                contentClass: "o_web_studio_preserve_space",
            });
            this.close();
        }
    }
}
MapNewViewDialog.props = Object.assign(Object.create(NewViewDialog.props), {
    viewType: { type: String, optional: true },
});

return __exports;
});
;

/**********************************************************************************************
*  Filepath: /web_studio/static/src/client_action/editor/new_view_dialogs/new_view_dialog.js  *
*  Bundle: web_studio.studio_assets                                                           *
*  Lines: 106                                                                                 *
**********************************************************************************************/
odoo.define('@web_studio/client_action/editor/new_view_dialogs/new_view_dialog', async function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

const { useService } = require("@web/core/utils/hooks");
const { sprintf } = require("@web/core/utils/strings");
const { ConfirmationDialog } = require("@web/core/confirmation_dialog/confirmation_dialog");

const NewViewDialog = __exports.NewViewDialog = class NewViewDialog extends ConfirmationDialog {
    setup() {
        super.setup();
        this.orm = useService("orm");
        this.rpc = useService("rpc");
        this.studio = useService("studio");
        this.user = useService("user");
        this.mandatoryStopDate = ["gantt", "cohort"].includes(this.viewType);

        this.title = sprintf(this.env._t("Generate %s View"), this.viewType);

        this.fieldsChoice = {
            date_start: null,
            date_stop: null,
        };
    }

    get viewType() {
        return this.props.viewType;
    }

    async willStart() {
        const fieldsGet = await this.orm.call(this.studio.editedAction.res_model, "fields_get");
        const fields = Object.entries(fieldsGet).map(([fName, field]) => {
            field.name = fName;
            return field;
        });
        fields.sort((first, second) => {
            if (first.string === second.string) {
                return 0;
            }
            if (first.string < second.string) {
                return -1;
            }
            if (first.string > second.string) {
                return 1;
            }
        });
        this.computeSpecificFields(fields);
        return super.willStart();
    }

    /**
     * Compute date, row and measure fields.
     */
    computeSpecificFields(fields) {
        this.dateFields = [];
        this.rowFields = [];
        this.measureFields = [];
        fields.forEach((field) => {
            if (field.store) {
                // date fields
                if (field.type === "date" || field.type === "datetime") {
                    this.dateFields.push(field);
                }
                // row fields
                if (this.constructor.GROUPABLE_TYPES.includes(field.type)) {
                    this.rowFields.push(field);
                }
                // measure fields
                if (this.constructor.MEASURABLE_TYPES.includes(field.type)) {
                    // id and sequence are not measurable
                    if (field.name !== "id" && field.name !== "sequence") {
                        this.measureFields.push(field);
                    }
                }
            }
        });
        if (this.dateFields.length) {
            this.fieldsChoice.date_start = this.dateFields[0].name;
            this.fieldsChoice.date_stop = this.dateFields[0].name;
        }
    }

    async _confirm() {
        await this.rpc("/web_studio/create_default_view", {
            model: this.studio.editedAction.res_model,
            view_type: this.viewType,
            attrs: this.fieldsChoice,
            context: this.user.context,
        });
        super._confirm();
    }
}
NewViewDialog.bodyTemplate = "web_studio.NewViewFieldsSelector";
NewViewDialog.footerTemplate = "web_studio.OwlNewViewDialogFooter";
NewViewDialog.GROUPABLE_TYPES = ["many2one", "char", "boolean", "selection", "date", "datetime"];
NewViewDialog.MEASURABLE_TYPES = ["integer", "float"];
NewViewDialog.size = "modal-md";
NewViewDialog.props = Object.assign(Object.create(ConfirmationDialog.props), {
    viewType: String,
    title: { type: String, optional: true },
    body: { type: String, optional: true },
});

return __exports;
});
;

/***********************************************************************************
*  Filepath: /web_studio/static/src/client_action/editor/report_editor_adapter.js  *
*  Bundle: web_studio.studio_assets                                                *
*  Lines: 203                                                                      *
***********************************************************************************/
odoo.define('@web_studio/client_action/editor/report_editor_adapter', async function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/
const { ComponentAdapter } = require("web.OwlCompatibility");
const ReportEditorManager = require("web_studio.ReportEditorManager");
const { useService } = require("@web/core/utils/hooks");
const { registry } = require("@web/core/registry");

class ReportEditorAdapter extends ComponentAdapter {
    constructor(parent, props) {
        props.Component = ReportEditorManager;
        super(...arguments);
        this.actionService = useService("action");
        this.user = useService("user");
        this.rpc = useService("rpc");
        this.orm = useService("orm");
        this.studio = useService("studio");
        this.reportEnv = {};
        this.env = owl.Component.env;
    }

    get handle() {
        return this.studio.editedReport;
    }

    async willStart() {
        const proms = [];
        await this._readReport();
        await this._loadEnvironment();
        proms.push(this._readModels());
        proms.push(this._readWidgetsOptions());
        proms.push(this._getReportViews());
        proms.push(this._readPaperFormat());
        await Promise.all(proms);
        return super.willStart();
    }

    get widgetArgs() {
        return [
            {
                env: this.reportEnv,
                //initialState: state,
                models: this.models,
                paperFormat: this.paperFormat,
                report: this.report,
                reportHTML: this.reportViews.report_html,
                reportMainViewID: this.reportViews.main_view_id,
                reportViews: this.reportViews.views,
                widgetsOptions: this.widgetsOptions,
            },
        ];
    }

    /**
     * Load and set the report environment.
     *
     * If the report is associated to the same model as the Studio action, the
     * action ids will be used ; otherwise a search on the report model will be
     * performed.
     *
     * @private
     * @returns {Promise}
     */
    async _loadEnvironment() {
        this.reportEnv.modelName = this.report.model;

        // TODO: Since 13.0, journal entries are also considered as 'account.move',
        // therefore must filter result to remove them; otherwise not possible
        // to print invoices and hard to lookup for them if lot of journal entries.
        let domain = [];
        if (this.report.model === "account.move") {
            domain = [["move_type", "!=", "entry"]];
        }

        const result = await this.orm.search(
            this.report.model,
            domain,
            undefined,
            this.user.context
        );
        this.reportEnv.ids = result;
        this.reportEnv.currentId = this.reportEnv.ids && this.reportEnv.ids[0];
    }
    /**
     * Read the models (ir.model) name and model to display them in a
     * user-friendly way in the sidebar (see AbstractReportComponent).
     *
     * @private
     * @returns {Promise}
     */
    async _readModels() {
        const models = await this.orm.searchRead(
            "ir.model",
            [
                ["transient", "=", false],
                ["abstract", "=", false],
            ],
            ["name", "model"],
            undefined,
            this.user.context
        );
        this.models = {};
        models.forEach((model) => {
            this.models[model.model] = model.name;
        });
    }
    /**
     * @private
     * @returns {Promise}
     */
    async _readReport() {
        const result = await this.orm.read(
            "ir.actions.report",
            [this.handle.res_id],
            undefined,
            this.user.context
        );
        this.report = result[0];
    }
    /**
     * @private
     * @returns {Promise}
     */
    async _readPaperFormat() {
        this.paperFormat = "A4";
        const result = await this.rpc("/web_studio/read_paperformat", {
            report_id: this.handle.res_id,
            context: this.user.context,
        });
        this.paperFormat = result[0];
    }
    /**
     * Load the widgets options for t-options directive in sidebar.
     *
     * @private
     * @returns {Promise}
     */
    async _readWidgetsOptions() {
        this.widgetsOptions = await this.rpc("/web_studio/get_widgets_available_options", {
            context: this.user.context,
        });
    }
    /**
     * @private
     * @returns {Promise<Object>}
     */
    async _getReportViews() {
        // SAD: FIXME calling this when there are no record for the model crashes (no currentId)
        // used to show a danger notification
        this.reportViews = await this.rpc("/web_studio/get_report_views", {
            record_id: this.reportEnv.currentId,
            report_name: this.report.report_name,
        });
    }

    _trigger_up(ev) {
        switch (ev.name) {
            case "studio_edit_report":
                this._editReport(ev.data);
                break;
            case "open_record_form_view":
                this.actionService.doAction(
                    {
                        type: "ir.actions.act_window",
                        res_model: "ir.actions.report",
                        res_id: this.handle.res_id,
                        views: [[false, "form"]],
                        target: "current",
                    },
                    { clearBreadcrumbs: true }
                );
                break;
        }
        super._trigger_up(...arguments);
    }

    /**
     * @private
     * @param {Object} values
     * @returns {Promise}
     */
    async _editReport(values) {
        const result = await this.rpc("/web_studio/edit_report", {
            report_id: this.report.id,
            values: values,
            context: this.user.context,
        });
        this.report = result[0];
        this.render();
    }
}

// We need this to wrap in a div
// ViewEditor doesn't need this because it extends AbstractEditor, and defines a template
const ReportEditor = __exports.ReportEditor = class ReportEditor extends owl.Component {}
ReportEditor.template = owl.tags
    .xml`<div class="o_web_studio_client_action"><ReportEditorAdapter /></div>`;
ReportEditor.components = { ReportEditorAdapter };
registry.category("actions").add("web_studio.report_editor", ReportEditor);

return __exports;
});
;

/********************************************************************************
*  Filepath: /web_studio/static/src/client_action/icon_creator/icon_creator.js  *
*  Bundle: web_studio.studio_assets                                             *
*  Lines: 186                                                                   *
********************************************************************************/
odoo.define('@web_studio/client_action/icon_creator/icon_creator', async function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/
const { COLORS, BG_COLORS, ICONS } = require("@web_studio/utils");
const { FileInput } = require("@web/core/file_input/file_input");
const CustomFileInput = require("web.CustomFileInput");
const { useService } = require("@web/core/utils/hooks");

const { Component, hooks } = owl;
const { useRef, useState, onWillUpdateProps } = hooks;

const DEFAULT_ICON = {
    backgroundColor: BG_COLORS[5],
    color: COLORS[4],
    iconClass: ICONS[0],
};

/**
 * Icon creator
 *
 * Component which purpose is to design an app icon. It can be an uploaded image
 * which will be displayed as is, or an icon customized with the help of presets
 * of colors and icon symbols (@see web_studio.utils for the full list of colors
 * and icon classes).
 * @extends Component
 */
const IconCreator = __exports.IconCreator = class IconCreator extends Component {
    /**
     * @param {Object} [props]
     * @param {string} [props.backgroundColor] Background color of the custom
     *      icon.
     * @param {string} [props.color] Color of the custom icon.
     * @param {boolean} props.editable
     * @param {string} [props.iconClass] Font Awesome class of the custom icon.
     * @param {string} props.type 'base64' (if an actual image) or 'custom_icon'.
     * @param {number} [props.uploaded_attachment_id] Databse ID of an uploaded
     *      attachment
     * @param {string} [props.webIconData] Base64-encoded string representing
     *      the icon image.
     */
    setup() {
        this.COLORS = COLORS;
        this.BG_COLORS = BG_COLORS;
        this.ICONS = ICONS;

        this.iconRef = useRef("app-icon");

        // FIXME: for now, the IconCreator can be spawned in a pure wowl environment (by clicking
        // on the 'edit' icon of an existing app) and in the legacy environment (through the app
        // creator)
        this.FileInput = FileInput;
        try {
            const user = useService("user");
            this.orm = useService("orm");
            this.userId = user.userId;
        } catch (e) {
            if (e.message === "Service user is not available") {
                this.userId = this.env.session.uid;
                // we are in a legacy environment, so use the legacy CustomFileInput as
                // the new one requires the new http service
                this.FileInput = CustomFileInput;
            }
        }

        this.show = useState({
            backgroundColor: false,
            color: false,
            iconClass: false,
        });

        if (this.env.qweb.constructor.enableTransitions) {
            onWillUpdateProps(async (nextProps) => {
                if ("iconClass" in nextProps && nextProps.iconClass !== this.props.iconClass) {
                    await new Promise((r) => $(this.iconRef.el).stop().fadeOut(50, r));
                    this.transition = () => $(this.iconRef.el).stop().fadeIn(800);
                }
            });
        }
    }

    patched() {
        if (this.transition) {
            this.transition();
            delete this.transition;
        }
    }

    //--------------------------------------------------------------------------
    // Handlers
    //--------------------------------------------------------------------------

    /**
     * @private
     */
    _onDesignIconClick() {
        this.trigger(
            "icon-changed",
            Object.assign(
                {
                    type: "custom_icon",
                },
                DEFAULT_ICON
            )
        );
    }

    /**
     * @private
     * @param {OwlEvent} ev
     */
    async _onFileUploaded(ev) {
        if (!ev.detail.files.length) {
            // Happens when cancelling upload
            return;
        }
        const file = ev.detail.files[0];
        let res;
        if (this.orm) {
            res = await this.orm.read("ir.attachment", [file.id], ["datas"]);
        } else {
            res = await this.rpc({
                model: "ir.attachment",
                method: "read",
                args: [[file.id], ["datas"]],
            });
        }

        this.trigger("icon-changed", {
            type: "base64",
            uploaded_attachment_id: file.id,
            webIconData: "data:image/png;base64," + res[0].datas.replace(/\s/g, ""),
        });
    }

    /**
     * @private
     * @param {string} palette
     * @param {string} value
     */
    _onPaletteItemClick(palette, value) {
        if (this.props[palette] === value) {
            return; // same value
        }

        const detail = {
            backgroundColor: this.props.backgroundColor,
            color: this.props.color,
            iconClass: this.props.iconClass,
            type: "custom_icon",
        };
        detail[palette] = value;

        this.trigger("icon-changed", detail);
    }

    /**
     * @private
     * @param {string} palette
     */
    _onTogglePalette(palette) {
        for (const pal in this.show) {
            if (pal === palette) {
                this.show[pal] = !this.show[pal];
            } else if (this.show[pal]) {
                this.show[pal] = false;
            }
        }
    }
}

// IconCreator.components = { FileInput };
IconCreator.defaultProps = DEFAULT_ICON;
IconCreator.props = {
    backgroundColor: { type: String, optional: 1 },
    color: { type: String, optional: 1 },
    editable: Boolean,
    iconClass: { type: String, optional: 1 },
    type: { validate: (t) => ["base64", "custom_icon"].includes(t) },
    uploaded_attachment_id: { type: Number, optional: 1 },
    webIconData: { type: String, optional: 1 },
};
IconCreator.template = "web_studio.IconCreator";

return __exports;
});
;

/********************************************************************************************
*  Filepath: /web_studio/static/src/client_action/model_configurator/model_configurator.js  *
*  Bundle: web_studio.studio_assets                                                         *
*  Lines: 242                                                                               *
********************************************************************************************/
odoo.define("web_studio.ModelConfigurator", function (require) {
    "use strict";

    const config = require("web.config");
    const Dialog = require("web.Dialog");
    const { WidgetAdapterMixin, ComponentWrapper } = require("web.OwlCompatibility");

    const { Component, hooks } = owl;
    const { useState } = hooks;

    class ModelConfigurator extends Component {
        constructor(parent, props) {
            super(parent, props);
            this.state = useState({
                /** You might wonder why I defined all these strings here and not in the template.
                 * The reason is that I wanted clear templates that use a single element to render an option,
                 * meaning that the label and helper text had to be defined here in the code.
                 */
                options: {
                    use_partner: {
                        label: this.env._t("Contact details"),
                        help: this.env._t("Get contact, phone and email fields on records"),
                        value: false,
                    },
                    use_responsible: {
                        label: this.env._t("User assignment"),
                        help: this.env._t("Assign a responsible to each record"),
                        value: false,
                    },
                    use_date: {
                        label: this.env._t("Date & Calendar"),
                        help: this.env._t("Assign dates and visualize records in a calendar"),
                        value: false,
                    },
                    use_double_dates: {
                        label: this.env._t("Date range & Gantt"),
                        help: this.env._t(
                            "Define start/end dates and visualize records in a Gantt chart"
                        ),
                        value: false,
                    },
                    use_stages: {
                        label: this.env._t("Pipeline stages"),
                        help: this.env._t("Stage and visualize records in a custom pipeline"),
                        value: false,
                    },
                    use_tags: {
                        label: this.env._t("Tags"),
                        help: this.env._t("Categorize records with custom tags"),
                        value: false,
                    },
                    use_image: {
                        label: this.env._t("Picture"),
                        help: this.env._t("Attach a picture to a record"),
                        value: false,
                    },
                    lines: {
                        label: this.env._t('Lines'),
                        help: this.env._t('Add details to your records with an embedded list view'),
                        value: false
                    },
                    use_notes: {
                        label: this.env._t("Notes"),
                        help: this.env._t("Write additional notes or comments"),
                        value: false,
                    },
                    use_value: {
                        label: this.env._t("Monetary value"),
                        help: this.env._t("Set a price or cost on records"),
                        value: false,
                    },
                    use_company: {
                        label: this.env._t("Company"),
                        help: this.env._t("Restrict a record to a specific company"),
                        value: false,
                    },
                    use_sequence: {
                        label: this.env._t("Custom Sorting"),
                        help: this.env._t("Manually sort records in the list view"),
                        value: true,
                    },
                    use_mail: {
                        label: this.env._t("Chatter"),
                        help: this.env._t("Send messages, log notes and schedule activities"),
                        value: true,
                    },
                    use_active: {
                        label: this.env._t("Archiving"),
                        help: this.env._t("Archive deprecated records"),
                        value: true,
                    },
                },
                saving: false,
            });
            this.multiCompany = this.env.session.display_switch_company_menu;
        }

        /**
         * Handle the confirmation of the dialog, just fires an event
         * to whomever instaciated it.
         *
         * @private
         */
        _onConfirm() {
            this.trigger("confirm-options", Object.assign({}, this.state.options));
            this.state.saving = true;
        }

        /**
         * Handle the 'back button'' of the dialog, just fires an event
         * to whomever instaciated it.
         *
         * @private
         */
        _onPrevious() {
            this.trigger("previous");
        }
    }

    class ModelConfiguratorOption extends Component {}

    ModelConfigurator.template = "web_studio.ModelConfigurator";
    ModelConfigurator.components = { ModelConfiguratorOption };
    ModelConfigurator.props = {
        debug: { type: Boolean, optional: true },
        embed: { type: Boolean, optional: true },
        label: { type: String },
    };

    ModelConfiguratorOption.template = "web_studio.ModelConfiguratorOption";
    ModelConfiguratorOption.props = {
        name: String,
        option: {
            type: Object,
            shape: {
                label: String,
                debug: {
                    type: Boolean,
                    optional: true,
                },
                help: String,
                value: Boolean,
            },
        },
    };

    const _t = require("web.core")._t;
    /**
     * Wrapper to make the ModelConfigurator usable as a standalone dialog. Used notably
     * by the 'NewMenuDialog' in Studio. Note that since the ModelConfigurator does not
     * have its own modal, I choose to use the classic Dialog and use it as an adapter
     * instead of using an owlDialog + another adapter on top of it. Don't @ me.
     *
     * I've taken a few liberties with the standard Dialog: removed the footer
     * (there's no need for it, the modelconfigurator has its own footer), it's a single
     * size, etc. Nothing crazy.
     */
    const ModelConfiguratorDialog = Dialog.extend(WidgetAdapterMixin, {
        custom_events: Object.assign({}, Dialog.prototype.custom_events, {
            previous: "_onPrevious",
        }),

        /**
         * @override
         */
        init(parent, options) {
            const res = this._super.apply(this, arguments);
            this.renderFooter = false;
            (this.title = _t("Suggested features for your new model")),
                (this.confirmLabel = options.confirmLabel);
            this.onForceClose = () => this.trigger_up("cancel_options");
            return res;
        },

        /**
         * Owl Wrapper override, as described in web.OwlCompatibility
         * @override
         */
        async start() {
            const res = await this._super.apply(this, arguments);
            this.component = new ComponentWrapper(this, ModelConfigurator, {
                label: this.confirmLabel,
                embed: true,
                debug: Boolean(config.isDebug()),
            });
            this.component.mount(this.el);
            return res;
        },

        /**
         * Proper handler calling since Dialog doesn't seem to do it
         * @override
         */
        close() {
            this.on_detach_callback();
            return this._super.apply(this, arguments);
        },

        /**
         * Needed because of the WidgetAdapterMixin
         * @override
         */
        destroy() {
            WidgetAdapterMixin.destroy.call(this);
            return this._super();
        },

        //--------------------------------------------------------------------------
        // Handlers
        //--------------------------------------------------------------------------

        /**
         * @override
         */
        on_attach_callback() {
            WidgetAdapterMixin.on_attach_callback.call(this);
            return this._super.apply(this, arguments);
        },

        /**
         * @override
         */
        on_detach_callback() {
            WidgetAdapterMixin.on_detach_callback.call(this);
            return this._super.apply(this, arguments);
        },

        /**
         * Handle the 'previous' button, which in this case should close the Dialog.
         * @private
         */
        _onPrevious(ev) {
            this.trigger_up("cancel_options");
            this.close();
        },
    });

    return {
        ModelConfigurator: ModelConfigurator,
        ModelConfiguratorDialog: ModelConfiguratorDialog,
    };
});
;

/*******************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/navbar/home_menu_customizer/home_menu_customizer.js  *
*  Bundle: web_studio.studio_assets                                                                    *
*  Lines: 101                                                                                          *
*******************************************************************************************************/
odoo.define('@web_studio/client_action/navbar/home_menu_customizer/home_menu_customizer', async function (require) {
'use strict';
let __exports = {};
/** @odoo-module */
const { useService } = require("@web/core/utils/hooks");
const { browser } = require("@web/core/browser/browser");
const { download } = require("@web/core/network/download");
const { ConfirmationDialog } = require("@web/core/confirmation_dialog/confirmation_dialog");
const { FileInput } = require("@web/core/file_input/file_input");

const HomeMenuCustomizer = __exports.HomeMenuCustomizer = class HomeMenuCustomizer extends owl.Component {
    setup() {
        this.rpc = useService("rpc");
        this.ui = useService("ui");
        this.notification = useService("notification");
        this.company = useService("company");
        this.user = useService("user");
        this.actionManager = useService("action");
        this.menus = useService("menu");
        this.dialogManager = useService("dialog");
        this.bgImageUploaded = this.bgImageUploaded.bind(this); // is executed as a callback
    }

    async bgImageUploaded(ev) {
        const file = ev.detail.files[0];

        if (!file) {
            this.notification.add(this.env._t("Could not change the background"), {
                sticky: true,
                type: "warning",
            });
        } else {
            this.ui.block();
            try {
                await this._setBackgroundImage(file.id);
                browser.location.reload();
            } finally {
                this.ui.unblock();
            }
        }
    }

    _setBackgroundImage(attachment_id) {
        return this.rpc("/web_studio/set_background_image", {
            attachment_id: attachment_id,
            context: this.user.context,
        });
    }
    /**
     * Export all customizations done by Studio in a zip file containing Odoo
     * modules.
     */
    _export() {
        download({ url: "/web_studio/export", data: {} });
    }
    /**
     * Open a dialog allowing to import new modules
     * (e.g. exported customizations).
     */
    _import() {
        const action = {
            name: "Import modules",
            res_model: "base.import.module",
            views: [[false, "form"]],
            type: "ir.actions.act_window",
            target: "new",
            context: {
                dialog_size: "medium",
            },
        };
        const options = {
            onClose: () => this.menus.reload(),
        };
        this.actionManager.doAction(action, options);
    }

    async _resetBgConfirmed() {
        this.ui.block();
        try {
            await this.rpc("/web_studio/reset_background_image", {
                context: this.user.context,
            });
            browser.location.reload();
        } finally {
            this.ui.unblock();
        }
    }

    _resetBgImage() {
        this.dialogManager.add(ConfirmationDialog, {
            body: this.env._t("Are you sure you want to reset the background image?"),
            title: this.env._t("Confirmation"),
            confirm: () => this._resetBgConfirmed(),
        });
    }
}
HomeMenuCustomizer.template = "web_studio.HomeMenuCustomizer";
HomeMenuCustomizer.components = { FileInput };

return __exports;
});
;

/********************************************************************
*  Filepath: /web_studio/static/src/client_action/navbar/navbar.js  *
*  Bundle: web_studio.studio_assets                                 *
*  Lines: 72                                                        *
********************************************************************/
odoo.define('@web_studio/client_action/navbar/navbar', async function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { useService } = require("@web/core/utils/hooks");
const { EnterpriseNavBar } = require("@web_enterprise/webclient/navbar/navbar");
const { NotEditableActionError } = require("@web_studio/studio_service");
const { HomeMenuCustomizer } = require("@web_studio/client_action/navbar/home_menu_customizer/home_menu_customizer");
const { EditMenuItem } = require("@web_studio/legacy/edit_menu_adapter");
const { NewModelItem } = require("@web_studio/legacy/new_model_adapter");

const StudioNavbar = __exports.StudioNavbar = class StudioNavbar extends EnterpriseNavBar {
    setup() {
        super.setup();
        this.studio = useService("studio");
        this.actionManager = useService("action");
        this.user = useService("user");
        this.dialogManager = useService("dialog");
        this.notification = useService("notification");
        owl.hooks.onMounted(() => {
            this.env.bus.off("HOME-MENU:TOGGLED", this);
            this._updateMenuAppsIcon();
        });
    }
    onMenuToggle() {
        this.studio.toggleHomeMenu();
    }
    closeStudio() {
        this.studio.leave();
    }
    async onNavBarDropdownItemSelection(ev) {
        if (ev.detail.payload.actionID) {
            try {
                await this.studio.open(this.studio.MODES.EDITOR, ev.detail.payload.actionID);
            } catch (e) {
                if (e instanceof NotEditableActionError) {
                    const options = { type: "danger" };
                    this.notification.add(
                        this.env._t("This action is not editable by Studio"),
                        options
                    );
                    return;
                }
                throw e;
            }
        }
    }
    get hasBackgroundAction() {
        return this.studio.editedAction || this.studio.MODES.APP_CREATOR === this.studio.mode;
    }
    get isInApp() {
        return this.studio.mode === this.studio.MODES.EDITOR;
    }
    _onNotesClicked() {
        // LPE fixme: dbuuid should be injected into session_info python side
        const action = {
            type: "ir.actions.act_url",
            url: `http://pad.odoo.com/p/customization-${this.user.db.uuid}`,
        };
        // LPE Fixme: this could be either the local AM or the GlobalAM
        // we don(t care i-here as we open an url anyway)
        this.actionManager.doAction(action);
    }
}
StudioNavbar.template = "web_studio.StudioNavbar";
StudioNavbar.components.HomeMenuCustomizer = HomeMenuCustomizer;
StudioNavbar.components.EditMenuItem = EditMenuItem;
StudioNavbar.components.NewModelItem = NewModelItem;

return __exports;
});
;

/******************************************************************************
*  Filepath: /web_studio/static/src/client_action/studio_action_container.js  *
*  Bundle: web_studio.studio_assets                                           *
*  Lines: 20                                                                  *
******************************************************************************/
odoo.define('@web_studio/client_action/studio_action_container', async function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { ActionContainer } = require("@web/webclient/actions/action_container");
const { useService } = require("@web/core/utils/hooks");

const StudioActionContainer = __exports.StudioActionContainer = class StudioActionContainer extends ActionContainer {
    setup() {
        super.setup();
        this.actionService = useService("action");
        if (this.props.initialAction) {
            this.actionService.doAction(this.props.initialAction);
        }
    }
}

return __exports;
});
;

/***************************************************************************
*  Filepath: /web_studio/static/src/client_action/studio_client_action.js  *
*  Bundle: web_studio.studio_assets                                        *
*  Lines: 85                                                               *
***************************************************************************/
odoo.define('@web_studio/client_action/studio_client_action', async function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

const { registry } = require("@web/core/registry");
const { useBus, useService } = require("@web/core/utils/hooks");
const { cleanDomFromBootstrap } = require("@web/legacy/utils");
const { computeAppsAndMenuItems } = require("@web/webclient/menus/menu_helpers");
const { ComponentAdapter } = require("web.OwlCompatibility");
const { AppCreatorWrapper } = require("@web_studio/client_action/app_creator/app_creator");
const { Editor } = require("@web_studio/client_action/editor/editor");
const { StudioNavbar } = require("@web_studio/client_action/navbar/navbar");
const { StudioHomeMenu } = require("@web_studio/client_action/studio_home_menu/studio_home_menu");

const { Component } = owl;

const StudioClientAction = __exports.StudioClientAction = class StudioClientAction extends Component {
    setup() {
        this.studio = useService("studio");
        useBus(this.studio.bus, "UPDATE", () => {
            this.render();
            cleanDomFromBootstrap();
        });

        this.menus = useService("menu");
        this.actionService = useService("action");
        this.homeMenuProps = computeAppsAndMenuItems(this.menus.getMenuAsTree("root"));
        useBus(this.env.bus, "MENUS:APP-CHANGED", () => {
            this.homeMenuProps = computeAppsAndMenuItems(this.menus.getMenuAsTree("root"));
            this.render();
        });

        this.AppCreatorWrapper = AppCreatorWrapper; // to remove
    }

    willStart() {
        return this.studio.ready;
    }

    mounted() {
        this.studio.pushState();
        document.body.classList.add("o_in_studio"); // FIXME ?
    }

    patched() {
        this.studio.pushState();
    }

    willUnmount() {
        document.body.classList.remove("o_in_studio");
    }

    async onNewAppCreated(ev) {
        const { menu_id, action_id } = ev.detail;
        await this.menus.reload();
        this.menus.setCurrentMenu(menu_id);
        const action = await this.actionService.loadAction(action_id);
        this.studio.setParams({
            mode: this.studio.MODES.EDITOR,
            editorTab: "views",
            action,
            viewType: "form",
        });
    }
}
StudioClientAction.template = "web_studio.StudioClientAction";
StudioClientAction.components = {
    StudioNavbar,
    StudioHomeMenu,
    Editor,
    ComponentAdapter: class extends ComponentAdapter {
        setup() {
            super.setup();
            this.env = owl.Component.env;
        }
    },
};
StudioClientAction.target = "fullscreen";

// force: true to override action defined by studio_action_loader
registry.category("actions").add("studio", StudioClientAction, { force: true });

return __exports;
});
;

/***************************************************************************************************************
*  Filepath: /web_studio/static/src/client_action/studio_home_menu/icon_creator_dialog/icon_creator_dialog.js  *
*  Bundle: web_studio.studio_assets                                                                            *
*  Lines: 83                                                                                                   *
***************************************************************************************************************/
odoo.define('@web_studio/client_action/studio_home_menu/icon_creator_dialog/icon_creator_dialog', async function (require) {
'use strict';
let __exports = {};
/* @odoo-module */

const { _lt } = require("@web/core/l10n/translation");
const { Dialog } = require("@web/core/dialog/dialog");
const { IconCreator } = require("@web_studio/client_action/icon_creator/icon_creator");
const { useService } = require("@web/core/utils/hooks");

const IconCreatorDialog = __exports.IconCreatorDialog = class IconCreatorDialog extends Dialog {
    setup() {
        super.setup();
        this.user = useService("user");
        this.rpc = useService("rpc");
        this.menus = useService("menu");
        this.initialAppData = Object.assign({}, this.props.editedAppData);
        this.editedAppData = owl.hooks.useState(this.props.editedAppData);
    }

    /**
     * @private
     * @param {CustomEvent} ev
     */
    onIconChanged(ev) {
        for (const key in this.editedAppData) {
            delete this.editedAppData[key];
        }
        for (const key in ev.detail) {
            this.editedAppData[key] = ev.detail[key];
        }
    }

    /**
     * @private
     */
    async saveIcon() {
        const { type } = this.initialAppData;
        const appId = this.props.appId;
        let iconValue;
        if (this.editedAppData.type !== type) {
            // different type
            if (this.editedAppData.type === "base64") {
                iconValue = this.editedAppData.uploaded_attachment_id;
            } else {
                const { iconClass, color, backgroundColor } = this.editedAppData;
                iconValue = [iconClass, color, backgroundColor];
            }
        } else if (this.editedAppData.type === "custom_icon") {
            // custom icon changed
            const { iconClass, color, backgroundColor } = this.editedAppData;
            if (
                this.initialAppData.iconClass !== iconClass ||
                this.initialAppData.color !== color ||
                this.initialAppData.backgroundColor !== backgroundColor
            ) {
                iconValue = [iconClass, color, backgroundColor];
            }
        } else if (this.editedAppData.uploaded_attachment_id) {
            // new attachment
            iconValue = this.editedAppData.uploaded_attachment_id;
        }

        if (iconValue) {
            await this.rpc("/web_studio/edit_menu_icon", {
                context: this.user.context,
                icon: iconValue,
                menu_id: appId,
            });
            await this.menus.reload();
        }
        this.close();
    }
}
IconCreatorDialog.title = _lt("Edit Application Icon");
IconCreatorDialog.contentClass = "o_web_studio_edit_menu_icon_modal";
IconCreatorDialog.size = "modal-md";
IconCreatorDialog.bodyTemplate = "web_studio.IconCreatorDialogBody";
IconCreatorDialog.footerTemplate = "web_studio.IconCreatorDialogFooter";
IconCreatorDialog.components = { IconCreator };

return __exports;
});
;

/****************************************************************************************
*  Filepath: /web_studio/static/src/client_action/studio_home_menu/studio_home_menu.js  *
*  Bundle: web_studio.studio_assets                                                     *
*  Lines: 136                                                                           *
****************************************************************************************/
odoo.define('@web_studio/client_action/studio_home_menu/studio_home_menu', async function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/
const { HomeMenu } = require("@web_enterprise/webclient/home_menu/home_menu");
const { useService } = require("@web/core/utils/hooks");
const { NotEditableActionError } = require("@web_studio/studio_service");
const { IconCreatorDialog } = require("@web_studio/client_action/studio_home_menu/icon_creator_dialog/icon_creator_dialog");

const NEW_APP_BUTTON = {
    isNewAppButton: true,
    label: "New App",
    webIconData: "/web_studio/static/src/img/default_icon_app.png",
};

/**
 * Studio home menu
 *
 * Studio version of the standard enterprise home menu. It has roughly the same
 * implementation, with the exception of the app icon edition and the app creator.
 * @extends HomeMenu
 */
const StudioHomeMenu = __exports.StudioHomeMenu = class StudioHomeMenu extends HomeMenu {
    /**
     * @param {Object} props
     * @param {Object[]} props.apps application icons
     * @param {string} props.apps[].action
     * @param {number} props.apps[].id
     * @param {string} props.apps[].label
     * @param {string} props.apps[].parents
     * @param {(boolean|string|Object)} props.apps[].webIcon either:
     *      - boolean: false (no webIcon)
     *      - string: path to Odoo icon file
     *      - Object: customized icon (background, class and color)
     * @param {string} [props.apps[].webIconData]
     * @param {string} props.apps[].xmlid
     */
    constructor() {
        super(...arguments);

        this.user = useService("user");
        this.studio = useService("studio");
        this.notifications = useService("notification");
        this.dialog = useService("dialog");
    }

    mounted() {
        super.mounted();
        this.canEditIcons = true;
        this.el.classList.add("o_studio_home_menu");
    }

    async willUpdateProps(nextProps) {
        this.availableApps = this.state.query.length
            ? this._filter(nextProps.apps)
            : nextProps.apps;
    }

    //--------------------------------------------------------------------------
    // Getters
    //--------------------------------------------------------------------------

    get displayedApps() {
        return super.displayedApps.concat([NEW_APP_BUTTON]);
    }

    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------

    /**
     * @override
     * @private
     */
    async _openMenu(menu) {
        if (menu.isNewAppButton) {
            this.canEditIcons = false;
            return this.studio.open(this.studio.MODES.APP_CREATOR);
        } else {
            try {
                await this.studio.open(this.studio.MODES.EDITOR, menu.actionID);
                this.menus.setCurrentMenu(menu);
            } catch (e) {
                if (e instanceof NotEditableActionError) {
                    const options = { type: "danger" };
                    this.notifications.add(
                        this.env._t("This action is not editable by Studio"),
                        options
                    );
                    return;
                }
                throw e;
            }
        }
    }

    //--------------------------------------------------------------------------
    // Handlers
    //--------------------------------------------------------------------------

    /**
     * @private
     * @param {Object} app
     */
    onEditIconClick(app) {
        if (!this.canEditIcons) {
            return;
        }
        const editedAppData = {};
        if (app.webIconData) {
            Object.assign(editedAppData, {
                webIconData: app.webIconData,
                type: "base64",
            });
        } else {
            Object.assign(editedAppData, {
                backgroundColor: app.webIcon.backgroundColor,
                color: app.webIcon.color,
                iconClass: app.webIcon.iconClass,
                type: "custom_icon",
            });
        }

        const dialogProps = {
            editedAppData,
            appId: app.id,
        };
        this.dialog.add(IconCreatorDialog, dialogProps);
    }
}

StudioHomeMenu.props = { apps: HomeMenu.props.apps };
StudioHomeMenu.template = "web_studio.StudioHomeMenu";

return __exports;
});
;

/******************************************************************
*  Filepath: /web_studio/static/src/legacy/action_editor_main.js  *
*  Bundle: web_studio.studio_assets                               *
*  Lines: 435                                                     *
******************************************************************/
odoo.define('@web_studio/legacy/action_editor_main', async function (require) {
'use strict';
let __exports = {};
/** @odoo-module **/

/**
 * Formerly action_editor_action, slightly adapted
 */

const core = require("web.core");
const Dialog = require("web.Dialog");
const dom = require("web.dom");
const session = require("web.session");
const Widget = require("web.Widget");

const ActionEditor = require("web_studio.ActionEditor");
const bus = require("web_studio.bus");
const ViewEditorManager = require("web_studio.ViewEditorManager");

const _t = core._t;
const _lt = core._lt;

const ActionEditorMain = __exports.ActionEditorMain = Widget.extend({
    custom_events: {
        studio_default_view: "_onSetDefaultView",
        studio_restore_default_view: "_onRestoreDefaultView",
        studio_disable_view: "_onDisableView",
        studio_edit_view: "_onEditView",
        studio_edit_action: "_onEditAction",
    },
    /**
     * @constructor
     * @param {Object} options
     * @param {Object} options.action - action description
     * @param {Boolean} options.chatter_allowed
     * @param {string} [options.controllerState]
     * @param {boolean} [options.noEdit] - do not edit a view
     * @param {string} [options.viewType]
     * @param {Object} [options.x2mEditorPath]
     */
    init: function (parent, options) {
        this._super.apply(this, arguments);

        this._title = _t("Studio");
        if (this.controlPanelProps) {
            this.controlPanelProps.title = this._title;
        }
        this.options = options;
        this.action = options.action;

        this._setEditedView(options.viewType);

        // We set the x2mEditorPath since when we click on the studio breadcrumb
        // a new view_editor_manager is instantiated and then the previous
        // x2mEditorPath is needed to reload the previous view_editor_manager
        // state.
        this.x2mEditorPath = options.x2mEditorPath;
        this.activityAllowed = undefined;
        this.controllerState = options.controllerState || {};
    },
    /**
     * @override
     */
    willStart: function () {
        if (!this.action) {
            return Promise.reject();
        }
        var defs = [this._super.apply(this, arguments), this._isActivityAllowed()];
        return Promise.all(defs);
    },
    /**
     * @override
     */
    start: function () {
        var self = this;
        var def;
        this.$el.addClass("o_web_studio_client_action");
        var isEditable = _.contains(ActionEditor.prototype.VIEW_TYPES, this.viewType);
        if (this.options.noEdit || !isEditable) {
            // click on "Views" in menu or view we cannot edit
            this.action_editor = new ActionEditor(this, this.action);
            def = this.action_editor.appendTo(this.$(".o_content"));
        } else {
            // directly edit the view instead of displaying all views
            def = this._editView();
        }
        return Promise.all([def, this._super.apply(this, arguments)]).then(function () {
            self._pushState();
            bus.trigger("studio_main", self.action);
            if (!self.options.noEdit) {
                // TODO: try to put it in editView
                bus.trigger("edition_mode_entered", self.viewType);
            }
            // add class when activating a pivot/graph view through studio
            const model = self.view_editor && self.view_editor.view.model;
            if (model && model._isInSampleMode) {
                self.el.classList.add("o_view_sample_data");
            }
        });
    },
    /**
     * @override
     */
    on_attach_callback: function () {
        this.isInDOM = true;
        if (this.view_editor) {
            this.view_editor.on_attach_callback();
        }
    },
    /**
     * @override
     */
    on_detach_callback: function () {
        this.isInDOM = false;
        if (this.view_editor) {
            this.view_editor.on_detach_callback();
        }
    },

    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------

    /**
     * @private
     * @param {Object} action
     * @param {Object} args
     * @returns {Promise}
     */
    _editAction: function (action, args) {
        var self = this;
        core.bus.trigger("clear_cache");
        return this._rpc({
            route: "/web_studio/edit_action",
            params: {
                action_type: action.type,
                action_id: action.id,
                args: args,
                context: session.user_context,
            },
        }).then(function (result) {
            if (result !== true) {
                Dialog.alert(self, result);
            } else {
                return self._reloadAction(action.id);
            }
        });
    },
    /**
     * @private
     */
    _editView: function () {
        var self = this;

        // the default view needs to be created before `loadViews` or the
        // renderer will not be aware that a new view exists
        var defs = [this._getStudioViewArch(this.action.res_model, this.viewType, this.viewId)];
        if (this.viewType === "form") {
            defs.push(this._isChatterAllowed());
        }
        return Promise.all(defs).then(function () {
            // add studio in loadViews context to retrieve groups server-side
            // We load views in the base language to make sure we read/write on the source term field
            // of ir.ui.view
            var context = _.extend({}, self.action.context, { studio: true, lang: false });
            var loadViewDef = self.loadViews(self.action.res_model, context, self.views, {
                load_filters: true,
            });
            return loadViewDef.then(function (fields_views) {
                if (!self.action.controlPanelFieldsView) {
                    // in case of Studio navigation, the processing done on the
                    // action in ActWindowActionManager@_executeWindowAction
                    // is by-passed
                    self.action.controlPanelFieldsView = fields_views.search;
                }
                if (!self.controllerState.currentId) {
                    self.controllerState.currentId =
                        self.controllerState.resIds && self.controllerState.resIds[0];
                }
                var params = {
                    action: self.action,
                    fields_view: fields_views[self.viewType],
                    viewType: self.viewType,
                    chatter_allowed: self.chatter_allowed,
                    studio_view_id: self.studioView.studio_view_id,
                    studio_view_arch: self.studioView.studio_view_arch,
                    x2mEditorPath: self.x2mEditorPath,
                    controllerState: self.controllerState,
                };
                self.view_editor = new ViewEditorManager(self, params);

                var fragment = document.createDocumentFragment();
                return self.view_editor.appendTo(fragment).then(function () {
                    if (self.action_editor) {
                        dom.detach([{ widget: self.action_editor }]);
                    }
                    dom.append(self.$el, [fragment], {
                        in_DOM: self.isInDOM,
                        callbacks: [{ widget: self.view_editor }],
                    });
                });
            });
        });
    },
    /**
     * @private
     * @param {String} model
     * @param {String} view_type
     * @param {Integer} view_id
     * @returns {Promise}
     */
    _getStudioViewArch: function (model, view_type, view_id) {
        var self = this;
        core.bus.trigger("clear_cache");
        return this._rpc({
            route: "/web_studio/get_studio_view_arch",
            params: {
                model: model,
                view_type: view_type,
                view_id: view_id,
                // We load views in the base language to make sure we read/write on the source term field
                // of ir.ui.view
                context: _.extend({}, session.user_context, { lang: false }),
            },
        }).then(function (studioView) {
            self.studioView = studioView;
        });
    },
    /**
     * Determines whether the model that will be edited supports mail_activity.
     *
     * @private
     * @returns {Promise}
     */
    _isActivityAllowed: function () {
        var self = this;
        var modelName = this.action.res_model;
        return this._rpc({
            route: "/web_studio/activity_allowed",
            params: {
                model: modelName,
            },
        }).then(function (activityAllowed) {
            self.activityAllowed = activityAllowed;
        });
    },
    /**
     * @private
     * Determines whether the model
     * that will be edited supports mail_thread
     * @returns {Promise}
     */
    _isChatterAllowed: function () {
        var self = this;
        var res_model = this.action.res_model;
        return this._rpc({
            route: "/web_studio/chatter_allowed",
            params: {
                model: res_model,
            },
        }).then(function (isChatterAllowed) {
            self.chatter_allowed = isChatterAllowed;
        });
    },

    /**
     * @private
     */
    _pushState: function () {
        // as there is no controller, we need to update the state manually
        var state = {
            action: this.action.id,
            model: this.action.res_model,
            view_type: this.viewType,
        };
        // TODO: necessary?
        if (this.action.context) {
            var active_id = this.action.context.active_id;
            if (active_id) {
                state.active_id = active_id;
            }
            var active_ids = this.action.context.active_ids;
            // we don't push active_ids if it's a single element array containing the active_id
            // to make the url shorter in most cases
            if (active_ids && !(active_ids.length === 1 && active_ids[0] === active_id)) {
                state.active_ids = this.action.context.active_ids.join(",");
            }
        }
        this.trigger_up("push_state", {
            state: state,
            studioPushState: true, // see action_manager @_onPushState
        });
    },
    /**
     * @private
     * @param {Integer} actionID
     * @returns {Promise}
     */
    _reloadAction: function (actionID) {
        var self = this;
        return new Promise(function (resolve) {
            self.trigger_up("reload_action", {
                actionID: actionID,
                onSuccess: resolve,
            });
        });
    },
    /**
     * @private
     * @param {string} [viewType]
     */
    _setEditedView: function (viewType) {
        var views = this.action._views || this.action.views;
        this.views = views.slice();
        // search is not in action.view
        var searchview_id = this.action.search_view_id && this.action.search_view_id[0];
        this.views.push([searchview_id || false, "search"]);
        var view = _.find(this.views, function (v) {
            return v[1] === viewType;
        });
        this.view = view || this.views[0]; // see action manager
        this.viewId = this.view[0];
        this.viewType = this.view[1];
    },
    /**
     * @private
     * @param {String} view_mode
     * @returns {Promise}
     */
    _writeViewMode: function (view_mode, initial_view_mode) {
        var self = this;
        var def = this._editAction(this.action, { view_mode: view_mode });
        return def.then(function (result) {
            if (initial_view_mode) {
                result.initial_view_types = initial_view_mode.split(",");
            }
            /* non-working action removed in #21562: we should never get here */
            return self.do_action("action_web_studio_action_editor", {
                action: result,
                noEdit: true,
            });
        });
    },

    //--------------------------------------------------------------------------
    // Handlers
    //--------------------------------------------------------------------------

    /**
     * @private
     * @param {OdooEvent} event
     */
    _onDisableView: function (event) {
        var view_type = event.data.view_type;
        var view_mode = _.without(this.action.view_mode.split(","), view_type);

        if (!view_mode.length) {
            Dialog.alert(this, _t("You cannot deactivate this view as it is the last one active."));
        } else {
            this._writeViewMode(view_mode.toString());
        }
    },
    /**
     * @private
     * @param {OdooEvent} event
     */
    _onEditAction: function (event) {
        var self = this;

        var args = event.data.args;
        if (!args) {
            return;
        }

        this._editAction(this.action, args).then(function (result) {
            self.action = result;
        });
    },
    /**
     * @private
     * @param {OdooEvent} event
     * @param {string} event.data.view_type
     */
    _onEditView: function (event) {
        this._setEditedView(event.data.view_type);
        this._editView().then(function () {
            bus.trigger("edition_mode_entered", event.data.view_type);
        });
    },
    /**
     * @private
     */
    _onRestoreDefaultView: function (event) {
        var self = this;

        var message = _t(
            "Are you sure you want to restore the default view?\r\nAll customization done with studio on this view will be lost."
        );

        Dialog.confirm(this, message, {
            confirm_callback: function () {
                var context = _.extend({}, self.action.context, { studio: true, lang: false });
                //To restore the default view from an inherited one, we need first to retrieve the default view id
                var loadViewDef = self.loadViews(self.action.res_model, context, self.views, {
                    load_filters: true,
                });
                loadViewDef.then(function (fields_views) {
                    self._rpc({
                        route: "/web_studio/restore_default_view",
                        params: {
                            view_id: fields_views[event.data.view_type].view_id,
                        },
                    });
                });
            },
            dialogClass: "o_web_studio_preserve_space",
        });
    },
    /**
     * @private
     * @param {OdooEvent} event
     */
    _onSetDefaultView: function (event) {
        var selected_view_type = event.data.view_type;
        var view_types = _.map(this.action.views, ({ type }) => type);
        var view_mode = _.without(view_types, selected_view_type);
        view_mode.unshift(selected_view_type);
        view_mode = view_mode.toString();

        this._writeViewMode(view_mode, this.action.view_mode);
    },
});

return __exports;
});
;

/*****************************************************************
*  Filepath: /web_studio/static/src/legacy/edit_menu_adapter.js  *
*  Bundle: web_studio.studio_assets                              *
*  Lines: 69                                                     *
*****************************************************************/
odoo.define('@web_studio/legacy/edit_menu_adapter', async function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

const { useService } = require("@web/core/utils/hooks");
const { ComponentAdapter } = require("web.OwlCompatibility");
const { MenuItem } = require("web_studio.EditMenu");

class EditMenuItemAdapter extends ComponentAdapter {
    constructor(parent, props) {
        props.Component = MenuItem;
        super(...arguments);
        this.menus = useService("menu");
        this.env = owl.Component.env;
    }

    get currentMenuId() {
        return this.menus.getCurrentApp().id;
    }

    get legacyMenuData() {
        return this.menus.getMenuAsTree("root");
    }

    get widgetArgs() {
        return [this.legacyMenuData, this.currentMenuId];
    }
    mounted() {
        super.mounted(...arguments);
        if (this.props.keepOpen) {
            this.widget.editMenu(this.props.scrollToBottom);
        }
    }
    updateWidget() {}
    renderWidget() {}
}

// why a high order component ?
// - support navbar re-rendering without having to fiddle too much in
// the legacy widget's code
// - allow to support the keepopen, and autoscroll features (yet to come)
const EditMenuItem = __exports.EditMenuItem = class EditMenuItem extends owl.Component {
    constructor() {
        super(...arguments);
        this.localId = 0;
        this.menus = useService("menu");
        owl.hooks.onWillUpdateProps(() => this.localId++);
        this.editMenuParams = {};
        owl.hooks.onPatched(() => {
            this.editMenuParams = {};
        });
    }
    reloadMenuData(ev) {
        const { keep_open, scroll_to_bottom } = ev.detail;
        this.editMenuParams = { keepOpen: keep_open, scrollToBottom: scroll_to_bottom };
        this.menus.reload();
    }
}
EditMenuItem.components = { EditMenuItemAdapter };
EditMenuItem.template = owl.tags.xml`
  <t>
    <div t-if="!menus.getCurrentApp()"/>
    <t t-else="" t-component="EditMenuItemAdapter" t-props="editMenuParams" t-key="localId" t-on-reload-menu-data="reloadMenuData" />
  </t>
`;

return __exports;
});
;

/*****************************************************************
*  Filepath: /web_studio/static/src/legacy/new_model_adapter.js  *
*  Bundle: web_studio.studio_assets                              *
*  Lines: 47                                                     *
*****************************************************************/
odoo.define('@web_studio/legacy/new_model_adapter', async function (require) {
'use strict';
let __exports = {};
/** @odoo-module */

const NewModel = require("web_studio.NewModel");
const { ComponentAdapter } = require("web.OwlCompatibility");
const { useService } = require("@web/core/utils/hooks");

const NewModelItem = __exports.NewModelItem = class NewModelItem extends owl.Component {
    setup() {
        this.NewModel = NewModel;
        this.menus = useService("menu");
        this.studio = useService("studio");
        this.action = useService("action");
        this.localId = 0;
        owl.hooks.onWillUpdateProps(() => this.localId++);
    }

    async editNewModel(ev) {
        const { action_id, options } = ev.detail;
        const action = await this.action.loadAction(action_id);
        this.studio.setParams({ action, viewType: (options && options.viewType) || "form" });
    }
}
NewModelItem.template = owl.tags.xml`
  <t>
    <t t-set="currentApp" t-value="menus.getCurrentApp()" />
    <t t-if="currentApp"
       t-component="ComponentAdapter"
       Component="NewModel.NewModelItem"
       widgetArgs="[currentApp and currentApp.id]"
       t-key="localId"
       t-on-reload-menu-data="menus.reload()"
       t-on-menu-clicked="editNewModel" />
    <div t-else="" />
  </t>
`;
NewModelItem.components.ComponentAdapter = class extends ComponentAdapter {
    setup() {
        super.setup();
        this.env = owl.Component.env;
    }
};

return __exports;
});
;

/*****************************************************
*  Filepath: /web_studio/static/src/legacy/js/py.js  *
*  Bundle: web_studio.studio_assets                  *
*  Lines: 155                                        *
*****************************************************/
(function (py) {

/**
 *
 * ´py.extract´ is an extension used only by AbstractEditComponent,
 * to parse the python values of the views so that it can be used
 * in javascript.
 *
 * The string converted into a dictionary in the case of options, and
 * a list of fieldName and non-usable rest (free code, functions,
 * calculations ...)
 *
 * eg:
 *
 *   t-esc="o.doc.get_currency()"
 *   t-options='{"field": o.doc.product_id, "toto": o.toto, "tata": "string"}'
 *   t-options='dict(field=o.doc.product_id, toto=o.toto, tata="string")'
 *   t-options-currency="o.doc.amount + 11.0"
 *
 * @see _splitRelatedValue in edit_components.js
 * @see _extractTOptions in edit_components.js
 *
 * Although it is functional, this must be redone, it is a poc.
 **/

var Python = function (expr, type, params) {
    this.expr = expr;
    this.params = params;
    if (type === 'call') {
        this.isCall = true;
    }
    if (type === 'field') {
        this.isField = true;
    }
    if (type === 'operator') {
        this.isOperator = true;
    }
};
Python.prototype.isPython = true;
Python.prototype.toString = function () {
    return this.expr + '';
};

function extract (expr) {
    switch (expr.id) {
        case '(name)':
            switch (expr.value) {
                case 'true': return true;
                case 'false': return false;
            }
            return new Python(expr.value, 'field');
        case '(string)':
        case '(number)':
        case '(constant)':
            switch (expr.value) {
                case 'None': return null;
                case 'False': return false;
                case 'True': return true;
            }
            return expr.value;
        case '(':
            var func = extract(expr.first);
            var error = false;
            if (func.isPython && func.expr === 'dict') {
                var obj = {};
                for(var l=0; l<expr.second.length; ++l) {
                    var kv = expr.second[l];
                    if (kv.id === "=") {
                        obj[extract(kv.first)] = extract(kv.second);
                    } else {
                        error = true;
                    }
                }
                if (!error) {
                    return obj;
                }
            }
            var array = [];
            for(var l=0; l<expr.second.length; ++l) {
                var kv = expr.second[l];
                array.push(extract(kv));
            }
            var res = new Python(func + '(' + array.join(', ') + ')', 'call', {
                object: func.isField ? func.params.slice(0, -1) : [],
                method: func.isField ? func.params[func.params.length-1] : func,
                args: array,
            });
            if (error) {
                throw new Error('SyntaxError: ' + res);
            }
            return res;
        case '[':
            if (expr.second) {
                var value = extract(expr.first);
                var attribute = extract(expr.second);
                return new Python(value + '[' + attribute + ']', 'attribute', {
                    value: value,
                    attribute: attribute,
                });
            }
            var array = [];
            for(var l=0; l<expr.first.length; ++l) {
                array.push(extract(expr.first[l]));
            }
            return array;
        case '{':
            var obj = {};
            for(var l=0; l<expr.first.length; ++l) {
                var kv = expr.first[l];
                obj[extract(kv[0])] = extract(kv[1]);
            }
            return obj;
        case '.':
            if (expr.second.id !== '(name)') {
                throw new Error('SyntaxError: ' + expr);
            }
            var params = [];
            var first = extract(expr.first);
            if (first.isAttribute) {
                params.push.apply(params, first.params);
            } else {
                params.push(first.expr);
            }
            var second = extract(expr.second);
            if (second.isAttribute) {
                params.push.apply(params, second.params);
            } else {
                params.push(second.expr);
            }
            return new Python(params.join('.'), 'field', params);
        case '=':
            return extract(expr.first) + '=' + extract(expr.second);
        case '(comparator)':
            var string = '';
            var values = [];
            for(var l=0; l<expr.expressions.length; ++l) {
                var value = extract(expr.expressions[l]);
                values.push(value);
                if (l > 0) {
                    string += expr.operators[l-1];
                }
                string += value;
            }
            return new Python(string, 'operator', {
                operators: expr.operators,
                values: values,
            });
    }
}
py.extract = function (str) {
    return extract(py.parse(py.tokenize(str)));
};

// eslint-disable-next-line no-undef
})(typeof exports === 'undefined' ? py : exports);;

/************************************************************
*  Filepath: /web_studio/static/src/legacy/js/edit_menu.js  *
*  Bundle: web_studio.studio_assets                         *
*  Lines: 445                                               *
************************************************************/
odoo.define('web_studio.EditMenu', function (require) {
"use strict";

const CommonMenuDialog = require('web_studio.CommonMenuDialog');
var config = require('web.config');
var core = require('web.core');
var Dialog = require('web.Dialog');
var FieldManagerMixin = require('web.FieldManagerMixin');
var form_common = require('web.view_dialogs');
var relational_fields = require('web.relational_fields');
var session = require('web.session');
var StandaloneFieldManagerMixin = require('web.StandaloneFieldManagerMixin');
var Widget = require('web.Widget');

var Many2One = relational_fields.FieldMany2One;
const FieldRadio = relational_fields.FieldRadio;
var _t = core._t;

var MenuItem = Widget.extend({
    template: 'web_studio.EditMenu.MenuItem',
    events: {
        'click .o_web_edit_menu': '_onClick',
    },
    /**
     * @constructor
     * @param {Widget} parent
     * @param {Object} menu_data
     * @param {Integer} current_primary_menu
     */
    init: function (parent, menu_data, current_primary_menu) {
        this._super.apply(this, arguments);
        this.menu_data = menu_data;
        this.current_primary_menu = current_primary_menu;
    },

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    editMenu: function (scrollToBottom) {
        new EditMenuDialog(this, this.menu_data, this.current_primary_menu, scrollToBottom)
            .open();
    },

    //--------------------------------------------------------------------------
    // Handlers
    //--------------------------------------------------------------------------

    /**
     * Open a dialog to edit the clicked menu.
     *
     * @private
     * @param {Event} event
     */
    _onClick: function (event) {
        event.preventDefault();
        this.editMenu();
    },
});

var EditMenuDialog = Dialog.extend({
    template: 'web_studio.EditMenu.Dialog',
    events: _.extend({}, Dialog.prototype.events, {
        'click button.js_edit_menu': '_onEditMenu',
        'click button.js_delete_menu': '_onDeleteMenu',
    }),
    /**
     * @constructor
     * @param {Widget} parent
     * @param {Object} menu_data
     * @param {Integer} current_primary_menu
     */
    init: function (parent, menu_data, current_primary_menu, scrollToBottom) {
        var options = {
            title: _t('Edit Menu'),
            size: 'medium',
            dialogClass: 'o_web_studio_edit_menu_modal',
            buttons: [{
                text: _t("Confirm"),
                classes: 'btn-primary',
                click: this._onSave.bind(this),
            }, {
                text: _t("Cancel"),
                close: true,
            }, {
                icon: 'fa-plus-circle',
                text: _t("New Menu"),
                classes: 'btn-secondary js_add_menu ml-auto',
                click: this._onAddMenu.bind(this),
            }],
        };
        this.current_primary_menu = current_primary_menu;
        this.roots = this.getMenuDataFiltered(menu_data);
        this.scrollToBottom = scrollToBottom;
        this.to_delete = [];
        this.to_move = {};

        this._super(parent, options);
    },
    /**
     * @override
     */
    start: function () {
        this.$('.oe_menu_editor').nestedSortable({
            listType: 'ul',
            handle: 'div',
            items: 'li',
            maxLevels: 5,
            toleranceElement: '> div',
            forcePlaceholderSize: true,
            opacity: 0.6,
            placeholder: 'oe_menu_placeholder',
            tolerance: 'pointer',
            attribute: 'data-menu-id',
            expression: '()(.+)', // nestedSortable takes the second match of an expression (*sigh*)
            relocate: this.moveMenu.bind(this),
            rtl: _t.database.parameters.direction === "rtl",
        });
        this.opened().then(() => {
            if (this.scrollToBottom) {
                this.$el.scrollTop(this.$el.prop('scrollHeight'));
            }
        });
        return this._super.apply(this, arguments);
    },

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    /**
     * @param {Object} menu_data
     * @returns {Object}
     */
    getMenuDataFiltered: function (menu_data) {
        var self = this;
        var menus = menu_data.childrenTree.filter(function (el) {
            return el.id === self.current_primary_menu;
        });
        return menus;
    },
    /**
     * @param {Event} ev
     */
    moveMenu: function (ev, ui) {
        var self = this;

        var $menu = $(ui.item);
        var menu_id = $menu.data('menu-id');

        this.to_move[menu_id] = {
            parent_menu_id: $menu.parents('[data-menu-id]:first').data('menu-id') || this.current_primary_menu,
            sequence: $menu.index(),
        };

        // Resequence siblings
        _.each($menu.siblings('li'), function (el) {
            var menu_id = $(el).data('menu-id');
            if (menu_id in self.to_move) {
                self.to_move[menu_id].sequence = $(el).index();
            } else {
                self.to_move[menu_id] = {sequence: $(el).index()};
            }
        });
    },

    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------

    /**
     * @private
     * @param {Boolean} keep_open
     */
    _reloadMenuData: function (keep_open, scrollToBottom) {
        this.trigger_up('reload_menu_data', { keep_open: keep_open, scroll_to_bottom: scrollToBottom});
    },

    //--------------------------------------------------------------------------
    // Handlers
    //--------------------------------------------------------------------------

    /**
     * @private
     * @param {Event} ev
     */
    _onAddMenu: function (ev) {
        ev.preventDefault();

        var self = this;
        new NewMenuDialog(this, {
            parent_menu_id: this.current_primary_menu,
            on_saved: function () {
                self._saveChanges().then(function () {
                    self._reloadMenuData(true, true);
                });
            },
        }).open();
    },
    /**
     * @private
     * @param {Event} ev
     */
    _onDeleteMenu: function (ev) {
        var $menu = $(ev.currentTarget).closest('[data-menu-id]');
        var menu_id = $menu.data('menu-id') || 0;
        if (menu_id) {
            this.to_delete.push(menu_id);
        }
        $menu.remove();
    },
    /**
     * @private
     * @param {Event} ev
     */
    _onEditMenu: function (ev) {
        var self = this;
        var menu_id = $(ev.currentTarget).closest('[data-menu-id]').data('menu-id');
        new form_common.FormViewDialog(this, {
            res_model: 'ir.ui.menu',
            res_id: menu_id,
            on_saved: function () {
                self._saveChanges().then(function () {
                    self._reloadMenuData(true);
                });
            },
        }).open();
    },
    /**
     * Save the current changes (in `to_move` and `to_delete`).
     *
     * @private
     */
    _onSave: function () {
        var self = this;
        const $menus = this.$("[data-menu-id]");
        if (!$menus.length) {
            return Dialog.alert(self, _t('You cannot remove all the menu items of an app.\r\nTry uninstalling the app instead.'));
        }
        if (
            !_.isEmpty(this.to_move) ||
            !_.isEmpty(this.to_delete)
        ) {
            // do not make an rpc (and then reload menu) if there is nothing to save
            this._saveChanges().then(function () {
                self._reloadMenuData();
            });
        } else {
            this.close();
        }
    },
    /**
     * Save the current changes (in `to_move` and `to_delete`).
     *
     * @private
     * @returns {Promise}
     */
    _saveChanges: function () {
        return this._rpc({
            model: 'ir.ui.menu',
            method: 'customize',
            kwargs: {
                to_move: this.to_move,
                to_delete: this.to_delete,
            },
        });
    },
});

// The Many2One field is extended to catch when a model is quick created
// to avoid letting the user click on the save menu button
// before the model is created.
var EditMenuMany2One = Many2One.extend({
    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------

    /**
     * @override
     * @private
     */
    _quickCreate: function () {
        this.trigger_up('edit_menu_disable_save');
        var def = this._super.apply(this, arguments);
        Promise.resolve(def).then(this.trigger_up.bind(this, 'edit_menu_enable_save'),
                                  this.trigger_up.bind(this, 'edit_menu_enable_save'));

    },
});

const NewMenuDialog = CommonMenuDialog.extend({
    template: 'web_studio.EditMenu.Dialog.New',

    /**
     * @constructor
     * @param {Widget} parent
     * @param {Object} params
     * @param {function} params.on_saved - callback executed after saving
     * @param {String} confirmlabel - label of the create menu dialog
     */
    init: function (parent, params) {
        this.title = _t('Create a new Menu');
        this.confirmLabel = _t('Create Menu');
        this._super(...arguments);
    },
    /**
     * set buttons for the new menu dialog
     *
     * @override
     */
    async willStart() {
        await this._super(...arguments);
        this.set_buttons([{
            text: _t("Confirm"),
            classes: 'btn-primary confirm_button',
            click: this._onSave.bind(this)
        }, {
            text: _t("Cancel"),
            close: true
        }]);
    },
    /**
     * @override
     */
    start: function () {
        var self = this;
        var defs = [];
        this.opened().then(function () {
            self.$modal.addClass('o_web_studio_add_menu_modal');
            // focus on input
            self.$el.find('input[name="name"]').focus();
        });

        defs.push(this._super.apply(this, arguments));

        defs.push(this.model.makeRecord('ir.actions.act_window', [
            {
                name: 'model',
                relation: 'ir.model',
                type: 'many2one',
                domain: [['transient', '=', false], ['abstract', '=', false]],
            },
            {
                name: 'model_choice',
                type: 'selection',
                selection: [['new', _t('New Model')], ['existing', _t('Existing Model')], ['parent', _t('Parent Menu')]],
                value: 'new',
            }
        ]).then(function (recordID) {
            var options = {
                mode: 'edit',
            };
            var record = self.model.get(recordID);
            self.many2one = new EditMenuMany2One(self, 'model', record, options);
            self.many2one.nodeOptions.no_create_edit = !config.isDebug();
            self.many2one.nodeOptions.no_create = !config.isDebug();
            self._registerWidget(recordID, 'model', self.many2one);
            self.many2one.appendTo(self.$('.js_model'));
            self.model_choice = new FieldRadio(self, 'model_choice', record, options);
            self._registerWidget(recordID, 'model_choice', self.model_choice)
            self.model_choice.appendTo(self.$('.model_choice'));
            self._onChangeModelChoice();
        }));
        return Promise.all(defs);
    },
    /**
     * this method will create new menu and new model
     *
     * @private
     * @override
     * @param {String} menu_name
     */
    _doSave(menuName) {
        this._super(...arguments);
        const modelID = this.many2one.value && this.many2one.value.res_id;
        core.bus.trigger('clear_cache');
        return this._rpc({
            route: '/web_studio/create_new_menu',
            params: {
                menu_name: menuName,
                model_id: modelID,
                model_choice: this.model_choice.value,
                model_options: this.model_options,
                parent_menu_id: this.parent_menu_id,
                context: session.user_context,
            },
        });
    },

    /**
     * Handle the change of model choice (new or existing model). Change the dialog's confirm
     * button text label and hide or show the ir.model selection field depending on the selected
     * value.
     *
     * @private
     */
    _onChangeModelChoice: function() {
        const new_model = this.model_choice.value === 'new';
        this.set_buttons([{
            text: new_model? _t("Configure Model"):_t('Confirm'),
            classes: 'btn-primary confirm_button',
            click: new_model? this._onConfigureModel.bind(this):this._onSave.bind(this),
        }, {
            text: _t("Cancel"),
            close: true
        }]);
        this.$('.model_chooser').toggle(this.model_choice.value === 'existing');
    },

    //--------------------------------------------------------------------------
    // Handlers
    //--------------------------------------------------------------------------


    /**
     * Handle the 'previous' button click on the ModelConfigurator
     *
     * @private
     * @param {OdooEvent} ev
     */
    _onCancelOptions: function (ev) {
        this.$footer.find('.btn').removeClass('disabled').attr('disabled', null);
    },

    /**
     * Override of the 'field_changed' handler; make sure the model selection
     * field's visibility is modified whenever the model selection radio is updated.
     *
     * @private
     * @override
     * @param {OdooEvent} ev
     */
    _onFieldChanged: async function(ev) {
        const res = await StandaloneFieldManagerMixin._onFieldChanged.apply(this, arguments);
        this._onChangeModelChoice();
        return res;
    },
});

return {
    MenuItem: MenuItem,
    Dialog: EditMenuDialog,
};

});
;

/************************************************************
*  Filepath: /web_studio/static/src/legacy/js/new_model.js  *
*  Bundle: web_studio.studio_assets                         *
*  Lines: 133                                               *
************************************************************/
odoo.define('web_studio.NewModel', function (require) {
"use strict";

const core = require('web.core');
const session = require('web.session');
const Widget = require('web.Widget');
const CommonMenuDialog = require('web_studio.CommonMenuDialog');

const _t = core._t;

const NewModelItem = Widget.extend({
    xmlDependencies: ['/web_studio/static/src/legacy/xml/new_model.xml'],
    template: 'web_studio.NewModel',
    events: {
        'click .o_web_create_new_model': '_onClick',
    },

    /**
     * This new model widget provides the shortcut to create a
     * new model direct from the menubar.
     *
     * @constructor
     * @param {Widget} parent
     * @param {Integer} currentPrimaryMenu - for a current menu
     */
    init(parent, currentPrimaryMenu) {
        this._super(...arguments);
        this.current_primary_menu = currentPrimaryMenu;
    },

    //--------------------------------------------------------------------------
    // Handlers
    //--------------------------------------------------------------------------

    /**
     * Open a dialog to create new model.
     *
     * @private
     * @param {Event} event
     */
    _onClick(event) {
        event.preventDefault();
        new NewModelDialog(this, {
            parent_menu_id: this.current_primary_menu,
            on_saved(menu) {
                this.trigger_up('reload_menu_data');
                this.trigger_up('menu_clicked', {
                    openAction: true,
                    menu_id: this.current_primary_menu,
                    action_id: menu.action_id,
                    options: {viewType: 'form'},
                });
            },
        }).open();
    },

});

const NewModelDialog = CommonMenuDialog.extend({
    template: 'web_studio.NewModel.Dialog',

    /**
     * @constructor
     * @param {Widget} parent
     * @param {Object} params
     * @param {String} confirmlabel - label of the create model dialog
     */
    init(parent, params) {
        this.title = _t('Create a new Model');
        this.confirmLabel = _t('Create Model');
        this._super(...arguments);
    },

    /**
     * set buttons for the new model dialog
     *
     * @override
     */
    async willStart() {
        await this._super(...arguments);
        this.set_buttons([{
            text: _t("Configure Model"),
            classes: 'btn-primary confirm_button',
            click: this._onConfigureModel.bind(this),
        }, {
            text: _t("Cancel"),
            close: true
        }]);
    },

    /**
     * set focus on the model name input once dialog open
     *
     * @override
     */
    async start() {
        await this._super(...arguments);
        this.opened(() => {
            this.$modal.addClass('o_web_studio_new_model_modal');
            // focus on input
            this.el.querySelector('input[name="name"]').focus();
        });
    },

    /**
     * this method will create new menu and new model
     *
     * @private
     * @override
     * @param {String} menuName
     */
    _doSave(menuName) {
        this._super(...arguments);
        core.bus.trigger('clear_cache');
        return this._rpc({
            route: '/web_studio/create_new_menu',
            params: {
                menu_name: menuName,
                model_id: false,
                model_choice: 'new',
                model_options: this.model_options,
                parent_menu_id: this.parent_menu_id,
                context: session.user_context,
            },
        });
    },
});

return {
    NewModelItem: NewModelItem,
};

});
;

/*********************************************************************
*  Filepath: /web_studio/static/src/legacy/js/common_menu_dialog.js  *
*  Bundle: web_studio.studio_assets                                  *
*  Lines: 117                                                        *
*********************************************************************/
odoo.define('web_studio.CommonMenuDialog', function (require) {
"use strict";

const Dialog = require('web.Dialog');
const { ModelConfiguratorDialog } = require('web_studio.ModelConfigurator');
const StandaloneFieldManagerMixin = require('web.StandaloneFieldManagerMixin');


const CommonMenuDialog = Dialog.extend(StandaloneFieldManagerMixin, {
    custom_events: Object.assign({}, Dialog.prototype.custom_events, StandaloneFieldManagerMixin.custom_events, {
        edit_menu_disable_save: function () {
            this.$footer.find('.confirm_button').attr("disabled", "disabled");
        },
        edit_menu_enable_save: function () {
            this.$footer.find('.confirm_button').removeAttr("disabled");
        },
        confirm_options: '_onConfirmOptions',
        cancel_options: '_onCancelOptions',
    }),

    /**
     * @constructor
     * @param {Widget} parent
     * @param {Object} params
     * @param {function} [params.on_saved] Callback method called upon confirmation
     *
     */

    init(parent, params) {
        this.on_saved = params.on_saved || function () {};
        this.parent_menu_id = params.parent_menu_id;
        this.options = {
            title: this.title,
            size: 'small',
        };
        this._super(parent, this.options);
        StandaloneFieldManagerMixin.init.call(this);
    },

    //--------------------------------------------------------------------------
    // Handlers
    //--------------------------------------------------------------------------

    /**
     * Open the ModelConfigurator when the user confirm the creation of a new model
     *
     * @private
     */
    async _onConfigureModel() {
        if (!this.el.querySelector('input[name="name"]').value) {
            this.el.querySelector('label').classList.add('o_studio_error');
            return;
        }
        this.$footer.find('.btn').attr('disabled', '').addClass('disabled');
        this.modelConfiguratorDialog = new ModelConfiguratorDialog(this, { confirmLabel: this.confirmLabel });
        this.modelConfiguratorDialog.open();
    },

    /**
     * Handle the 'previous' button click on the ModelConfigurator
     *
     * @private
     * @param {OdooEvent} ev
     */

    _onCancelOptions(ev) {
        this.$footer.find('.btn').removeClass('disabled').attr('disabled', null);
    },

    /**
     * Handle the confirmation of the ModelConfigurator, save the selected options
     * and continue the flow.
     *
     * @private
     * @param {OdooEvent} ev
     */

    async _onConfirmOptions(ev) {
        this.model_options = Object.entries(ev.data).filter(opt => opt[1].value).map(opt => opt[0]);
        return this._onSave().then((res) => {
            this.modelConfiguratorDialog.close();
            this.close();
            return res;
        }).guardedCatch(() =>
            this.modelConfiguratorDialog.close());
    },

    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------

    /**
     * Creates the new menu.
     *
     * @private
     */
    _onSave() {
        this.$footer.find('.btn').attr('disabled', '').addClass('disabled');
        const name = this.el.querySelector('input').value;
        return this._doSave(name).then((menu) => {
            this.on_saved(menu);
        }).guardedCatch(() => {
            this.$footer.find('.btn').removeAttr('disabled').removeClass('disabled');
        });
    },
    /**
     * @private
     * @param {String} menuName
     */
    _doSave(menuName) {
        
    },
});

return CommonMenuDialog;

});
;

/*********************************************************************************
*  Filepath: /web_studio/static/src/legacy/js/common/abstract_editor_manager.js  *
*  Bundle: web_studio.studio_assets                                              *
*  Lines: 486                                                                    *
*********************************************************************************/
odoo.define('web_studio.AbstractEditorManager', function (require) {
"use strict";

var concurrency = require('web.concurrency');
var core = require('web.core');
var Widget = require('web.Widget');

var bus = require('web_studio.bus');
var XMLEditor = require('web_studio.XMLEditor');

var _lt = core._lt;
var _t = core._t;

var AbstractEditorManager = Widget.extend({
    className: 'o_web_studio_editor_manager',
    custom_events: {
        close_xml_editor: '_onCloseXMLEditor',
        drag_component: '_onDragComponent',
        node_clicked: '_onNodeClicked',
        open_xml_editor: '_onOpenXMLEditor',
        save_xml_editor: '_onSaveXMLEditor',
        sidebar_tab_changed: '_onSidebarTabChanged',
        studio_error: '_onStudioError',
        view_change: '_onViewChange',
    },
    error_messages: {
        wrong_xpath: _lt("This operation caused an error, probably because a xpath was broken"),
        view_rendering: _lt("The requested change caused an error in the view. It could be because a field was deleted, but still used somewhere else."),
    },
    /**
     * @override
     */
    init: function () {
        this._super.apply(this, arguments);

        this.editor = undefined;
        this.sidebar = undefined;
        this.sidebarScrollTop = undefined;

        this.mode = 'edition';  // the other mode is 'rendering' in XML editor

        this.operations = [];
        this.operations_undone = [];

        this.mdp = new concurrency.MutexedDropPrevious();

        bus.on('undo_clicked', this, this._undo);
        bus.on('redo_clicked', this, this._redo);
    },
    /**
     * @override
     */
    start: function () {
        var self = this;
        return this._super.apply(this, arguments).then(function () {
            return self._instantiateEditor().then(function (editor) {
                var defs = [];
                var $editorFragment = $('<div>', {
                    class: 'o_web_studio_view_renderer',
                });
                self.editor = editor;
                if (self.editor instanceof owl.Component) {
                    defs.push(self.editor.mount($editorFragment[0]));
                } else {
                    defs.push(self.editor.appendTo($editorFragment));
                }
                // TODO: is that correct? shouldn't this be done in then the
                // appendTo
                $editorFragment.appendTo(self.$el);

                self.sidebar = self._instantiateSidebar();
                defs.push(self.sidebar.prependTo(self.$el));
                return Promise.all(defs);
            });
        });
    },
    /**
     * @override
     */
    destroy: function () {
        bus.trigger('undo_not_available');
        bus.trigger('redo_not_available');
        this._super.apply(this, arguments);
    },
    /**
     * Called each time the view editor manager is attached to the DOM. This is
     * important for the graph editor, which only renders itself when it is in
     * the DOM
     *
     */
    on_attach_callback: function () {
        if (this.editor && this.editor.on_attach_callback) {
            this.editor.on_attach_callback();
        }
        this.isInDOM = true;
    },
    /**
     * Called each time the view editor manager is detached from the DOM.
     *
     */
    on_detach_callback: function () {
        if (this.editor && this.editor.on_detach_callback) {
            this.editor.on_detach_callback();
        }
        this.isInDOM = false;
    },

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------

    /**
     * Apply the changes, i.e. the stack of operations on the Studio view.
     *
     * @param {Boolean} remove_last_op
     * @param {Boolean} from_xml
     * @returns {Promise}
     */
    _applyChanges: function (remove_last_op, from_xml) {
        var self = this;

        var lastOp = this.operations.slice(-1)[0];
        var lastOpID = lastOp && lastOp.id;

        bus.trigger('toggle_snack_bar', 'saving');

        var def;
        if (from_xml) {
            def = this.mdp.exec(this._editViewArch.bind(
                this,
                lastOp.view_id,
                lastOp.new_arch
            )).guardedCatch(function () {
                self.trigger_up('studio_error', {error: 'view_rendering'});
            });
        } else {
            def = this.mdp.exec(function () {
                var serverOperations = [];
                _.each(self.operations, function (op) {
                    if (op.type !== 'replace_arch') {
                        serverOperations.push(_.omit(op, 'id'));
                    }
                });
                var prom = self._editView(
                    self.view_id,
                    self.studio_view_arch,
                    serverOperations
                );
                prom.guardedCatch(function () {
                    self.trigger_up('studio_error', {error: 'wrong_xpath'});
                    return self._undo(lastOpID, true).then(function () {
                        return Promise.reject();
                    });
                });
                return prom;
            });
        }
        return def
            .then(function (result) {
                if (from_xml) {
                    self._cleanOperationsStack(lastOp);
                }
                if (remove_last_op) { self.operations.pop(); }
                return self._applyChangeHandling(result, lastOpID, from_xml);
            })
            .then(function () {
                self._updateButtons();
                if (self.sidebar.state.mode !== 'properties') {
                    // TODO: the sidebar will be updated by clicking on the node
                    self._updateSidebar(self.sidebar.state.mode);
                }
                bus.trigger('toggle_snack_bar', 'saved');
            });
    },
    /**
     * To be overriden.
     *
     * @param {Object} result
     * @param {String} [opID]
     * @param {boolean} [from_xml]
     * @returns {Promise}
     */
    _applyChangeHandling: function (result, opID, from_xml) {
        return Promise.resolve();
    },
    /**
     * To be overriden.
     *
     * @private
     * @param {Object} lastOp
     */
    _cleanOperationsStack: function (lastOp) {
        this.operations = [];
        this.operations_undone = [];
    },
    /**
     * @private
     * @param {Object} op
     * @returns {Promise}
     */
    _do: function (op) {
        op.id = _.uniqueId('op_');
        this.operations.push(op);
        this.operations_undone = [];

        return this._applyChanges(false, op.type === 'replace_arch');
    },
    /**
     * To be overriden.
     *
     * @private
     * @param {String} [mode]
     * @param {Object} [params]
     * @returns {Promise<Object>}
     */
    _getSidebarState: function (mode, params) {
        var newState = mode ? {mode: mode} : this.sidebar.state;
        return Promise.resolve(newState);
    },
    /**
     * To be overriden.
     *
     * The point of this function is to receive a list of customize operations
     * to do.
     *
     * @private
     * @param {Integer} view_id
     * @param {String} studio_view_arch
     * @param {Array} operations
     * @returns {Promise}
     */
    _editView: function (view_id, studio_view_arch, operations) {
        return Promise.resolve();
    },
    /**
     * To be overriden.
     *
     * This is used when the view is edited with the XML editor: the whole arch
     * is replaced by a new one.
     *
     * @private
     * @param {Integer} view_id
     * @param {String} view_arch
     * @returns {Promise}
     */
    _editViewArch: function (view_id, view_arch) {
        return Promise.resolve();
    },
    /**
     * To be overriden.
     *
     * @param {Object} params
     * @returns {Promise}
     */
    _instantiateEditor: function (params) {
        return Promise.resolve();
    },
    /**
     * To be overriden.
     * TODO: should probably have the same signature than instantiateEditor
     *
     * @param {Object} state
     * @returns {Widget} a sidebar instance
     */
    _instantiateSidebar: function (state) {
    },
    /**
     * Redo the last operation.
     *
     * @private
     * @returns {Promise}
     */
    _redo: function () {
        if (!this.operations_undone.length) {
            return;
        }
        var op = this.operations_undone.pop();
        this.operations.push(op);

        return this._applyChanges(false, op.type === 'replace_arch');
    },
    /**
     * Update the undo/redo button according to the operation stack.
     */
    _updateButtons: function () {
        // Undo button
        if (this.operations.length) {
            bus.trigger('undo_available');
        } else {
            bus.trigger('undo_not_available');
        }

        // Redo button
        if (this.operations_undone.length) {
            bus.trigger('redo_available');
        } else {
            bus.trigger('redo_not_available');
        }
    },
    /**
     * Re-render the sidebar and destroy the old while keeping the scroll
     * position.
     * If mode is not specified, the sidebar will be renderered with the same
     * state.
     * The sidebar will be detached if the XML editor is displayed.
     *
     * @private
     * @param {String} [mode]
     * @param {Object} [params]
     * @returns {Promise}
     */
    _updateSidebar: function (mode, params) {
        var self = this;

        if  (this.sidebar.$el) {
            // as the sidebar is updated via trigger_up (`sidebar_tab_changed`),
            // we might want to update a sidebar which wasn't started yet

            // TODO: scroll top is calculated to 'o_web_studio_sidebar_content'
            this.sidebarScrollTop = this.sidebar.$el.scrollTop();
        }

        return this._getSidebarState(mode, params).then(function (newState) {
            var oldSidebar = self.sidebar;
            var previousState = oldSidebar.getLocalState ? oldSidebar.getLocalState() : undefined;
            const newSidebar = self._instantiateSidebar(newState, previousState);
            self.sidebar = newSidebar;

            var fragment = document.createDocumentFragment();
            return newSidebar.appendTo(fragment).then(function () {
                oldSidebar.destroy();
                if (!newSidebar.isDestroyed()) {
                    newSidebar.$el.prependTo(self.$el);
                    if (newSidebar.on_attach_callback) {
                        newSidebar.on_attach_callback();
                    }
                    newSidebar.$el.scrollTop(self.sidebarScrollTop);
                    // the XML editor replaces the sidebar in this case
                    if (self.mode === 'rendering') {
                        newSidebar.$el.detach();
                    }
                }
            });
        });
    },
    /**
     * Undo the last operation.
     *
     * @private
     * @param {String} [opID] unique operation identifier
     * @param {Boolean} [forget=False]
     * @returns {Promise}
     */
    _undo: function (opID, forget) {
        if (!this.operations.length) {
            return Promise.resolve();
        }

        // find the operation to undo and update the operations stack
        var op;
        if (opID) {
            op = _.findWhere(this.operations, {id: opID});
            this.operations = _.without(this.operations, op);
        } else {
            op = this.operations.pop();
        }

        if (!forget) {
            // store the operation in case of redo
            this.operations_undone.push(op);
        }

        if (op.type === 'replace_arch') {
            // as the whole arch has been replace (A -> B),
            // when undoing it, the operation (B -> A) is added and
            // removed just after.
            var undo_op = jQuery.extend(true, {}, op);
            undo_op.old_arch = op.new_arch;
            undo_op.new_arch = op.old_arch;
            this.operations.push(undo_op);
            return this._applyChanges(true, true);
        } else {
            return this._applyChanges(false, false);
        }
    },

    //--------------------------------------------------------------------------
    // Handlers
    //--------------------------------------------------------------------------

    /**
     * @private
     */
    _onCloseXMLEditor: function () {
        this.XMLEditor.destroy();
        this.XMLEditor = null;
        this.sidebar.prependTo(this.$el);
        $('body').removeClass('o_in_studio_xml_editor');
        this.mode = 'edition';
    },
    /**
     * To be overriden.
     *
     * @private
     * @param {OdooEvent} ev
     */
    _onDragComponent: function (ev) {
    },
    /**
     * To be overriden.
     *
     * @private
     * @param {OdooEvent} ev
     */
    _onNodeClicked: function (ev) {
    },
    /**
     * @private
     */
    _onOpenXMLEditor: function () {
        var self = this;
        this.mode = 'rendering';

        this.XMLEditor = new XMLEditor(this, this.view_id, {
            position: 'left',
            doNotLoadSCSS: true,
            doNotLoadJS: true,
        });

        this.XMLEditor.prependTo(this.$el).then(function () {
            self.sidebar.$el.detach();
            $('body').addClass('o_in_studio_xml_editor');
        });
    },
    /**
     * @private
     * @param {OdooEvent} ev
     */
    _onSaveXMLEditor: function (ev) {
        this._do({
            type: 'replace_arch',
            view_id: ev.data.view_id,
            old_arch: ev.data.old_arch,
            new_arch: ev.data.new_arch,
        }).then(function () {
            if (ev.data.on_success) {
                ev.data.on_success();
            }
        }, function () {
            if (ev.data.on_fail) {
                ev.data.on_fail();
            }
        });
    },
    /**
     * @private
     * @param {OdooEvent} ev
     */
    _onSidebarTabChanged: function (ev) {
        this._updateSidebar(ev.data.mode);
        this.editor.unselectedElements();
    },
    /**
     * @private
     * @param {OdooEvent} ev
     */
    _onStudioError: function (ev) {
        this.displayNotification({ title: _t("Error"), message: this.error_messages[ev.data.error], type: 'danger' });
    },
    /**
     * To be overriden.
     *
     * @private
     * @param {OdooEvent} ev
     */
    _onViewChange: function (ev) {
    },
});

return AbstractEditorManager;

});
;

/*******************************************************************************
*  Filepath: /web_studio/static/src/legacy/js/common/field_selector_dialog.js  *
*  Bundle: web_studio.studio_assets                                            *
*  Lines: 67                                                                   *
*******************************************************************************/
odoo.define('web_studio.FieldSelectorDialog', function (require) {
"use strict";

var config = require('web.config');
var core = require('web.core');
var Dialog = require('web.Dialog');
var _t = core._t;

var FieldSelectorDialog = Dialog.extend({
    template: 'web_studio.FieldSelectorDialog',
    /**
     * @constructor
     * @param {Widget} parent
     * @param {Object} fields
     * @param {Boolean} show_new
     */
    init: function (parent, fields, show_new) {
        // set the field name because key will be lost after sorting dict
        this.orderered_fields = _.sortBy(
            _.mapObject(fields, function (attrs, fieldName) {
                return {
                    name: fieldName,
                    string: attrs.string
                };
            }), 'string');
        this.show_new = show_new;
        this.debug = config.isDebug();

        var options = {
            title: _t('Select a Field'),
            buttons: [{
                text: _t("Confirm"),
                classes: 'btn-primary',
                click: this._onConfirm.bind(this),
                close: true
            }, {
                text: _t("Cancel"),
                click: this._onCancel.bind(this),
                close: true
            }],
        };
        this._super(parent, options);
    },

    //--------------------------------------------------------------------------
    // Handlers
    //--------------------------------------------------------------------------

    /**
     * @private
     */
    _onConfirm: function () {
        var selectedField = this.$('select[name="field"]').val();
        this.trigger('confirm', selectedField);
    },
    /**
     * @private
     */
    _onCancel: function () {
        this.trigger('cancel');
    },
});


return FieldSelectorDialog;

});
;

/**************************************************************************
*  Filepath: /web_studio/static/src/legacy/js/common/new_field_dialog.js  *
*  Bundle: web_studio.studio_assets                                       *
*  Lines: 322                                                             *
**************************************************************************/
odoo.define('web_studio.NewFieldDialog', function (require) {
"use strict";

var config = require('web.config');
var core = require('web.core');
var Dialog = require('web.Dialog');
var relational_fields = require('web.relational_fields');
var ModelFieldSelector = require('web.ModelFieldSelector');
var StandaloneFieldManagerMixin = require('web.StandaloneFieldManagerMixin');

var _t = core._t;
var qweb = core.qweb;
var Many2one = relational_fields.FieldMany2One;

// TODO: refactor this file

var NewFieldDialog = Dialog.extend(StandaloneFieldManagerMixin, {
    template: 'web_studio.NewFieldDialog',
    events: {
        'keyup .o_web_studio_selection_new_value > input': '_onAddSelectionValue',
        'click .o_web_studio_edit_selection_value': '_onEditSelectionValue',
        'click .o_web_studio_remove_selection_value': '_onRemoveSelectionValue',
        'click .o_web_studio_add_selection_value': '_onAddSelectionValue',
        'click .o_web_studio_clear_selection_value': '_onClearSelectionValue',
        'blur .o_web_studio_selection_editor .o_web_studio_selection_input': '_onSelectionInputBlur',
    },
    /**
     * @constructor
     * @param {String} model_name
     * @param {Object} field
     * @param {Object} fields
     * @param {Object[]} field_chain - list of the initial field chain parts
     */
    init: function (parent, model_name, field, fields, field_chain) {
        this.model_name = model_name;
        this.type = field.type;
        this.field = field;
        this.fieldChain = field_chain || [];
        this.order = field.order;
        this.followRelations = field.followRelations || function (field) {return true;};
        this.filter = field.filter || function (field) {return true;};
        this.filters = field.filters;

        if (this.type === 'selection') {
            this.selection = this.field.selection && this.field.selection.slice() || [];
        }

        this.fields = fields;
        var options = _.extend({
            title: _t('Field Properties'),
            size: 'small',
            buttons: [{
                text: _t("Confirm"),
                classes: 'btn-primary',
                click: this._onSave.bind(this),
            }, {
                text: _t("Cancel"),
                close: true,
            }],
        }, options);
        this._super(parent, options);
        StandaloneFieldManagerMixin.init.call(this);
    },
    /**
     * @override
     */
    renderElement: function () {
        this._super.apply(this, arguments);

        if (this.type === 'selection') {
           this.$('.o_web_studio_selection_editor').sortable({
                axis: 'y',
                containment: '.o_web_studio_field_dialog_form',
                items: '> li',
                helper: 'clone',
                handle: '.input-group',
                opacity: 0.6,
                stop: this._resequenceSelection.bind(this),
           });
       }
    },
    /**
     * @override
     */
    start: function() {
        var self = this;
        var defs = [];
        var record;
        var options = {
            mode: 'edit',
        };

        this.$modal.addClass('o_web_studio_field_modal');

        if (this.type === 'selection') {
            // Focus on the input responsible for adding new selection value
            this.opened().then(function () {
                self.$('.o_web_studio_selection_new_value > input').focus();
            });
        } else if (this.type === 'one2many') {
            defs.push(this.model.makeRecord('ir.model.fields', [{
                name: 'field',
                relation: 'ir.model.fields',
                type: 'many2one',
                domain: [['relation', '=', this.model_name], ['ttype', '=', 'many2one'], ['model_id.abstract', '=', false]],
            }], {
                'field': {
                    can_create: false,
                }
            }).then(function (recordID) {
                record = self.model.get(recordID);
                self.many2one_field = new Many2one(self, 'field', record, options);
                self._registerWidget(recordID, 'field', self.many2one_field);
                self.many2one_field.nodeOptions.no_create_edit = !config.isDebug();
                self.many2one_field.appendTo(self.$('.o_many2one_field'));
            }));
        } else if (_.contains(['many2many', 'many2one'], this.type)) {
            defs.push(this.model.makeRecord('ir.model', [{
                name: 'model',
                relation: 'ir.model',
                type: 'many2one',
                domain: [['transient', '=', false], ['abstract', '=', false]]
            }]).then(function (recordID) {
                record = self.model.get(recordID);
                self.many2one_model = new Many2one(self, 'model', record, options);
                self._registerWidget(recordID, 'model', self.many2one_model);
                self.many2one_model.nodeOptions.no_create_edit = !config.isDebug();
                self.many2one_model.appendTo(self.$('.o_many2one_model'));
            }));
        } else if (this.type === 'related') {
            // This restores default modal height (bootstrap) and allows field selector to overflow
            this.$el.css("overflow", "visible").closest(".modal-dialog").css("height", "auto");
            var field_options = {
                order: this.order,
                filter: this.filter,
                followRelations: this.followRelations,
                fields: this.fields, //_.filter(this.fields, this.filter),
                readonly: false,
                filters: _.extend({}, this.filters, {searchable: false}),
            };
            this.fieldSelector = new ModelFieldSelector(this, this.model_name, this.fieldChain, field_options);
            defs.push(this.fieldSelector.appendTo(this.$('.o_many2one_field')));
        }

        defs.push(this._super.apply(this, arguments));
        return Promise.all(defs);
    },

    /**
     * @private
     * @param {Event} e
     */
    _resequenceSelection: function () {
        var self = this;
        var newSelection = [];
        this.$('.o_web_studio_selection_editor li').each(function (index, u) {
            var value = u.dataset.value;
            var string = _.find(self.selection, function(el) {
                return el[0] === value;
            })[1];
            newSelection.push([value, string]);
        });
        this.selection = newSelection;
    },

    //--------------------------------------------------------------------------
    // Handlers
    //--------------------------------------------------------------------------

    /**
     * @private
     * @param {Event} e
     */
    _onAddSelectionValue: function (e) {
        if (e.type === "keyup" && e.which !== $.ui.keyCode.ENTER) { return; }

        var $input = this.$(".o_web_studio_selection_new_value input");
        var string = $input.val().trim();

        if (string && !_.find(this.selection, function(el) {return el[1] === string; })) {
            // add a new element
            this.selection.push([string, string]);
        }
        this.renderElement();
        this.$('.o_web_studio_selection_new_value > input').focus();
    },
    /**
     * @private
     * @param {Event} ev
     */
    _onEditSelectionValue: function (ev) {
        var self = this;
        var $btn = $(ev.currentTarget);

        if (config.isDebug()) {
            var val = $btn.closest('li')[0].dataset.value;  // use dataset to always get a string
            var index = _.findIndex(this.selection, function (el) {return el[0] === val;});
            new Dialog(this, {
                title: _t('Edit Value'),
                size: 'small',
                $content: $(qweb.render('web_studio.SelectionValues.edit', {
                    element: self.selection[index],
                })),
                buttons: [
                    {text: _t('Confirm'), classes: 'btn-primary', close: true, click: function () {
                        var newValue = this.$('input#o_selection_value').val() || val;
                        var newString = this.$('input#o_selection_label').val();
                        self.selection[index] = [newValue, newString];
                        self.renderElement();
                    }},
                    {text: _t('Close'), close: true},
                ],
            }).open();
        } else {
            $btn.toggleClass('fa-check fa-pencil-square-o');
            var $input = $btn.closest('li').find('.o_web_studio_selection_input.d-none');
            var $span = $input.siblings('.o_web_studio_selection_label');
            // Toggle span and input, and set the initial value for input
            $input.val($span.toggleClass('d-none').text().trim()).toggleClass('d-none').focus();
        }
    },
    /**
     * Removes a selection value from the widget
     * The python is in charge of determining whether some records
     * have a deleted value, and raises if this is the case
     *
     * @private
     * @param {Event} e
     */
    _onRemoveSelectionValue: function (e) {
        var val = $(e.target).closest('li')[0].dataset.value;
        var element = _.find(this.selection, function(el) {return el[0] === val; });
        var index = this.selection.indexOf(element);
        if (index >= 0) {
            this.selection.splice(index, 1);
        }
        this.renderElement();
    },
    /**
     * @private
     */
    _onClearSelectionValue: function () {
        this.$('.o_web_studio_selection_input').val("").focus();
    },
    /**
     * @private
     */
    _onSave: function () {
        var values = {};
        if (this.type === 'one2many') {
            if (!this.many2one_field.value) {
                this.trigger_up('warning', {title: _t('You must select a related field')});
                return;
            }
            values.relation_field_id = this.many2one_field.value.res_id;
        } else if (_.contains(['many2many', 'many2one'], this.type)) {
            if (!this.many2one_model.value) {
                this.trigger_up('warning', {title: _t('You must select a relation')});
                return;
            }
            values.relation_id = this.many2one_model.value.res_id;
            values.field_description = this.many2one_model.m2o_value;
        } else if (this.type === 'selection') {
            var newSelection = this.$('.o_web_studio_selection_new_value > input').val();
            if (newSelection) {
                this.selection.push([newSelection, newSelection]);
            }
            values.selection = JSON.stringify(this.selection);
        } else if (this.type === 'related') {
            var selectedField = this.fieldSelector.getSelectedField();
            if (!selectedField) {
                this.trigger_up('warning', {title: _t('You must select a related field')});
                return;
            }
            values.string = selectedField.string;
            values.model = selectedField.model;
            values.related = this.fieldSelector.chain.join('.');
            values.type = selectedField.type;
            values.readonly = true;
            values.copy = false;
            values.store = selectedField.store;
            if (_.contains(['many2one', 'many2many'], selectedField.type)) {
                values.relation = selectedField.relation;
            } else if (selectedField.type === 'one2many') {
                values.relational_model = selectedField.model;
            } else if (selectedField.type === 'selection') {
                values.selection = selectedField.selection;
            } else if (selectedField.type === 'monetary') {
                // find the associated currency field on the related model in
                // case there is no currency field on the current model
                var currencyField = _.find(_.last(this.fieldSelector.pages), function (el) {
                    return el.name === 'currency_id' || el.name === 'x_currency_id';
                });
                if (currencyField) {
                    var chain = this.fieldSelector.chain.slice();
                    chain.splice(chain.length - 1, 1, currencyField.name);
                    values._currency = chain.join('.');
                }
            }

            if (_.contains(['one2many', 'many2many'], selectedField.type)) {
                values.store = false;
            }
        }
        this.trigger('field_default_values_saved', values);
    },
    /**
     * @private
     * @param {Event} ev
     */
    _onSelectionInputBlur: function (ev) {
        var $input = $(ev.currentTarget);
        var val = $input.closest('li').data('value');
        var index = _.findIndex(this.selection, function (el) { return el[0] === val; });
        this.selection[index][1] = $input.val();
        this.renderElement();
    },
});

return NewFieldDialog;

});
;

/********************************************************************
*  Filepath: /web_studio/static/src/legacy/js/common/xml_editor.js  *
*  Bundle: web_studio.studio_assets                                 *
*  Lines: 63                                                        *
********************************************************************/
odoo.define('web_studio.XMLEditor', function (require) {
'use strict';

var AceEditor = require('web_editor.ace');

/**
 * Extend the default view editor so that views are saved thanks to web studio and not
 * default RPC. Also notifies studio when the editor is closed.
 */
return AceEditor.extend({

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    /**
     * @override
     */
    do_hide: function () {
        this.trigger_up("close_xml_editor");
        this._super.apply(this, arguments);
    },

    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------

    /**
     * @override
     */
    _isCustomResource(resID) {
        if (this.currentType === "xml") {
            return _.str.startsWith(this.views[resID].xml_id, 'studio_customization');
        } else {
            return this._super(...arguments);
        }
    },
    /**
     * @override
     */
    _saveView: function (session) {
        var self = this;
        var view = this.views[session.id];
        var old_arch = view.arch;
        var new_arch = session.text;

        return new Promise(function (resolve, reject) {
            self.trigger_up('save_xml_editor', {
                view_id: session.id,
                old_arch: old_arch,
                new_arch: new_arch,
                on_success: function () {
                    self._toggleDirtyInfo(session.id, "xml", false);
                    view.arch = new_arch;
                    resolve();
                },
                on_fail: reject,
            });
        });
    },
});

});
;

/************************************************************************
*  Filepath: /web_studio/static/src/legacy/js/reports/report_editor.js  *
*  Bundle: web_studio.studio_assets                                     *
*  Lines: 787                                                           *
************************************************************************/
odoo.define('web_studio.ReportEditor', function (require) {
"use strict";

var core = require('web.core');
var Widget = require('web.Widget');

var EditorMixin = require('web_studio.EditorMixin');

var _t = core._t;

var ReportEditor = Widget.extend(EditorMixin, {
    template: 'web_studio.ReportEditor',
    nearest_hook_tolerance: 500,
    events: _.extend({}, Widget.prototype.events, {
        'click': '_onClick',
    }),

    /**
     * @override
     *
     * @param {Widget} parent
     * @param {Object} params
     * @param {Object} params.nodesArchs
     * @param {String} params.reportHTML
     * @param {Object} [params.paperFormat]
     */
    init: function (parent, params) {
        this._super.apply(this, arguments);

        this.nodesArchs = params.nodesArchs;
        this.reportHTML = params.reportHTML;

        this.paperFormat = params.paperFormat || {};

        this.$content = $();
        this.$noContentHelper = $();

        this.selectedNode = null;
        this.$targetHighlight = $();

        this.$dropZone = $();
        this._onUpdateContentId = _.uniqueId('_processReportPreviewContent');
        this.isDragging = false;
    },
    /**
     * @override
     */
    start: function () {
        this.$iframe = this.$('iframe');
        this.$iframe.one('load', this._updateContent.bind(this));
        return this._super.apply(this, arguments);
    },
    /**
     * @override
     */
    destroy: function () {
        window.top[this._onUpdateContentId] = null;
        delete window.top[this._onUpdateContentId];
        if (this.$content) {
            this.$content.off('click');
            this.$content.off('load');
        }
        return this._super.apply(this, arguments);
    },
    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    /**
     * Start dragging the component, notify that no cleanup should occur
     * because a drag operation is ongoing.
     */
    beginDragComponent: function (component) {
        this.isDragging = true;
        if (this.$content.find('.o_web_studio_hook').length === 0) {
            // for the case where computing the hooks takes long and
            // the user is too fast with the mouse
            this._prepareHooksOnIframeBeforeDrag(component);
        }
    },
    beginPreviewDragComponent: function (component) {
        if (this.isDragging) {
            return;
        }
        this._prepareHooksOnIframeBeforeDrag(component);
    },
    /**
    * Insert Studio hooks in the dom iframe, according to which building block
    * is being dragged.
    *
    * @param {Component} component the building block being dragged
    */
    _prepareHooksOnIframeBeforeDrag: function (component) {
        var self = this;

        this._cleanHooks();
        this.$noContentHelper.remove();

        var dropIn = component.dropIn;
        if (component.dropColumns && component.addEmptyRowsTargets) {
            dropIn = (dropIn ? dropIn + ',' : '') + '.page > .row > div:empty';
        }
        if (dropIn) {
            var inSelectors = dropIn.split(component.selectorSeparator || ',');
            _.each(inSelectors, function (selector) {
                var $target = self.$content.find(selector + "[data-oe-xpath]");
                _.each($target, function (node) {
                    if (!$(node).data('node')) {
                        // this is probably a template not present in
                        // reportViews so no hook should be attached to it
                        // TODO: should the corresponding view be branded
                        // (server-side) in this case (there won't be any
                        // data-oe-xpath then)?
                        return;
                    }
                    self._createHookOnNodeAndChildren($(node), component);
                });
            });
        }
        if (component.dropColumns) {
            // when dropping the component, it should have a specific (bootstrap) column structure
            // we will create this structure or complete it if it already exist
            var $hook = self._createHook($('<div/>'), component);
            var $gridHooks = $('<div class="row o_web_studio_structure_hook"/>');
            _.each(component.dropColumns, function (column, index) {
                var $col = $('<div class="offset-' + column[0] + ' col-' + column[1] + '"/>');
                $col.append($hook.clone().attr('data-oe-index', index));
                $gridHooks.append($col);
            });

            var $page = this.$content.find('.page');
            var $children = $page.children().not('.o_web_studio_hook,p:not([data-oe-id])');

            if ($children.length) {
                $gridHooks.find('.o_web_studio_hook').data('oe-node', $children.first()).data('oe-position', 'before');
                $children.first().before($gridHooks);

                _.each($children, function (child) {
                    var $child = $(child);
                    var $newHook = $gridHooks.clone();
                    $newHook.find('.o_web_studio_hook').data('oe-node', $child).data('oe-position', 'after');
                    $child.after($newHook);
                });
            } else {
                $gridHooks.find('.o_web_studio_hook').data('oe-node', $page).data('oe-position', 'inside');
                $page.prepend($gridHooks);
            }

            this.$content.find('.o_web_studio_structure_hook + .o_web_studio_hook').remove();
            this.$content.find('.o_web_studio_structure_hook').prev('.o_web_studio_hook').remove();
        }
        this.$content.find('.o_web_studio_hook + .o_web_studio_hook').remove();
        this.$dropZone = this.$content.find('.o_web_studio_hook');

        this.$dropZoneStructure = this.$content.find('.o_web_studio_structure_hook');
        this.$dropZoneStructure.removeClass('.o_web_studio_nearest').each(function () {
            $(this).children().children('.o_web_studio_hook:only-child').data('height', $(this).height() + 'px');
        });

        // compute the size box with the nearest rendering
        this._computeNearestHookAndShowIt();

        // association for td and colspan
        this.$dropZone.filter('th, td').each(function (_, item) {
            var $item = $(item);
            var $node = $item.data('oe-node');
            var colspan = +$node.data('colspan');
            if (colspan > 1) {
                $node.attr('colspan', colspan * 2 - 1);
            }
        });
    },
    /**
     * When a component is being dragged in the iframe, this function computes
     * which Studio hook(s) are the nearest.
     *
     * @param {Component} component
     * @param {integer} x
     * @param {integer} y
     */
    dragComponent: function (component, x, y) {
        this.isDragging = true;
        this.$dropZone
            .filter('.o_web_studio_nearest_hook')
            .removeClass('o_web_studio_nearest_hook')
            .closest(this.$dropZoneStructure).each(function () {
                $(this).children().css('height', '').children('.o_web_studio_hook:only-child').css('height', '');
            });

        this.$dropZoneStructure.removeClass('o_web_studio_nearest');

        var bound = this.$iframe[0].getBoundingClientRect();
        var isInIframe = (x >= bound.left && x <= bound.right) && (y >= bound.top && y <= bound.bottom);
        if (!isInIframe) {
            return;
        }

        // target with position of the box center
        _.each(this.dropPosition, function (box) {
            box.dist = Math.sqrt(Math.pow(box.centerY - (y - bound.top), 2) + Math.pow(box.centerX - (x - bound.left), 2));
        });
        this.dropPosition.sort(function (a, b) {
            return a.dist - b.dist;
        });

        if (!this.dropPosition[0] || this.dropPosition[0].dist > this.nearest_hook_tolerance) {
            return;
        }

        var $nearestHook = $(this.dropPosition[0].el);

        $nearestHook
            .addClass('o_web_studio_nearest_hook')
            .closest(this.$dropZoneStructure)
            .addClass('o_web_studio_nearest');

        if (!$nearestHook.data('oe-node') || !$nearestHook.data('oe-node').data('oe-id')) {
            return;
        }

        var $node = $nearestHook.data('oe-node');
        var id = $node.data('oe-id');
        var xpath = $node.data('oe-xpath');
        var position = $nearestHook.data('oe-position');
        var index = $nearestHook.data('oe-index');

        var td = $node.is('td, th');
        var reg, replace;
        if (td) {
            reg = /^(.*?)\/(thead|tbody|tfoot)(.*?)\/(td|th)(\[[0-9]+\])?/;
            replace = td && position === 'inside' ? '$1/$2/tr/td' : '$1/tr/td';
            xpath = xpath.replace(reg, replace);
        }

        // select all dropzone with the same xpath
        var $nearestHooks = this.$dropZone.filter(function () {
            var $hook = $(this);
            var $node = $hook.data('oe-node');
            return $hook.data('oe-position') === position &&
                $hook.data('oe-index') === index &&
                $node.data('oe-id') === id &&
                (td ? $node.data('oe-xpath').replace(reg, replace) : $node.data('oe-xpath')) === xpath;
        });

        if (td) {
            var pos = $nearestHook.data('oe-node').data('td-position-' + (position === 'before' ? 'before' : 'after'));
            $nearestHooks = $nearestHooks.filter(function () {
                var $node = $(this).data('oe-node');
                return $node.data('td-position-' + (position === 'before' ? 'before' : 'after')) === pos;
            });
        }

        $nearestHooks.addClass('o_web_studio_nearest_hook');
    },
    /**
     * When a component has been dropped in the iframe, we genrate the changes
     * in the view and clean the hooks.
     *
     * @param {Component} component
     */
    dropComponent: function (component) {
        this.isDragging = false;
        var $nearestHooks = this.$dropZone.filter('.o_web_studio_nearest_hook');
        var targets = [];

        // targets need to contain all the targets that are unique (oe-id, oe-xpath)
        $nearestHooks.get().forEach(function (nearHook) {
            var $active = $(nearHook);
            var alreadyAdded = false;
            var nodeData = $active.data('oe-node').data('node');

            for (var i = 0; i < targets.length; i++) {
                if (targets[i].node.attrs['data-oe-id'] === nodeData.attrs['data-oe-id'] &&
                    targets[i].node.attrs['data-oe-xpath'] === nodeData.attrs['data-oe-xpath']) {
                    alreadyAdded = true;
                }
            }
            if (!alreadyAdded) {
                targets.push({
                    node: nodeData,
                    position: $active.data('oe-position'),
                    data: $active.data(),
                });
            }
        });

        if (targets.length) {
            this.trigger_up('view_change', {
                component: component,
                fail: this._cleanHooks.bind(this),
                targets: targets,
                operation: {
                    type: 'add',
                    position: $nearestHooks.first().data('oe-position'),
                },
            });
        } else {
            this._cleanHooks();
        }
    },

    endPreviewDragComponent: function (component) {
        this._cleanHooks();
    },
    /**
     * Get the context associated to a node.
     *
     * @param {Object} initialNode
     * @returns {Object}
     */
    getNodeContext: function (initialNode) {
        var node = initialNode;
        var $nodes = this._findAssociatedDOMNodes(node);
        while (!$nodes.length && node.parent) {
            var index = node.parent.children.indexOf(node);
            for (index; index > 0; index--) {
                $nodes = this._findAssociatedDOMNodes(node.parent.children[index]);
                if ($nodes.length) {
                    break;
                }
            }
            if (!$nodes.length) {
                node = node.parent;
            }
        }
        if (!$nodes.length) {
            $nodes = this.$content.find('*[data-oe-xpath]');
        }

        return $nodes.data('oe-context');
    },
    /**
     * Highlight (shows a red arrow on) a DOM node.
     *
     * @param {Object} node
     */
    highlight: function (node) {
        if (!this.$highlight) {
            // an arrow that helps understanding which DOM element is being edited
            this.$highlight = $('<span class="o_web_studio_report_highlight"/>');
            this.$content.find('body').prepend(this.$highlight);
        }

        if (this.$targetHighlight.data('node') !== this.selectedNode) {
            // do not remove the highlight on the clicked node
            this.$targetHighlight.removeClass('o_web_studio_report_selected');
        }

        var $nodes = this._findAssociatedDOMNodes(node);
        if ($nodes && $nodes.length) {
            this.$targetHighlight = $nodes.addClass('o_web_studio_report_selected');
            var position = this.$targetHighlight.offset();
            this.$highlight
                .css({
                    top: position.top + 'px',
                    left: position.left + 'px',
                    bottom: position.top < 50 ? '0' : 'auto',
                })
                .toggleClass('o_web_studio_report_highlight_left', position.left < 50)
                .toggleClass('o_web_studio_report_highlight_top', position.top < 50)
                .show();
        } else {
            this.$highlight.hide();
        }
    },
    /**
     * Selects the given node if it's not already selected and deselects
     * previously selected one.
     *
     * @private
     * @param {Object} node
     */
    selectNode: function (node) {
        if (this.selectedNode) {
            if (this.selectedNode === node) {
                return;
            }
            var $oldSelectedNodes = this._findAssociatedDOMNodes(this.selectedNode);
            $oldSelectedNodes.removeClass('o_web_studio_report_selected');
        }

        this.selectedNode = node;
        var $nodesToHighlight = this._findAssociatedDOMNodes(this.selectedNode);
        $nodesToHighlight.addClass('o_web_studio_report_selected');
    },
    /**
     * @override
     */
    unselectedElements: function () {
        var $nodes = this._findAssociatedDOMNodes(this.selectedNode);
        $nodes.removeClass('o_web_studio_report_selected');
        this.selectedNode = null;
    },
    /**
     * Update the iframe content with a new HTML description.
     *
     * @param {Object} nodesArchs
     * @param {String} reportHTML
     * @returns {Promise}
     */
    update: function (nodesArchs, reportHTML) {
        var self = this;
        this.nodesArchs = nodesArchs;
        this.reportHTML = reportHTML;

        this.$dropZone = $();

        return this._updateContent().then(function () {
            if (self.selectedNode) {
                var $nodes = self._findAssociatedDOMNodes(self.selectedNode);
                if ($nodes.length) {
                    $nodes.first().click();
                } else {
                    self.selectedNode = null;
                    self.trigger_up('sidebar_tab_changed', {
                        mode: 'new',
                    });
                }
            }
        });
    },

    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------

    /**
     * Clean displayed hooks and reset colspan on modified nodes.
     *
     * @private
     */
    _cleanHooks: function () {
        if (this.isDragging) {
            return;
        }

        this.$dropZone.filter('th, td').each(function () {
            var $node = $(this).data('oe-node');
            if ($node) {
                var colspan = $node.data('colspan');
                if (colspan) {
                    $node.attr('colspan', colspan);
                }
            }
        });
        this.$content.find('.o_web_studio_hook').remove();
        this.$content.find('.o_web_studio_structure_hook').remove();

        this._setNoContentHelper();
    },
    /**
     * Create hook on target and compute its size.
     *
     * @private
     * @param {jQuery} $node report dom node that should be hooked onto
     * @param {Object} sidebar component currently being dragged
     */
    _createHookOnNodeAndChildren: function ($node, component) {
        var $hook = this._createHook($node, component);
        var $newHook = $hook.clone();
        var $children = $node.children()
            .not('.o_web_studio_hook,p:not([data-oe-id])')

        // display the hook with max height of this sibling
        if ($children.length === 1 && $children.is('td[colspan="99"]')) {
            return;
        }
        if ($children.length) {
            if (component.hookAutoHeight) {
                var height = Math.max.apply(Math, $children.map(function () { return $(this).height(); }));
                $newHook.data('height', height + 'px');
                $newHook.css('height', height + 'px');
            }
            $newHook.data('oe-node', $children.first()).data('oe-position', 'before');
            $children.first().before($newHook);

            $children.each(
                /* allows to drop besides each children */
                function (_, childNode) {
                    var $childNode = $(childNode);
                    var $newHook = $hook.clone().data('oe-node', $childNode).data('oe-position', 'after');
                    if (component.hookAutoHeight) {
                        $newHook.data('height', height + 'px');
                        $newHook.css('height', height + 'px');
                    }
                    $childNode.after($newHook);
                });
        } else if ($node.text() &&
                    $node[0].tagName.toLowerCase() !== 'th' &&
                    $node[0].tagName.toLowerCase() !== 'td') {
                    // in tables, we cannot add span hooks else it breaks the layout
            if (component.hookAutoHeight) {
                $newHook.data('height', $node.height() + 'px');
                $newHook.css('height', $node.height() + 'px');
            }
            $node.before($newHook.clone().data('oe-node', $node).data('oe-position', 'before'));
            $node.after($newHook.clone().data('oe-node', $node).data('oe-position', 'after'));
        }
        else {
            $newHook.data('oe-node', $node).data('oe-position', 'inside');
            $node.append($newHook);
        }
    },
    _computeNearestHookAndShowIt: function () {
        var self = this;
        this.dropPosition = [];
        var dropZone = this.$dropZone.get();
        dropZone.reverse();
        _.each(dropZone, function (node) {
            var $node = $(node);
            var box = node.getBoundingClientRect();
            box.el = node;
            box.centerY = (box.top + box.bottom) / 2;
            box.centerX = (box.left + box.right) / 2;
            self.dropPosition.push(box);
        });
    },
    /**
     * Recursively parses the DOM of the report and add the `data` and `attributes` on every DOM nodes,
     * according to the qWeb template that generated the report.
     *
     * After this function, every node in the DOM and in memory will have access to their context
     *
     * @private
     */
    _connectNodes: function () {
        var self = this;
        var nodesNotInView = [];

        function connectNodes(node) {
            if (!node.attrs) {
                return;
            }
            var $nodes = self._findAssociatedDOMNodes(node);
            $nodes.data('node', node);
            node.$nodes = $nodes;
            if ($nodes.length) {
                node.context = $nodes.data('oe-context');
            } else {
                nodesNotInView.push(node);
            }

            _.each(node.attrs, function (value, key) {
                if ($nodes.attr(key) === undefined) {
                    $nodes.attr(key, value);
                }
            });
            _.each(node.children, connectNodes);
        }
        _.each(this.nodesArchs, connectNodes);


        function connectContextOrder(dom, contextOrder) {
            var $node = $(dom);
            var newOrder = contextOrder.slice();
            var node = $node.data('node');

            if (node) {
                if (node.contextOrder) {
                    return node.contextOrder;
                }
                newOrder = node.contextOrder = _.uniq(contextOrder.concat(_.keys(node.context)));
            }

            var children = $node.children().get();
            for (var k = 0; k < children.length; k++) {
                newOrder = connectContextOrder(children[k], newOrder);
            }
            return newOrder;
        }

        var children = this.$content.children().get();
        for (var k = 0; k < children.length; k++) {
            connectContextOrder(children[k], []);
        }

        var bodyContext = this.$content.find('html').data('oe-context');
        _.each(nodesNotInView, function (node) {
            node.context = node.parent && node.parent.context || bodyContext;
        });
    },
    /**
     * @private
     * @param {jQuery} $target
     * @param {Component} component
     * @returns {jQuery}
     */
    _createHook: function ($target, component) {
        var firstChild = $target.children().get(0);
        var hookTag = ((firstChild && firstChild.tagName) || 'div').toLocaleLowerCase();
        if (!$target.is('tr') && component.hookTag) {
            hookTag = component.hookTag;
        }
        if (hookTag === 'table') {
            hookTag = 'div';
        }
        var $hook = $('<' + hookTag + ' class="o_web_studio_hook"/>');
        if ($target.hasClass('row')) {
            $hook.addClass('col-3');
        }
        if (component.hookClass) {
            $hook.addClass(component.hookClass);
        }
        return $hook;
    },
    /**
     * finds all the DOM nodes that share the same context as the node in parameter.
     * Example, all the cells of the same column are sharing the same context: they come from the same report template.
     *
     * @private
     * @param {Object} node qWeb node
     * @returns {jQuery} associated DOM nodes
     */
    _findAssociatedDOMNodes: function (node) {
        if (node) {
            return this.$content.find('[data-oe-id="' + node.attrs['data-oe-id'] + '"][data-oe-xpath="' + node.attrs['data-oe-xpath'] + '"]');
        } else {
            return $();
        }
    },
    /**
     * takes the content of the report preview (in the iframe) to
     * - adds all the node meta-data
     * - ensure its size is correct
     * - add meta-data about colspan to make the drag&drop easier
     * @private
     */
    _processReportPreviewContent: function () {
        this.$content = this.$('iframe').contents();
        this.$content.off('click').on('click', this._onContentClick.bind(this));
        this._connectNodes();
        this.$('.o_web_studio_loader').hide();
        this._resizeIframe();

        // association for td and colspan
        this.$content.find('tr').each(function () {
            var $tr = $(this);
            var $tds = $tr.children();
            var lineMax = 0;
            $tds.each(function () {
                var $td = $(this);
                var colspan = +$td.attr('colspan');
                $td.data('colspan', colspan || 1);
                $td.data('td-position-before', lineMax);
                lineMax += colspan || 1;
                $td.data('td-position-after', lineMax);
            });
        });

        this._setNoContentHelper();
    },
    /**
     * @private
     */
    _resizeIframe: function () {
        var self = this;
        // zoom content from 96 (default browser DPI) to paperformat DPI
        var zoom = 96 / this.paperFormat.dpi;
        self.$content.find('main:first').children().each(function () {
            // scale each section to fit DPI
            var sectionZoom = zoom;
            if (!self.paperFormat.disable_shrinking) {
                // check if needs shrinking to fit page (wkhtmltopdf enable-smart-shrinking)
                // only applies if option is not manually disabled on the paperformat (see 'disable_shrinking')
                sectionZoom = Math.min(zoom, $(this).width() / this.scrollWidth);
            }
            $(this).css({zoom: sectionZoom});
        });
        // WHY --> so that after the load of the iframe, if there are images,
        // the iframe height is recomputed to the height of the content images included
        self.$iframe[0].style.height = self.$iframe[0].contentWindow.document.body.scrollHeight + 'px';

        // TODO: it seems that the paperformat doesn't exactly do that
        // this.$content.find('.header').css({
        //     'margin-bottom': (this.paperFormat.header_spacing || 0) + 'mm',
        // });
        // TODO: won't be pretty if the content is larger than the format
        this.$content.find('.footer').css({
            'position': 'fixed',
            'bottom': '0',
            'width': this.$content.find('.page').css('width'),
        });

        this.$content.find('html')[0].style.overflow = 'hidden';

        // set the size of the iframe
        $(this.$content).find("img").on("load", function () {
            self.$iframe[0].style.height = self.$iframe[0].contentWindow.document.body.scrollHeight + 'px';
        });
    },
    /**
     * @private
     */
    _setNoContentHelper: function () {
        var $page = this.$content.find('div.page');
        if ($page.length && !$page.children().length) {
            this.$noContentHelper = $('<div/>', {
                class: 'o_no_content_helper',
                text: _t('Drag building block here'),
            });
            $page.append(this.$noContentHelper);
        }
    },
    /**
     * Update the iframe content.
     *
     * @private
     * @returns {Promise}
     */
    _updateContent: function () {
        var self = this;
        this.$content = this.$iframe.contents();
        var reportHTML = this.reportHTML;

        var $main = this.$content.find('main:first');
        if ($main.length) {
            $main.replaceWith($(reportHTML).find('main:first'));
            this._processReportPreviewContent();
            return Promise.resolve();
        }

        return new Promise(function (resolve, reject) {
            window.top[self._onUpdateContentId] = function () {
                if (!self.$('iframe')[0].contentWindow) {
                    return reject();
                }
                self._processReportPreviewContent();
                self.trigger_up('iframe_ready');
                resolve();
            };
            if (reportHTML.error) {
                self.displayNotification({
                    message: _.str.sprintf(
                        _t('This report could not be previewed or edited because it could not be rendered with this message: %s. This could be happening because this is a custom report type that needs custom data to be rendered and so is not editable by studio.'),
                        reportHTML.message
                    ), type: 'danger' });
            } else {
                // determine when the body has been inserted
                reportHTML = reportHTML.replace(
                    '</body>',
                    '<script>window.top.' + self._onUpdateContentId + '()</script></body>'
                );
            }

            // inject HTML
            var cwindow = self.$iframe[0].contentWindow;
            cwindow.document
                .open("text/html", "replace")
                .write(reportHTML);
        });
    },
    //--------------------------------------------------------------------------
    // Handlers
    //--------------------------------------------------------------------------

    /**
     * @private
     */
    _onClick: function () {
        this.trigger_up('editor_clicked');
    },
    /**
     * @private
     * @param {Event} e
     */
    _onContentClick: function (e) {
        e.preventDefault();
        e.stopPropagation();

        if ($(e.target).hasClass('o_no_content_helper')) {
            return;
        }

        var $node = $(e.target).closest('[data-oe-xpath]');
        if ($node.closest('[t-field], [t-esc]').length) {
            $node = $node.closest('[t-field], [t-esc]');
        }
        this.selectNode($node.data('node'));
        this.trigger_up('node_clicked', {
            node: this.selectedNode,
        });
    },
});

return ReportEditor;

});
;

/*******************************************************************************
*  Filepath: /web_studio/static/src/legacy/js/reports/report_editor_fields.js  *
*  Bundle: web_studio.studio_assets                                            *
*  Lines: 130                                                                  *
*******************************************************************************/
odoo.define('web_studio.report_fields', function (require) {
"use strict";

var fieldRegistry = require('web.field_registry');
var relationalFields = require('web.relational_fields');

/**
 * This widget is used only for rendering by the report editor (the widget options)
 *
 */


var FieldMany2ManySelection = relationalFields.FieldMany2ManyTags.extend({
    init: function (parent, name, record, options) {
        this._super.apply(this, arguments);

        options.quick_create = false;
        options.can_create = false;

        this.selection = _.map(options.attrs.selection, function (s) {
            return {id: s.field_name, res_id: s.field_name, data: {id: s.field_name, display_name: s.label}};
        });
    },
    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------

    /**
     * @override
     * @private
     * @param {Moment|false} value
     * @returns {boolean}
     */
    _isSameValue: function (value) {
        if (value === false) {
            return this.value === false;
        }
        return value.length === this.value.res_ids.length &&
            _.difference(value, this.value.res_ids).length === 0;
    },
    /**
     * Defines an _search method for the internal m2o.
     *
     * @private
     * @param {string} search_val
     * @returns {Object[]}
     */
    _many2oneSearch: function (search_val) {
        var self = this;
        var records = _.filter(_.pluck(this.selection, 'data'), function (r) {
            return r.display_name.indexOf(search_val) !== -1 &&
               !_.findWhere(self.value.data, {id: r.id});
        });
        return _.map(records, function (r) {
            return {
                id: r.id,
                label: r.display_name,
                name: r.display_name,
                value: r.display_name,
            };
        });
    },
    /**
     *
     * @overwrite
     */
    _render: function () {
        var self = this;
        var res_ids = this.value.res_ids;
        this.value.data = _.filter(this.selection, function (s) {
            return res_ids.indexOf(s.id) !== -1;
        });
        return this._super.apply(this, arguments).then(function () {
            if (self.many2one) {
                self.many2one._autocompleteSources = [];
                self.many2one._addAutocompleteSource(self._many2oneSearch.bind(self), {});
                self.many2one.limit = Object.keys(self.selection).length;
            }
        });
    },
    /**
     *
     * @overwrite
     */
    _setValue: function (value, options) {
        var self = this;
        var selection = this.value.res_ids;

        return new Promise(function (resolve, reject) {
            switch (value.operation) {
                case "ADD_M2M":
                    selection = selection.concat([value.ids.id]);
                    break;
                case "FORGET":
                    selection = _.difference(selection, value.ids);
                    break;
                default: throw Error('Not implemented');
            }

            if (!(options && options.forceChange) && self._isSameValue(selection)) {
                return Promise.resolve();
            }

            self.value.res_ids = selection;
            self._render();

            self.trigger_up('field_changed', {
                dataPointID: self.dataPointID,
                changes: _.object([self.name], [{
                    operation: 'REPLACE_WITH',
                    ids: selection,
                }]),
                viewType: self.viewType,
                doNotSetDirty: options && options.doNotSetDirty,
                notifyChange: !options || options.notifyChange !== false,
                onSuccess: resolve,
                onFailure: reject,
            });
        });
    },
});

fieldRegistry.add('many2many_select', FieldMany2ManySelection);

return {
    FieldMany2ManySelection: FieldMany2ManySelection,
};

});

;

/********************************************************************************
*  Filepath: /web_studio/static/src/legacy/js/reports/report_editor_manager.js  *
*  Bundle: web_studio.studio_assets                                             *
*  Lines: 532                                                                   *
********************************************************************************/
odoo.define('web_studio.ReportEditorManager', function (require) {
"use strict";

var Dialog = require('web.Dialog');
var Pager = require('web.Pager');
var utils = require('web.utils');
var core = require('web.core');
var session = require('web.session');

var ReportEditorSidebar = require('web_studio.ReportEditorSidebar');
var ReportEditor = require('web_studio.ReportEditor');
var AbstractEditorManager = require('web_studio.AbstractEditorManager');
const { ComponentWrapper, WidgetAdapterMixin } = require('web.OwlCompatibility');

var qweb = core.qweb;
var _t = core._t;

var ReportEditorManager = AbstractEditorManager.extend(WidgetAdapterMixin, {
    className: AbstractEditorManager.prototype.className + ' o_web_studio_report_editor_manager',
    custom_events: _.extend({}, AbstractEditorManager.prototype.custom_events, {
        editor_clicked: '_onEditorClick',
        hover_editor: '_onHighlightPreview',
        node_expanded: '_onNodeExpanded',
        drop_component: '_onDropComponent',
        begin_drag_component: '_onBeginDragComponent',
        element_removed: '_onElementRemoved',
        iframe_ready: '_onIframeReady',
        begin_preview_drag_component: '_onBeginPreviewDragComponent',
        end_preview_drag_component: '_onEndPreviewDragComponent',
        pager_changed: '_onPagerChanged',
    }),
    events: _.extend({}, AbstractEditorManager.prototype.events, {
        'click .o_web_studio_report_print': '_onPrintReport',
    }),
    /**
     * @override
     * @param {Object} params
     * @param {Object} params.env - environment (model and ids)
     * @param {Object} params.models
     * @param {Object} params.report
     * @param {Object} params.reportHTML
     * @param {Object} params.reportMainViewID
     * @param {Object} params.reportViews
     * @param {Object} [params.initialState]
     * @param {string} [params.initialState.sidebarMode] among ['add', 'report']
     * @param {Object} [params.paperFormat]
     * @param {Object} [params.widgetsOptions]
     */
    init: function (parent, params) {
        this._super.apply(this, arguments);

        this.view_id = params.reportMainViewID;

        this.env = params.env;
        this.models = params.models;
        this.report = params.report;
        this.reportHTML = params.reportHTML;
        this.reportName = this.report.report_name;
        this.reportViews = params.reportViews;

        this.initialState = params.initialState || {};
        this.paperFormat = params.paperFormat;
        this.widgetsOptions = params.widgetsOptions;

        this.editorIframeResolved = false;
        var self = this;
        this.editorIframeDef = new Promise(function (resolve, reject) {
            self._resolveEditorIframeDef = resolve;
        }).then(function () {
            self.editorIframeResolved = true;
        });
        const currentMinimum = 1;
        const size = this.env.ids.length;
        const limit = 1;
        this.withPager = size > 1;
        if (this.withPager) {
            // only display the pager if useful
            this.pager = new ComponentWrapper(this, Pager, { currentMinimum, limit, size });
        }
    },
    /**
     * @override
     */
    start: async function () {
        const promises = [this._super(...arguments)];
        if (this.withPager) {
            const pagerPromise = this.pager.mount(document.createDocumentFragment());
            promises.push(pagerPromise);
        }
        await Promise.all(promises);
        this._renderActionsSection();
        this._setPaperFormat();
    },
    /**
     * @override
     */
    destroy: function () {
        WidgetAdapterMixin.destroy.apply(this, arguments);
        return this._super.apply(this, arguments);
    },
    /**
     * @override
     */
    on_attach_callback: function () {
        this._super.apply(this, arguments);
        WidgetAdapterMixin.on_attach_callback.apply(this, arguments);
    },
    /**
     * @override
     */
    on_detach_callback: function () {
        this._super.apply(this, arguments);
        WidgetAdapterMixin.on_detach_callback.apply(this, arguments);
    },

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    /**
     * @override
     */
    updateEditor: function () {
        var nodesArchs = this._computeView(this.reportViews);
        return this.view.update(nodesArchs, this.reportHTML);
    },

    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------

    /**
     * @override
     */
    _applyChangeHandling: function (result, opID, from_xml) {
        var self = this;

        if (result.report_html.error) {
            // the operation can't be applied
            var error = result.report_html.message
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
            var msg = '<pre>' + error + '</pre>';
            this.displayNotification({ title: _t("Error when compiling AST"), message: msg, sticky: true, type: 'danger' });
            return this._undo(opID, true).then(function () {
                return Promise.reject();
            });
        }

        // TODO: what should we do with result? Maybe update the studio_view_id
        // if one has been created?
        if (!from_xml) {
            // reset studio_arch as it was before the changes for applying
            // the next operations
            _.each(result.views, function (view) {
                if (view.studio_view_id) {
                    view.studio_arch = self.reportViews[view.view_id].studio_arch;
                }
            });
        }
        this.reportViews = result.views;
        this.reportHTML = result.report_html;

        return this.updateEditor();
    },
    /**
     * @private
     * @param {Object} views
     * @returns {Object}
     */
    _computeView: function (views) {
        // TODO: find a better name
        var nodesArchs = _.mapObject(views, function (view, id) {
            var doc = $.parseXML(view.arch).documentElement;
            // first element child because we don't want <template> node
            if (!doc.hasAttribute('t-name')) {
                doc = doc.firstElementChild;
            }
            var node = utils.xml_to_json(doc, true);
            node.id = +id;
            node.key = view.key;
            return node;
        });

        this._setParentKey(nodesArchs);

        return nodesArchs;
    },
    /**
     * @override
     */
    _editView: function (view_id, studio_view_arch, operations) {
        core.bus.trigger('clear_cache');
        return this._rpc({
            route: '/web_studio/edit_report_view',
            params: {
                record_id: this.env.currentId,
                report_name: this.reportName,
                report_views: this.reportViews,
                operations: operations,
                context: session.user_context,
            },
        });
    },
    /**
     * @override
     */
    _editViewArch: function (view_id, view_arch) {
        core.bus.trigger('clear_cache');
        return this._rpc({
            route: '/web_studio/edit_report_view_arch',
            params: {
                record_id: this.env.currentId,
                report_name: this.reportName,
                view_id: view_id,
                view_arch: view_arch,
                context: session.user_context,
            },
        });
    },
    /**
     * @private
     * @param {Object} node
     * @returns {Object} first lonely node
     */
    _getNodeToDelete: function (node) {
        var result = node;
        while (
            result.parent &&
            result.parent.children.length === 1 &&  // last child
            result.attrs['data-oe-id'] === result.parent.attrs['data-oe-id'] &&  // same view
            (!result.attrs.class || result.attrs.class.indexOf('page') !== -1)  // cannot delete .page
        ) {
            result = result.parent;
        }
        return result;
    },
    /**
     * @private
     * @returns {Promise<Object>}
     */
    _getReportViews: function () {
        return this._rpc({
            route: '/web_studio/get_report_views',
            params: {
                record_id: this.env.currentId,
                report_name: this.reportName,
                context: session.user_context,
            },
        });
    },
    /**
     * @override
     */
    _instantiateEditor: function () {
        var nodesArchs = this._computeView(this.reportViews);
        this.view = new ReportEditor(this, {
            nodesArchs: nodesArchs,
            paperFormat: this.paperFormat,
            reportHTML: this.reportHTML,
        });
        return Promise.resolve(this.view);
    },
    /**
     * @override
     */
    _instantiateSidebar: function (state, previousState) {
        state = _.defaults(state || {}, {
            mode: this.initialState.sidebarMode || 'new',
        });
        return new ReportEditorSidebar(this, {
            report: this.report,
            widgetsOptions: this.widgetsOptions,
            models: this.models,
            state: state,
            previousState: previousState,
            paperFormat: this.paperFormat,
        });
    },
    /**
     * This section contains the 'Print' button and the pager.
     *
     * @private
     */
    _renderActionsSection: async function () {
        const actionsSection = Object.assign(document.createElement('div'), {
            className: 'o_web_studio_report_actions',
            innerHTML: qweb.render('web_studio.PrintSection'),
        });
        this.el.appendChild(actionsSection);

        if (this.withPager) {
            const pagerContainer = Object.assign(document.createElement('div'), {
                className: 'o_web_studio_report_pager',
            });
            pagerContainer.appendChild(this.pager.el);
            actionsSection.append(pagerContainer);
        }
    },
    /**
     * @private
     * @param {Object} nodesArchs
     */
    _setParentKey: function (nodesArchs) {
        function setParent(node, parent) {
            if (_.isObject(node)) {
                node.parent = parent;
                _.each(node.children, function (child) {
                    setParent(child, node);
                });
            }
        }
        _.each(nodesArchs, function (node) {
            setParent(node, null);
        });
    },
    /**
     * @private
     */
    _setPaperFormat: function () {
        var format = this.paperFormat || {};

        var $container = this.$('.o_web_studio_report_iframe_container');
        $container.css({
            'padding-top': Math.max(0, (format.margin_top || 0) - (format.header_spacing || 0)) + 'mm',
            'padding-left': (format.margin_left || 0) + 'mm',
            'padding-right': (format.margin_right || 0) + 'mm',
            // note: default width/height comes from default A4 size
            'width': (format.print_page_width || 210) + 'mm',
            // avoid a scroll bar with a fixed height
            'min-height': (format.print_page_height || 297) + 'mm',
        });

        this.$('.o_web_studio_report_iframe').css({
            // to remove
            'min-height': (format.print_page_height || 297) + 'mm',
            // 'max-height': document.body.scrollHeight + 'px',
        });
    },

    //--------------------------------------------------------------------------
    // Handlers
    //--------------------------------------------------------------------------

    /**
     * @private
     * @param {OdooEvent} ev
     */
    _onBeginDragComponent: function (ev) {
        this.view.beginDragComponent(ev.data.widget);
    },
    /**
     * @private
     * @param {OdooEvent} ev
     */
    _onBeginPreviewDragComponent: function (ev) {
        this.view.beginPreviewDragComponent(ev.data.widget);
    },
    /**
     * @override
     */
    _onDragComponent: function (ev) {
        var position = ev.data.position;
        this.view.dragComponent(ev.data.widget, position.pageX, position.pageY);
    },
    /**
     * @private
     * @param {OdooEvent} ev
     */
    _onDropComponent: function (ev) {
        this.view.dropComponent(ev.data.widget);
    },
    /**
     * @private
     */
    _onEditorClick: function () {
        this.view.unselectedElements();
    },
    /**
     * @private
     * @param {OdooEvent} ev
     */
    _onElementRemoved: function (ev) {
        var self = this;
        var node = this._getNodeToDelete(ev.data.node);
        var message = _.str.sprintf(_t('Are you sure you want to remove this %s from the view?'), node.tag);

        Dialog.confirm(this, message, {
            confirm_callback: function () {
                self.trigger_up('view_change', {
                    node: node,
                    operation: {
                        type: 'remove',
                        structure: 'remove',
                    },
                });
            },
        });
    },
        /**
     * @private
     * @param {OdooEvent} ev
     */
    _onEndPreviewDragComponent: function (ev) {
        this.view.endPreviewDragComponent(ev.data.widget);
    },
    /**
     * @private
     * @param {OdooEvent} ev
     */
    _onHighlightPreview: function (ev) {
        this.view.highlight(ev.data.node);
    },
    /**
     * @private
     * @param {OdooEvent} ev
     */
    _onNodeExpanded: function (ev) {
        this.view.selectNode(ev.data.node);
    },
    /**
     * @private
     */
    _onIframeReady: function () {
        this._resolveEditorIframeDef();
    },
    /**
     * @override
     */
    _onNodeClicked: function (ev) {
        var node = ev.data.node;

        if (node) {
            var currentNode = node;
            var sidebarNodes = [];
            while (currentNode) {
                sidebarNodes.push({
                    node: currentNode,
                    context: this.view.getNodeContext(currentNode),
                });
                currentNode = currentNode.parent;
            }
            this.sidebar.state = {
                mode: 'properties',
                nodes: sidebarNodes,
            };
        } else {
            this.sidebar.state = {
                mode: 'new',
            };
        }
        // TODO: this should probably not be done like that (setting state on
        // sidebar) but pass paramaters to _updateSidebar instead.
        this._updateSidebar();
    },
    /**
     * @private
     */
    _onPagerChanged: async function (ev) {
        const { currentMinimum, limit } = ev.data;
        this._cleanOperationsStack();
        this.env.currentId = this.env.ids[currentMinimum - 1];
        // TODO: maybe we should trigger_up and the action should handle
        // this? But the pager will be reinstantiate and useless RPCs will
        // be done (see willStart)
        // OR should we put _getReportViews of report_editor_action here?
        // But then it should be mocked in tests?
        const result = await this._getReportViews();
        this.pager.update({ currentMinimum, limit });
        this.reportHTML = result.report_html;
        this.reportViews = result.views;
        this.updateEditor();
    },
    /**
     * @private
     */
    _onPrintReport: function () {
        var self = this;
        this._rpc({
            route: '/web_studio/print_report',
            params: {
                record_id: this.env.currentId,
                report_name: this.reportName,
                context: session.user_context,
            },
        }).then(function (action) {
            self.do_action(action);
        });
    },
    /**
     * @override
     * @param {OdooEvent} ev
     * @param {Object} ev.data
     * @param {Object} ev.data.operation the operation sent to the server
     */
    _onViewChange: function (ev) {
        var self = this;
        var def;

        var node = ev.data.node || ev.data.targets[0].node;
        var operation = _.extend(ev.data.operation, {
            view_id: +node.attrs['data-oe-id'],
            xpath: node.attrs['data-oe-xpath'],
            context: node.context,
        });

        if (operation.type === 'add') {
            def = ev.data.component.add({
                targets: ev.data.targets,
            }).then(function (result) {
                // TODO: maybe modify the operation directly?
                _.extend(operation, result);
            });
        } else {
            if (node) {
                this.view.selectedNode = node;
            } else {
                console.warn("the key 'node' should be present");
            }
        }
        Promise.resolve(def).then(function () {
            return self._do(operation);
        }).guardedCatch(ev.data.fail);
    },
});

return ReportEditorManager;

});
;

/********************************************************************************
*  Filepath: /web_studio/static/src/legacy/js/reports/report_editor_sidebar.js  *
*  Bundle: web_studio.studio_assets                                             *
*  Lines: 586                                                                   *
********************************************************************************/
odoo.define('web_studio.ReportEditorSidebar', function (require) {
"use strict";

var config = require('web.config');
var core = require('web.core');
var relational_fields = require('web.relational_fields');
var StandaloneFieldManagerMixin = require('web.StandaloneFieldManagerMixin');
var utils = require('web.utils');
var Widget = require('web.Widget');

var editComponentsRegistry = require('web_studio.reportEditComponentsRegistry');
var newComponentsRegistry = require('web_studio.reportNewComponentsRegistry');
var studioUtils = require('web_studio.utils');

var Many2ManyTags = relational_fields.FieldMany2ManyTags;
var Many2One = relational_fields.FieldMany2One;

var qweb = core.qweb;
var _t = core._t;

var ReportEditorSidebar = Widget.extend(StandaloneFieldManagerMixin, {
    template: 'web_studio.ReportEditorSidebar',
    events: {
        'change input': '_onChangeReport',
        'click .o_web_studio_sidebar_header > div:not(.inactive)': '_onTab',
        'click .o_web_studio_xml_editor': '_onXMLEditor',
        'click .o_web_studio_parameters': '_onParameters',
        'click .o_web_studio_remove': '_onRemove',
    },
    /**
     * @constructor
     * @param {Widget} parent
     * @param {Object} params
     * @param {Object} [params.models]
     * @param {Object} [params.paperFormat]
     * @param {Object} [params.previousState]
     * @param {Object} [params.report] only mandatory if state.mode = 'report'
     * @param {Object} [params.state]
     * @param {Object} [params.widgetsOptions]
     */
    init: function (parent, params) {
        this._super.apply(this, arguments);
        StandaloneFieldManagerMixin.init.call(this);

        this.debug = config.isDebug();
        this.report = params.report;
        this.state = params.state || {};
        this.paperFormat = params.paperFormat || {};
        this.previousState = params.previousState || {};
        this.models = params.models;
        this.widgetsOptions = params.widgetsOptions;
    },
    /**
     * @override
     */
    willStart: function () {
        var self = this;
        var defs = [this._super.apply(this, arguments)];

        if (this.state.mode === 'report') {
            // make record for the many2many groups
            var defReport = this.model.makeRecord('ir.model.fields', [{
                name: 'groups_id',
                fields: [{
                    name: 'id',
                    type: 'integer',
                }, {
                    name: 'display_name',
                    type: 'char',
                }],
                relation: 'res.groups',
                type: 'many2many',
                value: this.report.groups_id,
            }]).then(function (recordID) {
                self.groupsHandle = recordID;
            });
            // load record for the many2one paperformat
            var defPaperFormat = this.model.makeRecord('ir.model.fields', [{
                name: 'paperformat_id',
                relation: 'report.paperformat',
                type: 'many2one',
                value: this.report.paperformat_id,
            }]).then(function (recordID) {
                self.paperformatHandle = recordID;
            });
            defs.push(defReport);
            defs.push(defPaperFormat);
        }
        return Promise.all(defs);
    },
    /**
     * @override
     */
    start: function () {
        var def;
        switch (this.state.mode) {
            case 'report':
                def = this._startModeReport();
                break;
            case 'new':
                def = this._startModeNew();
                break;
            case 'properties':
                def = this._startModeProperties();
                break;
        }
        return Promise.all([this._super.apply(this, arguments), def]);
    },

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    /**
     * Gets the state of all the widgets of all the node hierarchy of the
     * sidebar.
     *
     * @returns {Object}
     */
    getLocalState: function () {
        var self = this;
        var state = {};

        _.each(this.nodes, function (node) {
            var nodeName = self._computeUniqueNodeName(node.node);
            state[nodeName] = {};
            _.each(node.widgets, function (comp) {
                state[nodeName][comp.name] = comp.getLocalState();
            });
        });
        return state;
    },

    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------

    /**
     * Given a node, computes a unique name that will be the same between
     * refresh of the preview.
     *
     * @param {Object} node
     * @returns {string}
     */
    _computeUniqueNodeName: function (node) {
        return node.attrs["data-oe-id"] + node.attrs["data-oe-xpath"].replace(/\[\]\//g, "_");
    },
    /**
     * Utility function that will create a fake jQuery node.
     *
     * Note that the 'real' DOM node cannot be used as it may not not exist
     * (e.g. a <t> node which is defined in the arch but has no corresponding
     * DOM node).
     *
     * TODO: if it's too slow, maybe instatiate the parse only once in init.
     *
     * @private
     * @param {Object} node
     * @returns {jQuery}
     */
    _getAssociatedDOMNode: function (node) {
        var parser = new DOMParser();
        var xml = utils.json_node_to_xml(node);
        var xmlDoc = parser.parseFromString(xml, "text/xml");
        var xmlNode = xmlDoc.getElementsByTagName(node.tag)[0];
        return $(xmlNode);
    },
    /**
     * @private
     * @param {Object} components
     * @returns {Object}
     */
    _getComponentsObject: function (components) {
        return _.map(components, function (componentName) {
            var Component = _.find(editComponentsRegistry.map, function (Component) {
                return Component.prototype.name === componentName;
            });
            return Component;
        });
    },
    /**
     * @private
     * @param {Object} components
     * @returns {string}
     */
    _getComponentsBlacklist: function (components) {
        var blacklist = '';
        _.each(this._getComponentsObject(components), function (Component) {
            if (Component.prototype.blacklist) {
                if (blacklist.length) {
                    blacklist += ',';
                }
                blacklist += Component.prototype.blacklist;
            }
        });
        return blacklist;
    },
    /**
     * @private
     * @param {Object} node
     * @returns {string} a attempt of meaningful name for the given node
     */
    _getNodeDisplayName: function (node) {
        var displayName = { name: node.tag, attr: '', icon: '' };

        if (node.attrs) {
            if (node.attrs.name) {
                displayName.attr += '(' + node.attrs.name + ')';
            }
            if (node.attrs['t-field'] || node.attrs['t-esc']) {
                displayName.attr += '[' + (node.attrs['t-field'] || node.attrs['t-esc']) + ']';
            }
            if (node.attrs['t-call']) {
                displayName.attr += '[t-call="' + node.attrs['t-call'] + '"]';
            }
            if (node.attrs['t-foreach']) {
                displayName.attr += '[foreach="' + node.attrs['t-foreach'] + '"]';
            }
        }

        if (node.key) {
            displayName.attr += ' - ' + node.key;
        }

        if (displayName.name === 'div' && node.attrs.class) {
            displayName.attr += ' ' + node.attrs.class;
        }

        switch (displayName.name) {
            case 't':
                displayName.icon = 'fa-cog';
                break;

            case 'html':
            case 'body':
            case 'main':
                displayName.icon = 'fa-file';
                break;

            case 'table':
                displayName.icon = 'fa-table';
                break;

            case 'thead':
            case 'tr':
            case 'tfoot':
                displayName.icon = 'fa-ellipsis-h';

                if (node.attrs.hasOwnProperty('t-foreach')) {
                    displayName.icon = 'fa-retweet text-primary';
                }

                break;

            case 'tbody':
                displayName.icon = 'fa-th';
                break;

            case 'th':
            case 'td':
                displayName.icon = 'fa-square-o';
                break;

            case 'img':
                displayName.icon = 'fa-picture-o';
                break;

            case 'div':
                displayName.icon = 'fa-folder';

                if (!node.attrs.hasOwnProperty('class')) {
                    break;
                }

                if (node.attrs.class.indexOf('col-') !== -1) {
                    displayName.icon = 'fa-columns';
                } else if (node.attrs.class.indexOf('row') !== -1) {
                    displayName.icon = 'fa-ellipsis-h';
                }
                break;

            case 'address':
                displayName.icon = 'fa-address-book-o';
                break;

            case 'h1':
            case 'h2':
            case 'h3':
            case 'h4':
            case 'h5':
            case 'h6':
            case 'p':
            case 'b':
            case 'i':
            case 'span':
            case 'strong':
                displayName.icon = 'fa-i-cursor';
                break;
        }

        return displayName;
    },
    /**
     * Given a specific node selected (clicked) on the report, get a list of all
     * the components that are applicable to edit this node.
     *
     * This function uses the selector defined on the editable components
     * themselves to check wether it applies to a node or not
     *
     * @private
     * @param {Object} node
     * @returns {string[]}
     */
    _getNodeEditableComponents: function (node) {
        var self = this;
        var components = [];

        var $node = this._getAssociatedDOMNode(node);
        _.each(editComponentsRegistry.map, function (Component) {
            var selector = Component.prototype.selector;
            if (self.debug) {
                selector = Component.prototype.debugSelector || selector;
            }
            if ($node.is(selector)) { // use last because DOM eject t tag in table tag
                components.push(Component.prototype.name);
            }
        });

        _.each(['layout', 'tif', 'groups'], function (componentName) {
            if (!_.contains(components, componentName)) {
                components.push(componentName);
            }
        });
        return components;
    },
    /**
     * @private
     * @returns {Promise}
     */
    _startModeNew: function () {
        var self = this;
        var defs = [];
        var $sidebarContent = this.$('.o_web_studio_sidebar_content');

        _.each(newComponentsRegistry.map, function (components, title) {
            $sidebarContent.append($('<h3>', {
                html: title,
            }));
            var $componentsContainer = $('<div>', {
                class: 'o_web_studio_field_type_container',
            });
            _.each(components, function (Component) {
                defs.push(new Component(self, { models: self.models }).appendTo($componentsContainer));
            });
            $sidebarContent.append($componentsContainer);
        });

        return Promise.all(defs);
    },
    /**
     * A node has been clicked on the report, build the content of the sidebar so this node can be edited
     *
     * @private
     * @returns {Promise}
     */
    _startModeProperties: function () {
        var self = this;
        var componentsAppendedPromise;
        var $accordion = this.$('.o_web_studio_sidebar_content .o_web_studio_accordion');

        var blacklists = [];
        this.nodes = [];

        if (!this.debug) {
            // hide all nodes after .page, they are too technical
            var pageNodeIndex = _.findIndex(this.state.nodes, function (node) {
                return node.node.tag === 'div' && _.str.include(node.node.attrs.class, 'page');
            });
            if (pageNodeIndex !== -1) {
                this.state.nodes.splice(pageNodeIndex + 1, this.state.nodes.length - (pageNodeIndex + 1));
            }
        }

        for (var index = this.state.nodes.length - 1; index >= 0; index--) {
            // copy to not modifying in place the node
            var node = _.extend({}, this.state.nodes[index]);
            if (!this.debug && blacklists.length) {
                if (this._getAssociatedDOMNode(node.node).is(blacklists.join(','))) {
                    continue;
                }
            }
            var components = this._getNodeEditableComponents(node.node);
            node.components = components;
            var blacklist = this._getComponentsBlacklist(components);
            if (blacklist.length) {
                blacklists.push(blacklist);
            }
            node.widgets = [];
            this.nodes.unshift(node);
        }
        // TODO: do not reverse but put nodes in correct order directly
        this.nodes.reverse();

        this.nodes.forEach(function (node) {
            var $accordionSection = $(qweb.render('web_studio.AccordionSection', {
                id: 'id_' + studioUtils.randomString(6),
                header: 'header_' + studioUtils.randomString(6),
                nodeName: self._getNodeDisplayName(node.node).name,
                nodeAttr: self._getNodeDisplayName(node.node).attr,
                nodeIcon: self._getNodeDisplayName(node.node).icon,
                node: node.node,
            }));
            var renderingProms = self._getComponentsObject(node.components).map(function (Component) {
                if (!Component) {
                    self.displayNotification({ title: "Missing component", message: self.state.directive, type: 'danger' });
                    return;
                }
                var previousWidgetState = self.previousState[self._computeUniqueNodeName(node.node)] &&
                    self.previousState[self._computeUniqueNodeName(node.node)][Component.prototype.name];
                var directiveWidget = new Component(self, {
                    widgetsOptions: self.widgetsOptions,
                    node: node.node,
                    context: node.context,
                    state: previousWidgetState,
                    models: self.models,
                    componentsList: node.components,
                });
                node.widgets.push(directiveWidget);
                var fragment = document.createDocumentFragment();
                return directiveWidget.appendTo(fragment);
            });
            componentsAppendedPromise = Promise.all(renderingProms).then(function () {
                for (var i = 0; i < node.widgets.length; i++) {
                    var widget = node.widgets[i];
                    var selector = '.collapse' + (i > 0 ? '>div:last()' : '');
                    widget.$el.appendTo($accordionSection.find(selector));
                }
                var $removeButton = $(qweb.render('web_studio.Sidebar.Remove'));
                $removeButton.data('node', node.node); // see @_onRemove
                $accordionSection.find('.collapse')
                    .append($('<hr>'))
                    .append($removeButton);
            });
            $accordionSection.appendTo($accordion);
            $accordionSection
                .on('mouseenter', function () {
                    self.trigger_up('hover_editor', {
                        node: node.node,
                    });
                })
                .on('click', function () {
                    self.trigger_up('node_expanded', {
                        node: node.node,
                    });
                })
                .on('mouseleave', function () {
                    self.trigger_up('hover_editor', {
                        node: undefined,
                    });
                })
                .find('.collapse').on('show.bs.collapse hide.bs.collapse', function (ev) {
                    $(this).parent('.card').toggleClass('o_web_studio_active', ev.type === 'show');
                });
        });

        // open the last section
        // NB: this is the only way with BS4 to open the tab synchronously
        var $lastCard = $accordion.find('.card:last');
        $lastCard.addClass('o_web_studio_active');
        $lastCard.find('.collapse').addClass('show');

        return componentsAppendedPromise;
    },
    /**
     * @private
     * @returns {Promise}
     */
    _startModeReport: function () {
        var defs = [];
        var paperFormatRecord = this.model.get(this.paperformatHandle);
        var many2one = new Many2One(this, 'paperformat_id', paperFormatRecord, {
            attrs: {
                placeholder: _t('By default: ') + this.paperFormat.display_name,
            },
            mode: 'edit',
        });
        this._registerWidget(this.paperformatHandle, 'paperformat_id', many2one);
        defs.push(many2one.appendTo(this.$('.o_web_studio_paperformat_id')));
        this.paperformatMany2one = many2one;

        // append many2many for groups_id
        var groupsRecord = this.model.get(this.groupsHandle);
        var many2many = new Many2ManyTags(this, 'groups_id', groupsRecord, {
            mode: 'edit',
        });
        this._registerWidget(this.groupsHandle, 'groups_id', many2many);
        defs.push(many2many.appendTo(this.$('.o_groups')));
        return Promise.all(defs);
    },

    //--------------------------------------------------------------------------
    // Handlers
    //--------------------------------------------------------------------------

    /**
     * @private
     * @param {JQueryEvent} ev
     */
    _onChangeReport: function (ev) {
        var $input = $(ev.currentTarget);
        var attribute = $input.attr('name');
        if (attribute) {
            var newAttrs = {};
            if ($input.attr('type') === 'checkbox') {
                newAttrs[attribute] = $input.is(':checked') ? 'True' : '';
            } else {
                newAttrs[attribute] = $input.val();
            }
            this.trigger_up('studio_edit_report', newAttrs);
        }
    },
    /**
     * @private
     * @override
     * @param {OdooEvent} ev
     */
    _onFieldChanged: function (ev) {
        var self = this;
        StandaloneFieldManagerMixin._onFieldChanged.apply(this, arguments).then(function () {
            if (self.state.mode !== 'report') {
                return;
            }
            var newAttrs = {};
            var fieldName = ev.target.name;
            var record;
            if (fieldName === 'groups_id') {
                record = self.model.get(self.groupsHandle);
                newAttrs[fieldName] = record.data.groups_id.res_ids;
            } else if (fieldName === 'paperformat_id') {
                record = self.model.get(self.paperformatHandle);
                newAttrs[fieldName] = record.data.paperformat_id && record.data.paperformat_id.res_id;
            }
            self.trigger_up('studio_edit_report', newAttrs);
        });
    },
    /**
     * @private
     */
    _onParameters: function () {
        this.trigger_up('open_record_form_view');
    },
    /**
     * @private
     * @param {ClickEvent} ev
     */
    _onRemove: function (ev) {
        var node = $(ev.currentTarget).data('node');
        this.trigger_up('element_removed', {
            node: node,
        });
    },
    /**
     * @private
     * @param {ClickEvent} ev
     */
    _onTab: function (ev) {
        var mode = $(ev.currentTarget).attr('name');
        if (mode === 'options') {
            // one cannot manually select options
            return;
        }
        this.trigger_up('sidebar_tab_changed', {
            mode: mode,
        });
    },
    /**
     * @private
     */
    _onXMLEditor: function () {
        this.trigger_up('open_xml_editor');
    },
});

return ReportEditorSidebar;

});
;

/*****************************************************************************
*  Filepath: /web_studio/static/src/legacy/js/reports/report_kanban_view.js  *
*  Bundle: web_studio.studio_assets                                          *
*  Lines: 187                                                                *
*****************************************************************************/
odoo.define('web_studio.studio_report_kanban', function (require) {
"use strict";

var core = require('web.core');
var Dialog = require('web.Dialog');
var KanbanController = require('web.KanbanController');
var KanbanView = require('web.KanbanView');
var session = require('web.session');
var view_registry = require('web.view_registry');

var bus = require('web_studio.bus');

var _t = core._t;

var StudioReportKanbanController = KanbanController.extend({
    /**
     * Warn the Studio submenu that the report is not edited anymore.
     */
    on_reverse_breadcrumb: function () {
        bus.trigger('report_template_closed');
    },

    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------

    /**
     * Do not open the form view but open the Report Editor action.
     *
     * @param {Object} data
     * @param {Integer} [data.res_id] The record res ID (if it directly
     *   comes from the server)
     * @param {number} [data.id] The local model ID for the record to be
     *   opened
     * @private
     */
    _openReportRecord: function (data) {
        var self = this;
        var def;
        if (data.res_id && !data.id) {
            var state = this.model.get(this.handle, {raw: true});
            def = this.model.load({
                modelName: this.modelName,
                res_id: data.res_id,
                fields: state.fields,
                fieldNames: ['report_name'],
            });
        }
        Promise.resolve(def).then(function (result) {
            var id = data.id || result;
            var report = self.model.get(id, {raw: true});
            self.do_action('web_studio.action_edit_report', {
                report: report,
                on_reverse_breadcrumb: self.on_reverse_breadcrumb,
            });
        });
    },
    //--------------------------------------------------------------------------
    // Handlers
    //--------------------------------------------------------------------------

    /**
     * Do not add a record but open the dialog.
     *
     * @private
     * @override
     */
    _onButtonNew: function () {
        var model = this.initialState.context.default_model;
        new NewReportDialog(this, model).open();
    },
    /**
     * Do not open the form view but open the Report Editor action.
     *
     * @param {OdooEvent} ev
     * @param {Integer} [ev.data.res_id] The record res ID (if it directly
     *   comes from the server)
     * @param {number} [ev.data.id] The local model ID for the record to be
     *   opened
     * @private
     * @override
     */
    _onOpenRecord: function (ev) {
        ev.stopPropagation();
        this._openReportRecord(ev.data);
    },
    /**
     * Override to reload the view after the 'copy_report_and_template' action.
     *
     * @private
     * @override
     */
    _reloadAfterButtonClick: function (kanbanRecord, params) {
        this._super.apply(this, arguments);
        if (params.attrs.name === 'copy_report_and_template') {
            this.trigger_up('reload');
        }
    },
});

var StudioReportKanbanView = KanbanView.extend({
    config: _.extend({}, KanbanView.prototype.config, {
        Controller: StudioReportKanbanController,
    }),
});

var NewReportDialog = Dialog.extend({
    template: 'web_studio.NewReportDialog',
    events: {
        'click .o_web_studio_report_layout_item': '_onReportTemplateSelected',
    },
    /**
     * @constructor
     * @param {Widget} parent
     * @param {String} modelName
     */
    init: function (parent, modelName) {
        this.modelName = modelName;
        var options = {
            title: _t("Which type of report do you want to create?"),
            size: 'medium',
            buttons: [],
        };

        this.layouts = [{
            name: 'web.external_layout',
            label: _t("External"),
            description: _t("Business header/footer"),
        }, {
            name: 'web.internal_layout',
            label: _t("Internal"),
            description: _t("Minimal header/footer"),
        }, {
            name: 'web.basic_layout',
            label: _t("Blank"),
            description: _t("No header/footer"),
        }];

        this._super(parent, options);
    },

    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------

    /**
     * @private
     * @param {String} modelName
     * @param {String} layout
     * @returns {Promise}
     */
    _createNewReport: function (modelName, layout) {
        return this._rpc({
            route: '/web_studio/create_new_report',
            params: {
                model_name: modelName,
                layout: layout,
                context: session.user_context,
            },
        });
    },

    //--------------------------------------------------------------------------
    // Handlers
    //--------------------------------------------------------------------------

    /**
     * Create a new report.
     *
     * @private
     * @param {ClickEvent} event
     */
    _onReportTemplateSelected: function (event) {
        var self = this;
        var layout = $(event.currentTarget).data('layout');
        this._createNewReport(this.modelName, layout).then(function (result) {
            self.trigger_up('open_record', {res_id: result.id});
            self.close();
        });
    },
});

view_registry.add('studio_report_kanban', StudioReportKanbanView);

return StudioReportKanbanView;

});
;

/*******************************************************************************************************
*  Filepath: /web_studio/static/src/legacy/js/reports/sidebar_components/abstract_report_component.js  *
*  Bundle: web_studio.studio_assets                                                                    *
*  Lines: 68                                                                                           *
*******************************************************************************************************/
odoo.define('web_studio.AbstractReportComponent', function (require) {
"use strict";

var Widget = require('web.Widget');

var AbstractReportComponent = Widget.extend({
    /**
     * @override
     * @param {Widget} parent
     * @param {Object} params
     * @param {Object} params.models
     */
    init: function (parent, params) {
        this.models = params.models;
        this.node = {
            context: {},
            contextOrder: [],
        };
        this._super.apply(this, arguments);
    },

    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------
    /**
     * Given a node of the DOM of the report preview, get the avaiable context of this node
     * The context is filled in the branding on the node itself. It represents
     * all the variables available at a moment in the report
     *
     * @param {Object} node
     */
    _getContextKeys: function (node) {
        var self = this;
        var contextOrder = node.contextOrder || [];

        var keys = _.compact(_.map(node.context, function (relation, key) {
            if (!self.models[relation]) {
                return {
                    name: key,
                    string: key + ' (' + relation + ')',
                    type: relation,
                    store: true,
                    related: true,
                    searchable: true,
                    order: -contextOrder.indexOf(key),
                };
            }
            return {
                name: key,
                string: key + ' (' + self.models[relation] + ')',
                relation: relation,
                type: key[key.length-1] === 's' ? 'one2many' : 'many2one',
                store: true,
                related: true,
                searchable: true,
                order: -contextOrder.indexOf(key),
            };
        }));
        keys.sort(function (a, b) {
            return a.order - b.order;
        });
        return keys;
    },
});

return AbstractReportComponent;

});
;

/*********************************************************************************************
*  Filepath: /web_studio/static/src/legacy/js/reports/sidebar_components/edit_components.js  *
*  Bundle: web_studio.studio_assets                                                          *
*  Lines: 1564                                                                               *
*********************************************************************************************/
odoo.define('web_studio.reportEditComponents', function (require) {
"use strict";

var {ColorpickerDialog} = require('web.Colorpicker');
var config = require('web.config');
var core = require('web.core');
var utils = require('web.utils');
var fieldRegistry = require('web.field_registry');
var fieldRegistryOwl = require('web.field_registry_owl');
const FieldWrapper = require('web.FieldWrapper');
var ModelFieldSelector = require('web.ModelFieldSelector');
var StandaloneFieldManagerMixin = require('web.StandaloneFieldManagerMixin');
const { WidgetAdapterMixin } = require('web.OwlCompatibility');

const Wysiwyg = require('web_editor.wysiwyg');

var Abstract = require('web_studio.AbstractReportComponent');
var DomainSelectorDialog = require('web.DomainSelectorDialog');
var Domain = require("web.Domain");

var py = window.py; // look py.js
var qweb = core.qweb;

var AbstractEditComponent = Abstract.extend(WidgetAdapterMixin, StandaloneFieldManagerMixin, {
    events: {
        'change input': function (e) {
            e.stopPropagation();
        },
    },
    custom_events: _.extend({}, Abstract.prototype.custom_events, {
        field_changed: '_onDirectiveChange',
        field_chain_changed: '_onDirectiveChange',
    }),
    /**
     * @override
     * @param {Object} params
     * @param {Object} params.context
     * @param {Object} params.node
     * @param {Object} [params.state]
     * @param {string[]} [params.componentsList] the list of components for the
     *                                           node
     */
    init: function (parent, params) {
        this._super.apply(this, arguments);
        StandaloneFieldManagerMixin.init.call(this);
        this.state = params.state || {};
        this.node = params.node;
        this.context = params.context;
        this.componentsList = params.componentsList;
        // TODO: check if using a real model with widgets is reasonnable or if
        // we should use actual html components in QWEB
        this.directiveFields = {};

        // will be set in the willStart defDirective callback
        this.directiveRecordId = '';

        // add in init: directive => field selector
        this.fieldSelector = {};

    },
    /**
     * @override
     */
    willStart: function () {
        var self = this;

        var directiveModel = [];
        _.each(this.directiveFields, function (options, directiveKey) {
            var value = options.value;
            if (!value) {
                value = self.node.attrs[options.attributeName || directiveKey];
            }

            if (options.type === 'related') {
                directiveModel.push({
                    name: directiveKey,
                    type: 'char',
                    value: options.freecode ? value : self._splitRelatedValue(value).chain.join('.'),
                });
            } else {
                directiveModel.push(_.extend({}, {
                    name: directiveKey,
                    value: value,
                }, options));
            }
        });

        var defDirective = this.model.makeRecord('ir.model.fields', directiveModel)
            .then(function (recordId) {
                self.directiveRecordId = recordId;

                _.each(self.directiveFields, function (options, directiveKey) {
                    if (options.type === 'related') {
                        self.createFieldSelector(directiveKey, options);
                    } else {
                        self.createField(directiveKey, options);
                    }
                });
            });
        var defParent = this._super.apply(this, arguments);
        return Promise.all([defDirective, defParent]);
    },
    /**
     * @override
     */
    destroy: function () {
        this._super.apply(this, arguments);
        WidgetAdapterMixin.destroy.call(this);
    },
    /**
     * Called each time the widget is attached into the DOM.
     */
    on_attach_callback: function () {
        WidgetAdapterMixin.on_attach_callback.call(this);
    },
    /**
     * Called each time the widget is detached from the DOM.
     */
    on_detach_callback: function () {
        WidgetAdapterMixin.on_detach_callback.call(this);
    },

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    /**
     * Creates a new field (for basic fields, as field registry).
     *
     * @param {String} directiveKey unique key
     * @param {Object} options
     */
    createField: function (directiveKey, options) {
        var directiveRecord = this.model.get(this.directiveRecordId);

        options = _.extend({mode: 'edit', attrs: _.extend({
            quick_create: false, can_create: false}, options)}, options);

        var field = directiveRecord.fields[directiveKey];
        var FieldClass = fieldRegistryOwl.getAny([options.Widget, field.type]);
        if (FieldClass) {
            this.fieldSelector[directiveKey] = new FieldWrapper(this, FieldClass, {
                fieldName: directiveKey,
                record: directiveRecord,
                options,
            });
            this.fieldSelector[directiveKey].appendTo = function ($el) {
                return this.mount($el[0]);
            };
        } else {
            FieldClass = fieldRegistry.getAny([options.Widget, field.type]);
            this.fieldSelector[directiveKey] = new FieldClass(
                this, directiveKey, directiveRecord, options);
        }
    },
    /**
     * Creates a new field selector (for related fields).
     *
     * @param {String} directiveKey unique key
     * @param {Object} options
     */
    createFieldSelector: function (directiveKey, options) {
        var directiveRecord = this.model.get(this.directiveRecordId);

        var split = this._splitRelatedValue(directiveRecord.data[directiveKey]);

        if (this.context[split.chain[0]] === 'undefined') {
            // if we don't know what the variable is, we won't be able to follow
            // the relations (and fetch the fields) with the FieldSelector
            console.warn("We don't know what " + split.chain[0] + " is ...");
            return this.createField(directiveKey);
        }

        if (options.freecode && split.rest) {
            var InputField = fieldRegistry.get('input');
            this.fieldSelector[directiveKey] = new InputField(
                this, directiveKey,
                directiveRecord,
                _.extend({mode: 'edit', attrs: options}, options));
            return;
        }

        var availableKeys = this._getContextKeys(this.node);
        if (options.loop) {
            availableKeys = _.filter(availableKeys, function (relation) {
                return relation.type === 'one2many' || relation.type === 'many2one';
            });
        }

        this.fieldSelector[directiveKey] = new ModelFieldSelector(this, 'record_fake_model', split.chain,
            _.extend({
                readonly: options.mode === 'readonly',
                searchable: false,
                fields: availableKeys,
                filters: {searchable: false},
                filter: options.filter || function () {
                    return true;
                },
                followRelations: options.followRelations || function (field) {
                    return field.type === 'many2one';
                },
            }, options));
    },
    /**
     * To be overriden.
     */
    getLocalState: function() {
    },

    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------

    /**
     * @private
     * @param {any} value
     * @returns {Object}
     */
    _splitRelatedValue: function (value) {
        var chain = [];
        var rest = value || '';
        if (typeof value === "string") {
            try {
                value = py.extract(value);
            } catch (e) {
                return {
                    chain: [],
                    rest: value,
                };
            }
        }
        if (value) {
            if (value.isOperator) {
                if (value.params.values[0].isField) {
                    chain = value.params.values[0].expr.split('.');
                    rest = value.expr.slice(chain.length);
                } else {
                    rest = value.expr;
                }
            }
            if (value.isCall) {
                rest = (value.params.object.length ? '.' : '') + value.params.method + '(' + value.params.args.join(', ') + ')';
                chain = value.params.object;
            }
            if (value.isField) {
                rest = '';
                chain = value.expr.split('.');
            }
        }
        return {
            chain: chain,
            rest: rest,
        };
    },
    /**
     * @private
     * @param {Object} newAttrs
     */
    _tSetAttributes: function (newAttrs) {
        var self = this;
        var node = this.node;
        var op = [];
        _.each(newAttrs, function (tvalue, tset) {
            if (tvalue === self.directiveFields[tset].value) {
                return;
            }
            op.push({
                content: '<attribute name="t-value">' + tvalue + '</attribute>',
                position: "attributes",
                view_id: +node.attrs['data-oe-id'],
                xpath: node.attrs['data-oe-xpath'] + "//t[@t-set='" + tset + "']"
            });
        });
        if (!op.length) {
            return;
        }
        this.trigger_up('view_change', {
            node: node,
            operation: {
                inheritance: op,
            },
        });
    },
    /**
     * @private
     * @param {String} attributeName
     * @param {String} toAdd
     * @param {String} toRemove
     */
    _editDomAttribute: function (attributeName, toAdd, toRemove) {
        var attribute = '<attribute name="' + attributeName + '" separator="' + (attributeName === 'class' ? ' ' : ';') + '"';
        if (toAdd) {
            attribute += ' add="' + toAdd + '"';
        }
        if (toRemove) {
            attribute += ' remove="' + toRemove + '"';
        }
        attribute += '/>';

        this.trigger_up('view_change', {
            node: this.node,
            operation: {
                inheritance: [{
                    content: attribute,
                    position: "attributes",
                    view_id: +this.node.attrs['data-oe-id'],
                    xpath: this.node.attrs['data-oe-xpath']
                }],
            },
        });
    },
    /**
     * Triggered by a field modification (see @createField and
     * @createFieldSelector).
     * To be overriden if the attributes need to be preprocessed.
     *
     * @private
     * @param {Object} newAttrs
     */
    _triggerViewChange: function (newAttrs) {
        this.trigger_up('view_change', {
            node: this.node,
            operation: {
                type: 'attributes',
                new_attrs: newAttrs,
            },
        });
    },

    //--------------------------------------------------------------------------
    // Handlers
    //--------------------------------------------------------------------------
    /**
     * @private
     * @param {OdooEvent} e
     */
    _onDirectiveChange: function (e) {
        var self = this;
        e.stopPropagation();  // TODO: is it really useful on an OdooEvent

        e.data.dataPointID = this.directiveRecordId;

        var always = function () {
            var newAttrs = {};
            _.each(self.fieldSelector, function (fieldType, directiveKey) {
                var directiveTarget = self.fieldSelector[directiveKey];
                var target = e.target;
                if (directiveTarget instanceof owl.Component) {
                    directiveTarget = directiveTarget.componentRef.comp;
                    target = e.data.__originalComponent
                }
                if (!e.data.forceChange && target !== directiveTarget) {
                    return;
                }
                var data = self.model.get(self.directiveRecordId).data;
                var fieldValue = data[directiveKey];
                // TODO: for relation field, maybe set id (or ids) in fieldValue to
                // avoid overwritting _triggerViewChange in every directive
                if (e.data.chain) {
                    fieldValue = e.data.chain.join('.');
                }
                if (fieldValue.res_ids) {
                    fieldValue = fieldValue.res_ids.slice();
                }
                newAttrs[directiveKey] = fieldValue;
            });

            if (e.data.chain) {
                e.data.dataPointID = self.directiveRecordId;
                e.data.changes = newAttrs;
            }

            self._triggerViewChange(newAttrs);
        };

        StandaloneFieldManagerMixin._onFieldChanged.call(this, e).then(always, always);
    },
});

var loadColors;
var LayoutEditable = AbstractEditComponent.extend({
    name: 'layout',
    template : 'web_studio.ReportLayoutEditable',
    events : _.extend({}, AbstractEditComponent.prototype.events, {
        "change .o_web_studio_margin>input": "_onMarginInputChange",
        "change .o_web_studio_width>input": "_onWidthInputChange",
        "click .o_web_studio_font_size .dropdown-item-text": "_onFontSizeChange",
        "change .o_web_studio_table_style > select": "_onTableStyleInputChange",
        "click .o_web_studio_text_decoration button": "_onTextDecorationChange",
        "click .o_web_studio_text_alignment button": "_onTextAlignmentChange",
        "change .o_web_studio_classes>input": "_onClassesChange",
        "click .o_web_studio_colors .o_web_studio_reset_color": "_onResetColor",
        "click .o_web_studio_colors .o_web_studio_custom_color": "_onCustomColor",
    }),
    /**
     * @override
     */
    init: function (parent, params) {
        this._super.apply(this, arguments);

        this.debug = config.isDebug();
        this.isTable = params.node.tag === 'table';
        this.isNodeText = _.contains(this.componentsList, 'text');
        this.allClasses = params.node.attrs.class || "";
        this.classesArray =(params.node.attrs.class || "").split(' ');
        this.stylesArray =(params.node.attrs.style || "").split(';');

        var fontSizeRegExp= new RegExp(/^\s*(h[123456]{1})|(small)|(display-[1234]{1})\s*$/gim);
        var backgroundColorRegExp= new RegExp(/^\s*background\-color\s*:/gi);
        var colorRegExp= new RegExp(/^\s*color\s*:/gi);
        var widthRegExp= new RegExp(/^\s*width\s*:/gi);
        const colClassRegex = /\bcol((-(sm|md|lg|xl))?-(\d{1,2}|auto))?\b/;

        this["margin-top"] = this._findMarginValue('margin-top');
        this["margin-bottom"] = this._findMarginValue('margin-bottom');
        this["margin-left"] = this._findMarginValue('margin-left');
        this["margin-right"] = this._findMarginValue('margin-right');

        this["background-color-class"] = _.find(this.classesArray, function(item) {
            return !item.indexOf('bg-');
        });
        this["font-color-class"] = _.find(this.classesArray, function(item) {
            return !item.indexOf('text-');
        });
        this.tableStyle = _.find(this.classesArray, function(item) {
            return !item.indexOf('table-');
        });
        this["background-color"] = _.find(this.stylesArray, function(item) {
            return backgroundColorRegExp.test(item);
        });
        this.color = _.find(this.stylesArray, function(item) {
            return colorRegExp.test(item);
        });
        // the width on div.col is set with col-. instead of width style
        this.displayWidth = !(params.node.tag === 'div' && _.find(this.classesArray, function(item) {
            return colClassRegex.test(item);
        }));
        this.originalWidth =  _.find(this.stylesArray, function(item) {
            return widthRegExp.test(item);
        });
        if (this.originalWidth) {
            this.width = this.originalWidth.replace(/\D+/g,''); //replaces all non-digits with nothing
        }

        this.fontSize = _.find(this.classesArray, function(item) {
            return fontSizeRegExp.test(item);
        });

        this.italic = _.contains(this.classesArray, 'o_italic');
        this.bold =_.contains(this.classesArray, 'o_bold');
        this.underline = _.contains(this.classesArray, 'o_underline');

        this.alignment = _.intersection(this.classesArray, ['text-left', 'text-center', 'text-right'])[0];
        this.displayAlignment = !_.contains(['inline', 'float'], this.node.$nodes.css('display'));

        this.allClasses = params.node.attrs.class || "";
    },
    /**
     * @override
     */
    willStart: async function () {
        await this._super();
        this._groupColors = await this._getColors();
    },
    /**
     * Override to re-render the color picker on each component rendering.
     *
     * @override
     */
    renderElement: function() {
        var self = this;
        this._super.apply(this, arguments);
        this.$('.o_web_studio_background_colorpicker .o_web_studio_color_palette').append(this._createPalette());
        this.$('.o_web_studio_background_colorpicker').on("mousedown", 'button[data-color]', function (e) {
            self._onColorChange($(e.currentTarget).data('value').replace('text-', 'bg-'), "background");
        });
        this.$('.o_web_studio_font_colorpicker .o_web_studio_color_palette').append(this._createPalette());
        this.$('.o_web_studio_font_colorpicker').on("mousedown", 'button[data-color]', function (e) {
            self._onColorChange($(e.currentTarget).data('value'), "font");
        });
     },



    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------

    /**
     * @private
     * @returns {JQuery Node}
     */
    _createPalette: function () {
        var self = this;
        var $fontPlugin = $('<div/>');
        this._groupColors.forEach(function (color) {
            var $row;
            if (typeof color === 'string') {
                $row = $('<h6/>').text(color);
            } else {
                $row = $('<div class="o_web_studio_color_row"/>');
                color.forEach(function (color) {
                    var $button = $('<button/>').appendTo($row);
                    $button.attr('data-color', color);
                    if (color.startsWith('#')) {
                        $button.css('background-color', color);
                        $button.attr('data-value', color);
                    } else {
                        $button.addClass('bg-' + color);
                        $button.attr('data-value', 'text-' + color);
                    }
                    $row.append($button);
                });
            }
            $fontPlugin.append($row);
        });
        return $fontPlugin;
    },
    /**
     * @private
     * @param {String} marginName the short name of the margin property (mt for
     * margin top, etc.)
     * @returns {Integer|undefined}
     */
    _findMarginValue: function(marginName) {
        if (this.node.attrs.style) {
            var margin = this.node.attrs.style
                .split(';')
                .map(function(item) {return item.trim();})
                .filter(function(item){return !item.indexOf(marginName);});
            if (margin.length) {
                var marginValue = margin[0].split(':')[1].trim().replace('px','');
                return parseInt(marginValue, 10);
            }
        }
    },
    /**
     * @private
     * @returns {Array}
     */
    _getColors: async function () {
        if (!this._colorpickerArch) {
            this._colorpickerArch = await this._rpc({
                model: 'ir.ui.view',
                method: 'render_public_asset',
                args: ['web_editor.colorpicker', {}],
            });
        }

        var groupColors = [];
        var $clpicker = $(this._colorpickerArch);
        $clpicker.children('.o_colorpicker_section').each(function () {
            if (this.dataset.display) {
                groupColors.push(this.dataset.display);
            }
            var colors = [];
            $(this).children('button').each(function () {
                var $el = $(this);
                if (!$el.hasClass('d-none')) {
                    colors.push($el.attr('data-color') || '');
                }
            });
            if (colors.length) {
                groupColors.push(colors);
            }
            if (this.dataset.name === 'common') {
                groupColors = groupColors.concat([
                    ['#FF0000', '#FF9C00', '#FFFF00', '#00FF00', '#00FFFF', '#0000FF', '#9C00FF', '#FF00FF'],
                    ['#F7C6CE', '#FFE7CE', '#FFEFC6', '#D6EFD6', '#CEDEE7', '#CEE7F7', '#D6D6E7', '#E7D6DE'],
                    ['#E79C9C', '#FFC69C', '#FFE79C', '#B5D6A5', '#A5C6CE', '#9CC6EF', '#B5A5D6', '#D6A5BD'],
                    ['#E76363', '#F7AD6B', '#FFD663', '#94BD7B', '#73A5AD', '#6BADDE', '#8C7BC6', '#C67BA5'],
                    ['#CE0000', '#E79439', '#EFC631', '#6BA54A', '#4A7B8C', '#3984C6', '#634AA5', '#A54A7B'],
                    ['#9C0000', '#B56308', '#BD9400', '#397B21', '#104A5A', '#085294', '#311873', '#731842'],
                    ['#630000', '#7B3900', '#846300', '#295218', '#083139', '#003163', '#21104A', '#4A1031']
                ]);
            }
        });
        return groupColors;
    },

    //--------------------------------------------------------------------------
    // Handlers
    //--------------------------------------------------------------------------

    /**
     * @private
     * @param {JQelement} $elem
     * @param {String} type either font or background
     */
    _onColorChange: function (value, type) {
        var isClass = /^(text|bg)-/ .test(value);
        if (isClass) {
            this._editDomAttribute("class", value, type === "background" ? this["background-color-class"] : this["font-color-class"]);
        } else {
            var attributeName = type === "background" ? 'background-color' : 'color';
            this._editDomAttribute("style", attributeName + ':' + value, this[attributeName]);
        }
    },
    /**
     * @private
     * @param {JQEvent} e
     */
    _onClassesChange: function (e) {
        e.preventDefault();
        var newAttrs = {class : e.target.value};
        this.trigger_up('view_change', {
            node: this.node,
            operation: {
                type: 'attributes',
                new_attrs: newAttrs,
            },
        });
    },
    /**
     * @private
     * @param {JQEvent} e
     */
    _onCustomColor: function (e) {
        e.preventDefault();
        const colorpicker = new ColorpickerDialog(this, {
            defaultColor: 'rgb(255, 0, 0)',
        });
        colorpicker.on('colorpicker:saved', this, (ev) => {
            var color = ev.data.cssColor;
            var $button = $('<button/>');
            $button.attr('data-color', color);
            $button.attr('data-value', color);
            $button.css('background-color', color);
            $(e.target).closest('.dropdown-item').find('.o_web_studio_custom_colors').append($button);
            $button.mousedown();
        });
        colorpicker.open();
    },
    /**
     * @private
     * @param {JQEvent} e
     */
    _onFontSizeChange: function (e) {
        e.preventDefault();
        this._editDomAttribute('class', $(e.currentTarget).data('value'), this.fontSize);
    },
    /**
     * @private
     * @param {JQEvent} e
     */
    _onTableStyleInputChange: function (e) {
        e.preventDefault();
        this._editDomAttribute("class", e.target.value, this.tableStyle);
    },
    _onMarginInputChange: function (e) {
        e.preventDefault();
        var toRemove, toAdd;
        if (e.target.value !== "") {
            toAdd = e.target.dataset.margin + ':' + e.target.value + 'px';
        }
        if (this[e.target.dataset.margin]) {
            toRemove = e.target.dataset.margin + ':' + this[e.target.dataset.margin] + 'px';
        }
        this._editDomAttribute("style", toAdd, toRemove);
    },
    /**
     * @private
     * @param {JQEvent} e
     */
    _onResetColor: function (e) {
        e.preventDefault();
        if (e.currentTarget.dataset.target === "background") {
            if (this["background-color-class"]) {
                this._editDomAttribute("class", null, this["background-color-class"]);
            } else if (this["background-color"]) {
                this._editDomAttribute("style", null, this["background-color"]);
            }
        } else {
            if (this["font-color-class"]) {
                this._editDomAttribute("class", null, this["font-color-class"]);
            } else if (this.color) {
                this._editDomAttribute("style", null, this.color);
            }
        }
    },
    /**
     * @private
     * @param {JQEvent} e
     */
    _onTextAlignmentChange : function(e) {
        e.preventDefault();
        var data = $(e.currentTarget).data();
        var toAdd = this.alignment !== data.property ? data.property : null;
        this._editDomAttribute("class", toAdd, this.alignment);
    },
    /**
     * @private
     * @param {JQEvent} e
     */
    _onTextDecorationChange : function(e) {
        e.preventDefault();
        var data = $(e.target).closest("button").data();
        this._editDomAttribute("class",
            !this[data.property] && ("o_" + data.property),
            this[data.property] && ("o_" + data.property));
    },
    /**
     * @private
     * @param {JQEvent} e
     */
    _onWidthInputChange: function(e) {
        e.preventDefault();
        var addDisplayInlineBlock = "";
        var hasDisplay = _.any((this.node.attrs.style || '').split(';'), function (item) {
            return _.str.startsWith(item, 'display');
        });
        if (this.node.tag.toLowerCase() === 'span' && !hasDisplay) {
            addDisplayInlineBlock = ";display:inline-block";
        }
        this._editDomAttribute("style", e.target.value && ("width:" + e.target.value + "px" + addDisplayInlineBlock), this.originalWidth);
    }
});

var TField = AbstractEditComponent.extend({
    name: 'tfield',
    template : 'web_studio.ReportDirectiveTField',
    selector: '[t-field]',
    /**
     * @override
     */
    init: function () {
        this._super.apply(this, arguments);
        this.directiveFields['t-field'] = {
            type: 'related',
        };
    },
    /**
     * @override
     */
    start: function () {
        var self = this;
        return this._super.apply(this, arguments).then(function () {
            var $expr = self.$('.o_web_studio_tfield_fieldexpression');
            return self.fieldSelector['t-field'].appendTo($expr);
        });
    },
});

var TIf = AbstractEditComponent.extend({
    name: 'tif',
    template : 'web_studio.ReportDirectiveTIf',
    selector: '',
    events: _.extend({}, AbstractEditComponent.prototype.events, {
        "click .o_field_domain_dialog_button": "_onDialogEditButtonClick",
    }),
    /**
     * @override
     */
    init: function () {
        this._super.apply(this, arguments);
        this.directiveFields['t-if'] = {
            type: 'char',
        };
    },
    /**
     * @override
     */
    start: function () {
        var self = this;
        try {
            Domain.prototype.conditionToDomain(this.node.attrs['t-if'] || '');
        } catch (e) {
            console.warn("Can't convert the condition in an Odoo domain", this.node.attrs['t-if'], e);
            this.$('.o_field_domain_dialog_button').hide();
        }
        return this._super.apply(this, arguments).then(function () {
            return self.fieldSelector['t-if'].appendTo(self.$('.o_web_studio_tif_ifexpression'));
        });
    },

    //--------------------------------------------------------------------------
    // Handlers
    //--------------------------------------------------------------------------

    /**
     * Called when the "Edit domain" button is clicked (when using the in_dialog
     * option) -> Open a DomainSelectorDialog to edit the value
     *
     * @param {Event} e
     */
    _onDialogEditButtonClick: function (e) {
        e.preventDefault();
        var self = this;
        var availableKeys = this._getContextKeys(this.node);
        // set a default document on the domain selector
        var defaultDoc = _.findWhere(availableKeys, {relation: this.context.docs, type: 'many2one'});
        defaultDoc = defaultDoc && defaultDoc.name || _.first(availableKeys).name;
        var value = Domain.prototype.conditionToDomain(this.node.attrs['t-if'] || '');
        var dialog = new DomainSelectorDialog(this, 'record_fake_model', value, {
            readonly: this.mode === "readonly",
            debugMode: config.isDebug(),
            fields: availableKeys,
            default: [[defaultDoc, '!=', false]],
            operators: ["=", "!=", ">", "<", ">=", "<=", "in", "not in", "set", "not set"],
        }).open();
        dialog.on("domain_selected", this, function (e) {
            var condition = Domain.prototype.domainToCondition(e.data.domain);
            self.$('input').val(condition === 'True' ? '' : condition).trigger('change');
        });
    },

    /**
    * @override
    */
    _onDirectiveChange: function (e) {
        if (e.target.name === "t-if") {
            return this._super.apply(this, arguments);
        }
        e.stopPropagation();
    },
    _isSameValue(value) {
        const currentValue = this.node.attrs['t-if'];
        const newValue = value['t-if'];
        if (!currentValue || !newValue || typeof newValue !== "string") {
            return currentValue === newValue;
        }
        function normalizeValue(value) {
            const charset = {
                "'": /"/,
                "[": /\(/,
                "]": /\)/,
                "','": /',\s+'/,
                "']": /'\s+]/,
                "['": /\[\s+'/,
            }
            for (const key in charset) {
                const toReplace = new RegExp(charset[key], "g");
                value = value.replace(toReplace, key);
            }
            return value;
        }
        return normalizeValue(currentValue) == normalizeValue(newValue);
    },
    _triggerViewChange: function (newAttrs) {
        if (!this._isSameValue(newAttrs)) {
            this._super.apply(this, arguments);
        }
    },
});

var TElse = AbstractEditComponent.extend({
    name: 'telse',
    template : 'web_studio.ReportDirectiveTElse',
    selector: '[t-else]',
    insertAsLastChildOfPrevious: true,
    /**
     * @override
     */
    init: function () {
        this._super.apply(this, arguments);
        this.tIf = this.node.parent.children[this.node.parent.children.indexOf(this.node) - 1].attrs['t-if'];
        this.directiveFields['t-else'] = {
            type: 'boolean',
        };
    },
    /**
     * @override
     */
    start: function () {
        var self = this;
        return this._super.apply(this, arguments).then(function () {
            return self.fieldSelector['t-else'].appendTo(self.$('.o_web_studio_telse_elseexpression'));
        });
    },
    /**
     * @override
     */
    _triggerViewChange: function (newAttrs) {
        this.trigger_up('view_change', {
            node: this.node,
            operation: {
                type: 'attributes',
                new_attrs: {
                    't-else': newAttrs['t-else'] ? 'else' : null,
                },
            },
        });
    },

    //--------------------------------------------------------------------------
    // Handlers
    //--------------------------------------------------------------------------
});

var TEsc = AbstractEditComponent.extend({
    name: 'tesc',
    template : 'web_studio.ReportDirectiveTEsc',
    selector: '[t-esc]',
    /**
     * @override
     */
    init: function () {
        this._super.apply(this, arguments);
        this.directiveFields['t-esc'] = {
            type: 'related',
            freecode: true,
        };
    },
    /**
     * @override
     */
    start: function () {
        var self = this;
        return this._super.apply(this, arguments).then(function () {
            return self.fieldSelector['t-esc'].appendTo(self.$('.o_web_studio_tesc_escexpression'));
        });
    },
});

var TSet = AbstractEditComponent.extend({
    name: 'tset',
    template : 'web_studio.ReportDirectiveTSet',
    selector: '[t-set]',
    /**
     * @override
     */
    init: function () {
        this._super.apply(this, arguments);

        this.directiveFields['t-set'] = {
            type: 'char',
        };
        this.directiveFields['t-value'] = {
            type: 'related',
            freecode: true,
        };
    },
    /**
     * @override
     */
    start: function () {
        var self = this;
        return this._super.apply(this, arguments).then(function () {
            return Promise.all([
                self.fieldSelector['t-set'].appendTo(self.$('.o_web_studio_tset_setexpression')),
                self.fieldSelector['t-value'].appendTo(self.$('.o_web_studio_tset_valueexpression'))
            ]);
        });
    },
});

var TForeach = AbstractEditComponent.extend({
    name: 'tforeach',
    template : 'web_studio.ReportDirectiveTForeach',
    debugSelector: '[t-foreach]',
    /**
     * @override
     */
    init: function () {
        this._super.apply(this, arguments);
        this.directiveFields['t-foreach'] = {
            type: 'related',
            freecode: true,
            loop: true,
        };
        this.directiveFields['t-as'] = {
            type: 'char',
        };
    },
    /**
     * @override
     */
    start: function () {
        var self = this;
        return this._super.apply(this, arguments).then(function () {
            return Promise.all([
                self.fieldSelector['t-as'].appendTo(self.$('.o_web_studio_tas_asexpression')),
                self.fieldSelector['t-foreach'].appendTo(self.$('.o_web_studio_tforeach_foreachexpression'))
            ]);
        });
    },
});

var BlockTotal = AbstractEditComponent.extend({
    name: 'blockTotal',
    template : 'web_studio.BlockTotal',
    selector: '.o_report_block_total',
    blacklist: 't, tr, td, th, small, span',
    /**
     * @override
     */
    init: function () {
        this._super.apply(this, arguments);
        this.directiveFields.total_amount_untaxed = {
            type: 'related',
            value: this.node.children[2].attrs['t-value'],
            filter: function (field) {
                return _.contains(['many2one', 'float', 'monetary'], field.type);
            },
            followRelations: function (field) {
                return field.type === 'many2one';
            },
        };
        this.directiveFields.total_currency_id = {
            type: 'related',
            value: this.node.children[0].attrs['t-value'],
            filter: function (field) {
                return field.type === 'many2one';
            },
            followRelations: function (field) {
                return field.type === 'many2one' && field.relation !== 'res.currency';
            },
        };
        this.directiveFields.total_amount_total = {
            type: 'related',
            value: this.node.children[1].attrs['t-value'],
            filter: function (field) {
                return _.contains(['many2one', 'float', 'monetary'], field.type);
            },
            followRelations: function (field) {
                return field.type === 'many2one';
            },
        };
        this.directiveFields.total_amount_by_groups = {
            type: 'related',
            value: this.node.children[3].attrs['t-value'],
        };
    },
    /**
     * @override
     */
    start: function () {
        var self = this;
        return this._super.apply(this, arguments).then(function () {
            return Promise.all([
                self.fieldSelector.total_currency_id.appendTo(self.$('.o_web_studio_report_currency_id')),
                self.fieldSelector.total_amount_untaxed.appendTo(self.$('.o_web_studio_report_amount_untaxed')),
                self.fieldSelector.total_amount_total.appendTo(self.$('.o_web_studio_report_amount_total')),
                self.fieldSelector.total_amount_by_groups.appendTo(self.$('.o_web_studio_report_amount_by_groups'))
            ]);
        });
    },
    /**
     * @override
     */
    _triggerViewChange: function (newAttrs) {
        this._tSetAttributes(newAttrs);
    },
});

var Column = AbstractEditComponent.extend({
    name: 'column',
    template : 'web_studio.ReportColumn',
    selector: 'div[class*=col-]',
    /**
     * @override
     */
    init: function () {
        this._super.apply(this, arguments);

        this.classes = (this.node.attrs.class || "").split(' ');
        // TODO: deal with multiple classes (ex: col-6 col-md-3)
        this.sizeClass = _.find(this.classes, function (item) {
            return item.indexOf('col-') !== -1;
        }) || '';
        this.offsetClass = _.find(this.classes, function (item) {
            return item.indexOf('offset-') !== -1;
        }) || '';
        this.size = +this.sizeClass.split('col-')[1];
        this.offset = +this.offsetClass.split('offset-')[1];
        this.directiveFields.size = {
            type: 'integer',
            value: this.size,
        };
        this.directiveFields.offset = {
            type: 'integer',
            value: this.offset,
        };
    },
    /**
     * @override
     */
    start: function () {
        var self = this;
        return this._super.apply(this, arguments).then(function () {
            return Promise.all([
                self.fieldSelector.size.prependTo(self.$('.o_web_studio_size')),
                self.fieldSelector.offset.prependTo(self.$('.o_web_studio_offset'))
            ]);
        });
    },
    /**
     * @override
     */
    _triggerViewChange: function (newAttrs) {
        if ('size' in newAttrs && newAttrs.size >= 0) {
            this._editDomAttribute("class", 'col-' + newAttrs.size, this.sizeClass);
        } else if ('offset' in newAttrs && newAttrs.offset >= 0) {
            this._editDomAttribute("class", 'offset-' + newAttrs.offset, this.offsetClass);
        }
    },
});

var Table = AbstractEditComponent.extend({
    selector: 'table.o_report_block_table',
    blacklist: 'thead, tbody, tfoot, tr, td[colspan="99"]',
});

var TextSelectorTags = 'span, p, h1, h2, h3, h4, h5, h6, blockquote, pre, small, u, i, b, font, strong, ul, li, dl, dt, ol, th, td';
var filter = ':not([t-field]):not(:has(t, [t-' + QWeb2.ACTIONS_PRECEDENCE.join('], [t-field], [t-') + ']))';
var Text = AbstractEditComponent.extend({
    name: 'text',
    template : 'web_studio.ReportText',
    selector: TextSelectorTags.split(',').join(filter + ',') + filter,
    blacklist: TextSelectorTags,
    custom_events: {
        wysiwyg_blur: '_onBlurWysiwygEditor',
    },
    /**
     * @override
     */
    init: function () {
        this._super.apply(this, arguments);
        this.$node = $(utils.json_node_to_xml(this.node));
        this.$node.find('*').add(this.$node).each(function () {
                var node = this;
                _.each(Array.prototype.slice.call(node.attributes), function (attr) {
                    if (!attr.name.indexOf('data-oe-')) {
                        node.removeAttribute(attr.name);
                    }
                });
            });
        this.directiveFields.text = {
            type: 'text',
            value: utils.xml_to_str(this.$node[0]).split('>').slice(1).join('>').split('</').slice(0, -1).join('</'),
        };
    },
    /**
     * @override
     */
    start: function () {
        var self = this;
        return this._super.apply(this, arguments)
            .then(function () {
                return self.fieldSelector.text.appendTo(self.$('.o_web_studio_text'));
            }).then(function () {
                return self._startWysiwygEditor();
            });
    },

    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------

    _onBlurWysiwygEditor: function () {
        this._triggerViewChange({text: this.wysiwyg.getValue()});
    },
    _startWysiwygEditor: function () {
        var self = this;
        const options = {
            lang: "odoo",
            recordInfo: {context: this.context},
            value: this.directiveFields.text.value,
            resizable: true,
            toolbarTemplate: 'web_studio.Sidebar.web_editor_toolbar',
        };
        this.wysiwyg = new Wysiwyg(this, options);
        this.$textarea = this.$('textarea:first').val(this.directiveFields.text.value);

        this.$textarea.after(this.$wysiwygWrapper);
        this.$textarea.hide();

        this.$textarea.off().on('input', function (e) { // to test simple
            e.preventDefault();
            e.stopImmediatePropagation();
            self.wysiwyg.setValue($(this).val());
            self.wysiwyg.trigger_up('wysiwyg_blur');
        });

        return this.wysiwyg.insertAfter(this.$textarea);
    },
    /**
     * @override
     */
    _triggerViewChange: function (newAttrs) {
        var node = this.node;
        var $node = this.$node.clone().html(newAttrs.text);
        var xml = utils.xml_to_str($node[0]).replace(/ xmlns="[^"]+"/, "");
        this.trigger_up('view_change', {
            node: node,
            operation: {
                inheritance: [{
                    content: xml,
                    position: "replace",
                    view_id: +node.attrs['data-oe-id'],
                    xpath: node.attrs['data-oe-xpath']
                }],
            },
        });
    },
});

var Image = LayoutEditable.extend({
    name: 'image',
    template: 'web_studio.ReportImage',
    selector: 'img',
    /**
     * @override
     */
    init: function() {
        this._super.apply(this, arguments);
        this.directiveFields.src = {
            type: 'text', value: this.node.attrs.src
        };
    },
    /**
     * @override
     */
    start: function() {
        var self = this;
        return this._super.apply(this, arguments).then(function () {
            return self.fieldSelector.src.appendTo(self.$('.o_web_studio_source'));
        });
    },
});

var Groups = AbstractEditComponent.extend({
    name: 'groups',
    template: 'web_studio.ReportGroups',
    insertAsLastChildOfPrevious: true,
    /**
     * @override
     */
    init: function () {
        this._super.apply(this, arguments);

        var groups = this.node.attrs.studio_groups && JSON.parse(this.node.attrs.studio_groups);
        this.directiveFields.groups = {
            name: 'groups',
            fields: [{
                name: 'id',
                type: 'integer',
            }, {
                name: 'display_name',
                type: 'char',
            }],
            value: groups,
            relation: 'res.groups',
            type: 'many2many',
            Widget: 'many2many_tags',
        };
    },
    /**
     * @override
     */
    start: function() {
        var self = this;
        return this._super.apply(this, arguments).then(function () {
            return self.fieldSelector.groups.appendTo(self.$('.o_web_studio_groups'));
        });
    },
});

var TOptions = AbstractEditComponent.extend( {
    name: 'toptions',
    template : 'web_studio.ReportDirectiveTOptions',
    selector: '[t-field], [t-esc]',
    insertAsLastChildOfPrevious: true,
    events: _.extend({}, AbstractEditComponent.prototype.events, {
        'change select:first': '_onChangeWidget',
    }),
    /**
     * @override
     * @param {Object} [params.widgetsOptions]
     */
    init: function (parent, params) {
        this._super.apply(this, arguments);

        this.changes = {};
        this.widgetsOptions = params.widgetsOptions;

        // for contact widget, we don't want to display all options
        if (this.widgetsOptions && this.widgetsOptions.contact) {
            this.widgetsOptions.contact = _.pick(this.widgetsOptions.contact, [
                'fields',
                'separator',
                'no_marker',
            ]);
        }

        this.widget = null;  // the selected widget
        this.values = {};  // dict containing the t-options values

        this._extractTOptions();
    },
    /**
     * @override
     */
    willStart: function () {
        var self = this;

        // create fields for each widget options
        var directiveFields = this.directiveFields;
        this.widgets = _.map(this.widgetsOptions, function (widgetConf, widgetKey) {
            var values = self.values.widget === widgetKey ? self.values : {};

            var options = _.map(widgetConf, function (option, optionKey) {
                option.key = optionKey;
                if (option.default_value) {
                    option.default_value = option.default_value;
                }
                var required = typeof option.required === 'string' ?
                        option.required === 'value_to_html' && !('t-field' in self.node.attrs) :
                        option.required;
                var params = {
                    key: option.key,
                    string: option.string,
                    required: required,
                    attributeName: 't-options-' + optionKey,
                    value: values[optionKey],
                };
                switch (option.type) {
                    case 'model':
                        params.type = 'related';
                        //filter => m2o > model name
                        break;
                    case 'boolean':
                        params.type = 'boolean';
                        break;
                    case 'select':
                        params.type = 'selection';
                        params.selection = option.params;
                        break;
                    case 'float':
                        params.type = 'float';
                        break;
                    case 'integer':
                        params.type = 'integer';
                        break;
                    case 'date':
                    case 'datetime':
                        params.type = 'related';
                        params.filter = function (field) {
                            return field.type === 'many2one' || field.type === 'datetime';
                        };
                        params.followRelations = function (field) {
                            return field.type === 'many2one';
                        };
                        // free object date / datetime
                        params.freecode = true;
                        break;
                    case 'array':
                        if (option.params && option.params.type === 'selection') {
                            params.type = 'many2many';
                            params.Widget = 'many2many_select';
                            params.value = params.value && params.value.length ? params.value : option.default_value || [];
                            params.selection = option.params.params;
                        } else {
                            params.type = 'char';
                            params.value = JSON.stringify(params.value);
                        }
                        break;
                    case 'selection':
                        if (option.params && option.params.type === 'selection' && option.params.selection) {
                            params.type = option.params.type;
                            params.value = params.value ? params.value : option.default_value || false;
                            params.placeholder = option.params.placeholder || '';
                            params.selection = option.params.selection || [];
                        } else {
                            params.type = 'char';
                        }
                        break;
                    default:
                        params.type = 'char';
                }

                directiveFields[widgetKey + ':' + optionKey] = params;

                return params;
            });
            options.sort(function (a, b) {
                return (a.type === 'boolean' && b.type === 'boolean' ?
                        a.string.localeCompare(b.string) :
                        a.type === 'boolean' && a.key !== 'no_marker' ? -1 : 1);
            });

            return {
                key: widgetKey,
                string: widgetKey,
                options: options,
            };
        });
        this.widgets.sort(function (a, b) {
            return a.string.localeCompare(b.string);
        });

        // selected widget
        this.widget = _.findWhere(this.widgets, {key: this.values.widget && this.values.widget});

        return this._super.apply(this, arguments);
    },
    /**
     * @override
     */
    start: function () {
        var defs = [this._super.apply(this, arguments)];
        if (this.widget) {
            this.$('.o_web_studio_toption_widget select').val(this.widget.key);
            defs.push(this._updateWidgetOptions());
        }
        return Promise.all(defs);
    },

    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------

    /**
     * Extracts t-options widget and options for this node.
     *
     * @private
     */
    _extractTOptions: function () {
        this.values = py.extract(this.node.attrs['t-options'] || '{}');
        for (var k in this.node.attrs) {
            if (k.slice(0, 10) === 't-options-') {
                this.values[k.slice(10)] = py.extract(this.node.attrs[k]);
            }
        }
    },
    /**
     * @private
     * @returns {Promise}
     */
    _updateWidgetOptions: function () {
        var self = this;
        this.$('button').toggleClass('hidden', !this.widget || !this.widget.options.length);
        this.$('.o_web_studio_toption_options').remove();
        if (!this.widget || !this.widget.options.length) {
            return;
        }
        var $options = $(qweb.render('web_studio.ReportDirectiveTOptions.options', this));
        var mountedComponents = [];
        var defs = _.map(this.widget.options, function (option) {
            var $option = $options.find('.o_web_studio_toption_option_' + self.widget.key + '_' + option.key);
            var field = self.fieldSelector[self.widget.key + ':' + option.key];
            if (field instanceof owl.Component) {
                mountedComponents.push(field);
                if (option.type === "boolean") {
                    return field.mount($option.find('label')[0], {position: 'first-child'});
                } else {
                    return field.mount($option[0]);
                }
            } else {
                if (option.type === "boolean") {
                    return field.prependTo($option.find('label'));
                } else {
                    return field.appendTo($option);
                }
            }

        });
        return Promise.all(defs).then (function () {
            self.$el.find('.o_studio_report_options_container').append($options);
            if (!self.isDestroyed()) {
                mountedComponents.forEach(widget => widget.on_attach_callback());
            }
        });
    },
    /**
     * @private
     * @override
     */
    _triggerViewChange: function (newAttrs) {
        var self = this;
        var changes = {};

        // this.widget is the recently set `widget` key
        if (this.widget) {
            var options = _.findWhere(this.widgets, {key: this.widget.key}).options;

            if (this.values.widget !== this.widget.key) {
                changes['t-options-widget'] = '"' + this.widget.key + '"';
            }
            _.each(newAttrs, function (val, key) {
                var field = key.split(':');
                if (self.widget.key === field[0]) {
                    var option = _.findWhere(options, {key: field[1]});
                    var value = val;
                    if (value) {
                        if (option.type === 'char' || option.type === 'selection') {
                            value = '"' + val.replace(/"/g, '\\"') + '"';
                        }
                    }

                    if (option.format) {
                        value = option.format(value);
                    }

                    if ((self.widget.key !== self.values.widget || value !== self.values[key])) {
                        changes['t-options-' + field[1]] = value;
                    }
                }
            });
        } else {
            changes['t-options-widget'] = '""';
            // TODO: remove all other set t-options-..
            // t-options='"{}"' doesn't work because t-options-.. has precedence
        }
        this.trigger_up('view_change', {
            node: this.node,
            operation: {
                type: 'attributes',
                new_attrs: changes,
            },
        });
    },
    //--------------------------------------------------------------------------
    // Handlers
    //--------------------------------------------------------------------------
    /**
     * @private
     * @param {OdooEvent} ev
     */
    _onChangeWidget: function (ev) {
        var widget = _.findWhere(this.widgets, {key: $(ev.target).val()});
        if (widget !== this.widget) {
            this.widget = widget;
            this._triggerViewChange({});
        }
        this._updateWidgetOptions();
    },
    /**
     * @override
     */
    _onDirectiveChange: function (e) {
        if (e.target.name === 'contact:fields') {
            // this field uses a special FieldWidget (many2many_select) which is
            // not a real FieldWidget so the changes are not formatted as
            // expected
            e.stopPropagation();
            var changes = _.clone(e.data.changes);
            var key = _.keys(changes)[0];
            changes[key] = changes[key].ids;
            this._triggerViewChange(changes);
        } else {
            this._super.apply(this, arguments);
        }
    },
});

return {
    BlockTotal: BlockTotal,
    Column: Column,
    Groups: Groups,
    Image: Image,
    LayoutEditable: LayoutEditable,
    Table: Table,
    Text: Text,
    TField: TField,
    TForeach: TForeach,
    TElse: TElse,
    TEsc: TEsc,
    TIf: TIf,
    TOptions: TOptions,
    TSet: TSet,
};

});
;

/******************************************************************************************************
*  Filepath: /web_studio/static/src/legacy/js/reports/sidebar_components/edit_components_registry.js  *
*  Bundle: web_studio.studio_assets                                                                   *
*  Lines: 27                                                                                          *
******************************************************************************************************/
odoo.define('web_studio.reportEditComponentsRegistry', function (require) {
"use strict";

var Registry = require('web.Registry');
var reportEditComponents = require('web_studio.reportEditComponents');

var registry = new Registry();

registry
    .add('column', reportEditComponents.Column)
    .add('groups', reportEditComponents.Groups)
    .add('layout', reportEditComponents.LayoutEditable)
    .add('image', reportEditComponents.Image)
    .add('table', reportEditComponents.Table)
    .add('text', reportEditComponents.Text)
    .add('total', reportEditComponents.BlockTotal)
    .add('tEsc', reportEditComponents.TEsc)
    .add('tElse', reportEditComponents.TElse)
    .add('tField', reportEditComponents.TField)
    .add('tForeach', reportEditComponents.TForeach)
    .add('tIf', reportEditComponents.TIf)
    .add('tOptions', reportEditComponents.TOptions)
    .add('tSet', reportEditComponents.TSet);

return registry;

});
;

/****************************************************************************************************
*  Filepath: /web_studio/static/src/legacy/js/reports/sidebar_components/report_building_blocks.js  *
*  Bundle: web_studio.studio_assets                                                                 *
*  Lines: 928                                                                                       *
****************************************************************************************************/
odoo.define('web_studio.reportNewComponents', function (require) {
"use strict";

var config = require('web.config');
var core = require('web.core');
var Dialog = require('web.Dialog');
var weWidgets = require('wysiwyg.widgets');

var Abstract = require('web_studio.AbstractReportComponent');
var NewFieldDialog = require('web_studio.NewFieldDialog');

var _t = core._t;
var _lt = core._lt;

var AbstractNewBuildingBlock = Abstract.extend({
    type: false,
    structure: false,
    label: false,
    fa: false,
    description: false,
    addEmptyRowsTargets: true,
    events: _.extend({}, Abstract.prototype.events, {
        mouseenter: '_onHover',
        focusin: '_onHover',
        mouseleave: '_onStopHover',
        focusout: '_onStopHover',
    }),
    /**
     * @override
     */
    start: function () {
        var self = this;
        this.$el.addClass('o_web_studio_component');
        this.$el.text(this.label);
        if (this.fa) {
            this.$el.append('<i class="fa ' + this.fa + '">');
        }
        if (config.isDebug() && this.description) {
            this.$el.addClass('o_web_studio_debug');
            this.$el.append($('<div>')
                .addClass('o_web_studio_component_description')
                .text(this.description)
            );
        }
        var dragFunction = _.cancellableThrottleRemoveMeSoon(function (e) {
                self.trigger_up('drag_component', {
                    position: { pageX: e.pageX, pageY: e.pageY },
                    widget: self,
                });
            }, 100);
        this.$el.draggable({
            helper: 'clone',
            opacity: 0.4,
            scroll: false,
            // revert: 'invalid',  // this causes _setTimeout in tests for stop
            revertDuration: 200,
            refreshPositions: true,
            iframeFix: true,
            start: function (e, ui) {
                $(ui.helper).addClass("ui-draggable-helper");
                self.trigger_up('begin_drag_component', {
                    widget: self
                });
            },
            drag: dragFunction,
            stop: function (e) {
                dragFunction.cancel();
                self.trigger_up('drop_component', {
                    position: { pageX: e.pageX, pageY: e.pageY },
                    widget: self,
                });
            }
        });

        return this._super.apply(this, arguments);
    },

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    /**
     * To be overriden.
     *
     * @param {Object} options
     * @param {Object[]} options.targets
     * @param {Integer} [options.oeIndex]
     * @returns {Promise<Object>}
     */
    add: function (options) {
        this.targets = options.targets;
        var first = options.targets[0];
        this.index = first.data.oeIndex;
        this.position = first.data.oePosition;
        this.node = first.node;
        return Promise.resolve({
            type: this.type,
            options: {
                columns: this.dropColumns,
                index: first.data.oeIndex,
            },
        });
    },
    //--------------------------------------------------------------------------
    // Handlers
    //--------------------------------------------------------------------------
    /**
     * @private
     * @param {MouseEvent} e
     */
    _onHover: function (e) {
        this.trigger_up('begin_preview_drag_component', {
            widget: this,
        });
    },

    /**
     * @private
     * @param {MouseEvent} e
     */
    _onStopHover: function (e) {
        this.trigger_up('end_preview_drag_component', {
            widget: this,
        });
    },
    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------
    /**
     * create td and th in table, manage colspan.
     *
     * @param {Object} options
     * @param {string} options.head
     * @param {string} options.headLoop
     * @param {string} options.body
     * @param {string} options.bodyLoop
     * @param {string} options.foot
     * @param {string} options.footLoop
     * @returns {Object}
     */
    _createReportTableColumn: function (options) {
        var self = this;
        var inheritance = [];
        var updatedNodes = [];

        // add cells in rows

        _.each(this.targets, function (target) {
            var node = target.node;
            var inheritanceItem;
            if (node.tag === 'th' || node.tag === 'td') {
                var loop = self._findParentWithTForeach(node) ? true : false;
                var dataName = loop ? 'Loop' : '';
                var content = '<' + node.tag + '>';
                if (node.tag === 'th' || node.parent.parent.tag === 'thead') {
                    content += options['head' + dataName] || options.head || '';
                } else if (node.parent.parent.tag === 'tfoot') {
                    content += options['foot' + dataName] || options.foot || '';
                } else {
                    content += options['body' + dataName] || options.body || '';
                }
                content += '</' + node.tag + '>';

                updatedNodes.push(node);
                inheritanceItem = {
                    content: content,
                    position: target.position,
                    xpath: node.attrs['data-oe-xpath'],
                    view_id: +node.attrs['data-oe-id'],
                };
            } else if (node.tag === 'tr') {
                updatedNodes.push(node);
                inheritanceItem = {
                    content: '<td>' + (options.tbody || '') + '</td>',
                    position: target.position,
                    xpath: node.attrs['data-oe-xpath'],
                    view_id: +node.attrs['data-oe-id'],
                };
            }
            inheritance.push(inheritanceItem);
        });

        // colspan
        var cellsToGrow = [];
        _.each(this.targets, function (target) {
            var node = target.node;
            if (target.position !== 'after') {
                return;
            }

            // define td index

            var nodeIndex = 0;
            var nodeRow = self._getParentNode(node, function (node) { return node.tag === 'tr'; });
            var cells = self._getChildrenNode(nodeRow, function (node) { return node.tag === 'td' || node.tag === 'th'; });
            for (var k = 0; k < cells.length; k++) {
                nodeIndex += +(cells[k].attrs.colspan || 1);
                if (cells[k] === node) {
                    break;
                }
            }

            // select colspan to grow

            var table = self._getParentNode(node, function (node) { return node.tag === 'table'; });
            var rows = self._getChildrenNode(table, function (node) { return node.tag === 'tr'; });
            _.each(rows, function (row) {
                if (row === nodeRow) {
                    return;
                }

                var cells = self._getChildrenNode(row, function (node) { return node.tag === 'td' || node.tag === 'th'; });

                var cellIndex = 0;
                for (var k = 0; k < cells.length; k++) {
                    var cell = cells[k];
                    cellIndex += +(cell.attrs.colspan || 1);
                    if (cellIndex >= nodeIndex) {
                        if (((+cell.attrs.colspan) > 1) && cellsToGrow.indexOf(cell) === -1) {
                            cellsToGrow.push(cell);
                        }
                        break;
                    }
                }
            });
        });
        _.each(cellsToGrow, function (node) {
            inheritance.push({
                content: '<attribute name="colspan">' + ((+node.attrs.colspan) + 1) + '</attribute>',
                position: 'attributes',
                xpath: node.attrs['data-oe-xpath'],
                view_id: +node.attrs['data-oe-id'],
            });
        });

        return inheritance;
    },
    _createStructure: function (options) {
        var xml = ['<div class="row'];
        if (this.structureClass) {
            xml.push(' ' + this.structureClass);
        }
        xml.push('">');
        for (var k = 0; k < this.dropColumns.length; k++) {
            var column = this.dropColumns[k];
            xml.push('<div class="col-');
            xml.push(column[1]);
            if (column[0]) {
                xml.push(' offset-');
                xml.push(column[0]);
            }
            xml.push('">');
            if (options.content && (k === options.index || options.fillStructure)) {
                xml.push(options.content);
            }
            xml.push('</div>');
        }
        xml.push('</div>');

        return [{
            content: xml.join(''),
            position: this.position,
            xpath: this.node.attrs['data-oe-xpath'],
            view_id: +this.node.attrs['data-oe-id'],
        }];
    },
    _createContent: function (options) {
        if (this.dropColumns && typeof this.index === 'number') {
            return this._createStructure({
                index: this.index,
                content: options.contentInStructure || options.content,
                fillStructure: options.fillStructure || false,
            });
        } else {
            return _.map(this.targets, function (target) {
                var isCol = (target.node.attrs.class || '').match(/(^|\s)(col(-[0-9]+)?)(\s|$)/);
                return {
                    content: isCol ? options.contentInStructure || options.content : options.content,
                    position: target.position,
                    xpath: target.node.attrs['data-oe-xpath'],
                    view_id: +target.node.attrs['data-oe-id'],
                };
            });
        }
    },
    _getParentNode: function (node, fn) {
        while (node) {
            if (fn(node)) {
                return node;
            }
            node = node.parent;
        }
    },
    /**
     * TODO: rewrite this function
     */
    _getChildrenNode: function (parent, fn) {
        var children = [];
        var stack = [parent];
        parent = stack.shift();
        while (parent) {
            if (parent.children) {
                for (var k = 0; k < parent.children.length; k++) {
                    var node = parent.children[k];
                    if (fn(node)) {
                        children.push(node);
                    }
                }
                stack = parent.children.concat(stack);
            }
            parent = stack.shift();
        }
        return children;
    },
    /**
     * Goes through the hierachy of parents of the node in parameter until we
     * find the closest parent with a t-foreach defined on it.
     *
     * @private
     * @param {Object} node
     * @returns {Object|undefined} node that contains a t-foreach as parent of the node in parameter
     */
    _findParentWithTForeach: function (node) {
        if (!node || !node.parent || (node.tag === "div" && node.attrs.class === "page")) {
            return;
        }
        if (node.attrs["t-foreach"]) {
            return node;
        }
        return this._findParentWithTForeach(node.parent);
    },
});
var TextSelectorTags = 'span, p, h1, h2, h3, h4, h5, h6, blockquote, pre, small, u, i, b, font, strong, ul, li, dl, dt, ol, .page > .row > div:empty';
var filter = ':not([t-field]):not(:has(t, [t-' + QWeb2.ACTIONS_PRECEDENCE.join('], [t-') + ']))';

// ----------- TEXT -----------

var BlockText = AbstractNewBuildingBlock.extend({
    type: 'text',
    label: _lt('Text'),
    dropIn: '.page',
    className: 'o_web_studio_field_char',
    hookClass: 'o_web_studio_block_char',
    add: function () {
        var self = this;
        return this._super.apply(this, arguments).then(function () {
            return Promise.resolve({
                inheritance: self._createContent({
                    content: '<div class="row"><div class="col"><span>New Text Block</span></div></div>',
                })
            });
        });
    },
});

var InlineText = AbstractNewBuildingBlock.extend({
    type: 'text',
    label: _lt('Text'),
    className: 'o_web_studio_field_char',
    hookClass: 'o_web_studio_hook_inline',
    hookAutoHeight: true,
    dropIn: TextSelectorTags.split(',').join(filter + '|') + filter,
    selectorSeparator: '|',
    hookTag: 'span',
    add: function () {
        var self = this;
        return this._super.apply(this, arguments).then(function () {
            return Promise.resolve({
                inheritance: self._createContent({
                    content: '<span>New Text Block</span>',
                })
            });
        });
    },
});

var ColumnHalfText = AbstractNewBuildingBlock.extend({
    type: 'text',
    label: _lt('Two Columns'),
    dropIn: '.page',
    className: 'o_web_studio_field_fa',
    fa: 'fa-align-left',
    hookClass: 'o_web_studio_block_char',
    hookTag: 'div',
    dropColumns: [[0, 6], [0, 6]],
    addEmptyRowsTargets: false,
    add: function () {
        var self = this;
        return this._super.apply(this, arguments).then(function () {
            return Promise.resolve({
                inheritance: self._createContent({
                    fillStructure: true,
                    contentInStructure: '<span>New Column</span>',
                })
            });
        });
    },
});

var ColumnThirdText = AbstractNewBuildingBlock.extend({
    type: 'text',
    label: _lt('Three Columns'),
    dropIn: '.page',
    className: 'o_web_studio_field_fa',
    fa: 'fa-align-left',
    hookClass: 'o_web_studio_block_char',
    hookTag: 'div',
    dropColumns: [[0, 4], [0, 4], [0, 4]],
    addEmptyRowsTargets: false,
    add: function () {
        var self = this;
        return this._super.apply(this, arguments).then(function () {
            return Promise.resolve({
                inheritance: self._createContent({
                    fillStructure: true,
                    contentInStructure: '<span>New Column</span>',
                })
            });
        });
    },
});

var TableCellText = AbstractNewBuildingBlock.extend({
    type: 'text',
    label: _lt('Text in Cell'),
    className: 'o_web_studio_field_char',
    hookAutoHeight: false,
    hookClass: 'o_web_studio_hook_inline',
    dropIn: 'td, th',
    hookTag: 'span',
    add: function () {
        var self = this;
        return this._super.apply(this, arguments).then(function () {
            return Promise.resolve({
                inheritance: self._createContent({
                    content: '<span>New Text Block</span>',
                })
            });
        });
    },
});


// ----------- FIELD -----------
/**
 * Defines the behavior of a field building block. It behaves by default by asking
 * the user to select a field in a model, and takes the first target as
 * destination node
 */
var AbstractFieldBlock = AbstractNewBuildingBlock.extend({
    type: 'field',
    add: function () {
        var self = this;
        return self._super.apply(this, arguments).then(function() {
            return new Promise(function (resolve, reject) {
                var field = {
                    order: 'order',
                    type: 'related',
                    filters: { searchable: false },
                filter: function (field) {
                    // For single fields (i.e. NOT a table), forbid putting x2many's
                    // Because it just doesn't make sense otherwise
                    return ! _.contains(['one2many', 'many2many'], field.type);
                }
                };

                var target = self.targets[0];
                if (self._filterTargets) {
                    target = self._filterTargets() || target;
                }

                var availableKeys = _.filter(self._getContextKeys(target.node), function (field) {
                    // "docs" is a technical object referring to all records selected to issue the report for
                    // it shouldn't be manipulated by the user
                    return !!field.relation && field.name !== 'docs';
                });
                var fieldChain = [];
                if (availableKeys.length) {
                    fieldChain.push(_.first(availableKeys).name);
                }
                var dialog = new NewFieldDialog(self, 'record_fake_model', field, availableKeys, fieldChain).open();
                dialog.on('field_default_values_saved', self, function (values) {
                    if (values.related.split('.').length < 2) {
                        Dialog.alert(self, _t('The record field name is missing'));
                    } else {
                        resolve({
                            inheritance: self._dataInheritance(values),
                        });
                        dialog.close();
                    }
                });
                dialog.on('closed', self, function () {
                    reject();
                });
            });
        });
    },
});

var BlockField = AbstractFieldBlock.extend({
    label: _lt('Field'),
    className: 'o_web_studio_field_many2one',
    hookClass: 'o_web_studio_hook_field',
    dropIn: '.page',
    _dataInheritance: function (values) {
        var $field = $('<span/>').attr('t-field', values.related);
        if (values.type === 'binary') {
            $field.attr('t-options-widget', '"image"');
        }
        var fieldHTML = $field.prop('outerHTML');

        return this._createContent({
            content: "<div class='row'><div class='col'>" + fieldHTML + "</div></div>",
        });
    },
});

var InlineField = AbstractFieldBlock.extend({
    label: _lt('Field'),
    className: 'o_web_studio_field_many2one',
    hookClass: 'o_web_studio_hook_inline',
    hookAutoHeight: true,
    dropIn: TextSelectorTags.split(',').join(filter + '|') + filter,
    selectorSeparator: '|',
    hookTag: 'span',
    _dataInheritance: function (values) {
        var $field = $('<span/>').attr('t-field', values.related);
        if (values.type === 'binary') {
            $field.attr('t-options-widget', '"image"');
        }
        var fieldHTML = $field.prop('outerHTML');
        if (this.node.tag === 'td' || this.node.tag === 'th') {
            return this._createReportTableColumn({
                head: $('<span/>').text(values.string).prop('outerHTML'),
                bodyLoop: fieldHTML,
            });
        } else {
            return this._createContent({
                content: fieldHTML,
            });
        }
    },
    _filterTargets: function () {
        var self = this;
        var target = this.targets[0];
        if (this.targets.length > 1 && (target.node.tag === 'td' || target.node.tag === 'th')) {
            target = _.find(this.targets, function (target) {
                return self._findParentWithTForeach(target.node) ? true : false;
            });
        }
        return target;
    },
});

var TableColumnField = AbstractFieldBlock.extend({
    label: _lt('Field Column'),
    className: 'o_web_studio_field_fa',
    fa: ' fa-plus-square',
    hookAutoHeight: true,
    hookClass: 'o_web_studio_hook_table_column',
    dropIn: 'tr',
    _dataInheritance: function (values) {
        var $field = $('<span/>').attr('t-field', values.related);
        if (values.type === 'binary') {
            $field.attr('t-options-widget', '"image"');
        }
        var fieldHTML = $field.prop('outerHTML');
        if (this.node.tag === 'td' || this.node.tag === 'th') {
            // add content either in looped cells, or if no loop in normal cells
            var targetInLoop = _.find(this.targets, function (target) {
                return this._findParentWithTForeach(target.node);
            }.bind(this)) ? true : false;
            return this._createReportTableColumn({
                head: $('<span/>').text(values.string).prop('outerHTML'),
                body: targetInLoop ? undefined : fieldHTML,
                bodyLoop: targetInLoop ? fieldHTML : undefined,
            });
        } else {
            return this._createContent({
                contentInStructure: '<span><strong>' + values.string + ':</strong><br/></span>' + fieldHTML,
                content: fieldHTML,
            });
        }
    },
    _filterTargets: function () {
        var self = this;
        var target = this.targets[this.targets.length - 1];
        if (this.targets.length > 1) {
            target = _.find(this.targets, function (target) {
                return self._findParentWithTForeach(target.node) ? true : false;
            });
        }
        return target;
    },
});

var TableCellField = AbstractFieldBlock.extend({
    label: _lt('Field in Cell'),
    className: 'o_web_studio_field_many2one',
    hookAutoHeight: false,
    hookClass: 'o_web_studio_hook_inline',
    dropIn: 'td, th',
    hookTag: 'span',
    _dataInheritance: function (values) {
        var $field = $('<span/>').attr('t-field', values.related);
        if (values.type === 'binary') {
            $field.attr('t-options-widget', '"image"');
        }
        var fieldHTML = $field.prop('outerHTML');
        if (this.node.tag === 'td' || this.node.tag === 'th') {
            return this._createReportTableColumn({
                head: $('<span/>').text(values.string).prop('outerHTML'),
                bodyLoop: fieldHTML,
            });
        } else {
            return this._createContent({
                contentInStructure: '<span><strong>' + values.string + ':</strong><br/></span>' + fieldHTML,
                content: fieldHTML,
            });
        }
    },
    _filterTargets: function () {
        var self = this;
        var target = this.targets[0];
        if (this.targets.length > 1) {
            target = _.find(this.targets, function (target) {
                return self._findParentWithTForeach(target.node) ? true : false;
            }) ;
        }
        return target;
    },
});

var LabelledField = AbstractFieldBlock.extend({
    label: _lt('Field & Label'),
    className: 'o_web_studio_field_many2one',
    hookClass: 'o_web_studio_hook_information',
    dropColumns: [[0, 3], [0, 3], [0, 3], [0, 3]],
    hookAutoHeight: false,
    dropIn: '.page, .row > div.col*:empty',
    _dataInheritance: function (values) {
        var $field = $('<span/>').attr('t-field', values.related);
        if (values.type === 'binary') {
            $field.attr('t-options-widget', '"image"');
        }
        var fieldHTML = $field.prop('outerHTML');

        return this._createContent({
            contentInStructure: '<span><strong>' + values.string + ':</strong><br/></span>' + fieldHTML,
            content: fieldHTML,
        });
    },
});



// ----------- OTHER -----------

var Image = AbstractNewBuildingBlock.extend({
    type: 'image',
    label: _lt('Image'),
    dropIn: '.page',
    className: 'o_web_studio_field_picture',
    hookClass: 'o_web_studio_hook_picture',
    add: function () {
        var self = this;
        return this._super.apply(this, arguments).then(function () {
            var def = new Promise(function (resolve, reject) {
                var $image = $("<img/>");
                var dialog = new weWidgets.MediaDialog(self, {
                    onlyImages: true,
                }, $image[0]).open();
                var value;
                dialog.on("save", self, function (el) {
                    // el is a vanilla JS element
                    // Javascript Element.src returns the full url (including protocol)
                    // But we want only a relative path
                    // https://www.w3schools.com/jsref/prop_img_src.asp
                    // We indeed expect only one image at this point
                    value = el.attributes.src.value;
                });
                dialog.on('closed', self, function () {
                    if (value) {
                        resolve({
                            inheritance: self._createContent({
                                content: '<img class="img-fluid" src="' + value + '"/>',
                            })
                        });
                    } else {
                        reject();
                    }
                });
            });
            return def;
        });
    },
});

var BlockTitle = AbstractNewBuildingBlock.extend({
    type: 'block_title',
    label: _lt('Title Block'),
    className: 'o_web_studio_field_char',
    hookClass: 'o_web_studio_hook_title',
    dropIn: '.page',
    add: function () {
        var self = this;
        return this._super.apply(this, arguments).then(function () {
            return Promise.resolve({
                inheritance: [{
                    content: '<div class="row"><div class="col h2"><span>New Title</span></div></div>',
                    position: self.position,
                    xpath: self.node.attrs['data-oe-xpath'],
                    view_id: +self.node.attrs['data-oe-id'],
                }],
            });
        });
    },
});

var BlockAddress = AbstractNewBuildingBlock.extend({
    type: 'block_address',
    label: _lt('Address Block'),
    fa: 'fa-address-card',
    className: 'o_web_studio_field_fa',
    hookAutoHeight: false,
    hookClass: 'o_web_studio_hook_address',
    structureClass: 'address',
    dropColumns: [[0, 5], [2, 5]],
    add: function () {
        var self = this;
        var callersArguments = arguments;
        return new Promise(function (resolve, reject) {
            self._super.apply(self, callersArguments).then(function () {
                var field = {
                    order: 'order',
                    type: 'related',
                    filters: {},
                    filter: function (field) {
                        return field.type === 'many2one';
                    },
                    followRelations: function (field) {
                        return field.type === 'many2one' && field.relation !== 'res.partner';
                    },
                };
                var availableKeys = self._getContextKeys(self.node);
                // TODO: maybe filter keys to only get many2one fields to res.partner?
                // For reports, set the current model ('doc') by default
                // in 'ModelFieldSelector' whenever available
                var fieldChain = [];
                if (availableKeys.length) {
                    fieldChain.push(_.first(availableKeys).name);
                }
                var dialog = new NewFieldDialog(self, 'record_fake_model', field, availableKeys, fieldChain).open();
                dialog.on('field_default_values_saved', self, function (values) {
                    if (!_.contains(values.related, '.')) {
                        Dialog.alert(self, _t('Please specify a field name for the selected model.'));
                        return;
                    }
                    if (values.relation === 'res.partner') {
                        resolve({
                            inheritance: self._createContent({
                                content: '<div t-field="' + values.related + '" t-options-widget="\'contact\'"/>',
                            })
                        });
                        dialog.close();
                    } else {
                        Dialog.alert(self, _t('You can only display a user or a partner'));
                    }
                });
                dialog.on('closed', self, function () {
                    reject();
                });
            });
        });
    },
});

var BlockTable = AbstractNewBuildingBlock.extend({
    type: 'block_table',
    label: _lt('Data table'),
    fa: 'fa-th-list',
    className: 'o_web_studio_field_fa',
    hookClass: 'o_web_studio_hook_table',
    dropIn: '.page',
    add: function () {
        var self = this;
        var callersArguments = arguments;
        return new Promise(function (resolve, reject) {
            self._super.apply(self, callersArguments).then(function () {
                var field = {
                    order: 'order',
                    type: 'related',
                    filters: {},
                    filter: function (field) {
                        return field.type === 'many2one' || field.type === 'one2many' || field.type === 'many2many';
                    },
                    followRelations: function (field) {
                        return field.type === 'many2one';
                    },
                };
                var availableKeys = self._getContextKeys(self.node);
                // For reports, set the current model ('doc') by default
                // in 'ModelFieldSelector' whenever available
                var fieldChain = [];
                if (availableKeys.length) {
                    fieldChain.push(_.first(availableKeys).name);
                }
                var dialog = new NewFieldDialog(self, 'record_fake_model', field, availableKeys, fieldChain).open();
                dialog.on('field_default_values_saved', self, function (values) {
                    if (values.type === 'one2many' || values.type === 'many2many') {
                        resolve({
                            inheritance: self._dataInheritance(values),
                        });
                        dialog.close();
                    } else {
                        Dialog.alert(self, _t('You need to use a many2many or one2many field to display a list of items'));
                    }
                });
                dialog.on('closed', self, function () {
                    reject();
                });
            });
        });
    },
    _dataInheritance: function (values) {
        var target = this.targets[0];
        return [{
            content:
                '<table class="table o_report_block_table">' +
                '<thead>' +
                '<tr>' +
                '<th><span>Name</span></th>' +
                '</tr>' +
                '</thead>' +
                '<tbody>' +
                '<tr t-foreach="' + values.related + '" t-as="table_line">' +
                '<td><span t-field="table_line.display_name"/></td>' +
                '</tr>' +
                '</tbody>' +
                '</table>',
            position: target.position,
            xpath: target.node.attrs['data-oe-xpath'],
            view_id: +target.node.attrs['data-oe-id'],
        }];
    },
});

var TableBlockTotal = AbstractNewBuildingBlock.extend({
    type: 'block_total',
    label: _lt('Subtotal & Total'),
    fa: 'fa-money',
    className: 'o_web_studio_field_fa',
    dropIn: '.page',
    hookClass: 'o_web_studio_hook_total',
    dropColumns: [[0, 5], [2, 5]],
    add: function () {
        var self = this;
        var callersArguments = arguments;
        return new Promise(function (resolve, reject) {
            self._super.apply(self, callersArguments).then(function () {
                var field = {
                    order: 'order',
                    type: 'related',
                    filters: {},
                    filter: function (field) {
                        return field.type === 'many2one';
                    },
                    followRelations: function (field) {
                        return field.type === 'many2one' &&
                            field.relation !== 'account.move' && field.relation !== 'sale.order' && field.relation !== 'purchase.order';
                    },
                };
                var availableKeys = self._getContextKeys(self.node);
                // For reports, set the current model ('doc') by default
                // in 'ModelFieldSelector' whenever available
                var fieldChain = [];
                if (availableKeys.length) {
                    fieldChain.push(_.first(availableKeys).name);
                }
                var dialog = new NewFieldDialog(self, 'record_fake_model', field, availableKeys, fieldChain).open();
                dialog.on('field_default_values_saved', self, function (values) {
                    resolve({
                        inheritance: self._dataInheritance(values),
                    });
                    dialog.close();
                });
                dialog.on('closed', self, function () {
                    reject();
                });
            });
        });
    },
    _dataInheritance: function (values) {
        var data = this._dataInheritanceValues(values);
        return this._createContent({
            contentInStructure: 
                '<table class="table table-sm">' +
                    `<t t-set="tax_totals" t-value="json.loads(${data.tax_totals_json})"/>` +
                    '<t t-call="account.document_tax_totals"/>' +
                '</table>'
        });
    },
    _dataInheritanceValues: function (values) {
        const tax_totals_json = `${values.related}.tax_totals_json`;
        return { tax_totals_json };
    },
});


return {
    BlockText: BlockText,
    InlineText: InlineText,
    ColumnHalfText: ColumnHalfText,
    ColumnThirdText: ColumnThirdText,
    TableCellText: TableCellText,
    BlockField: BlockField,
    InlineField: InlineField,
    TableColumnField: TableColumnField,
    TableCellField: TableCellField,
    LabelledField: LabelledField,
    Image: Image,
    BlockTitle: BlockTitle,
    BlockAddress: BlockAddress,
    BlockTable: BlockTable,
    TableBlockTotal: TableBlockTotal,
};

});
;

/*************************************************************************************************************
*  Filepath: /web_studio/static/src/legacy/js/reports/sidebar_components/report_building_blocks_registry.js  *
*  Bundle: web_studio.studio_assets                                                                          *
*  Lines: 39                                                                                                 *
*************************************************************************************************************/
odoo.define('web_studio.reportNewComponentsRegistry', function (require) {
"use strict";

var core = require('web.core');
var Registry = require('web.Registry');
var reportNewComponents = require('web_studio.reportNewComponents');

var _lt = core._lt;

var registry = new Registry();

registry
    .add(_lt('Block'), [
        reportNewComponents.BlockText,
        reportNewComponents.BlockField,
        reportNewComponents.BlockTitle,
        reportNewComponents.LabelledField,
        reportNewComponents.Image,
        reportNewComponents.BlockAddress,
    ])
    .add(_lt('Inline'), [
        reportNewComponents.InlineText,
        reportNewComponents.InlineField,
    ])
    .add(_lt('Table'), [
        reportNewComponents.BlockTable,
        reportNewComponents.TableColumnField,
        reportNewComponents.TableCellText,
        reportNewComponents.TableCellField,
        reportNewComponents.TableBlockTotal,
    ])
    .add(_lt('Column'), [
        reportNewComponents.ColumnHalfText,
        reportNewComponents.ColumnThirdText,
    ]);

return registry;

});
;

/**********************************************************************
*  Filepath: /web_studio/static/src/legacy/js/views/abstract_view.js  *
*  Bundle: web_studio.studio_assets                                   *
*  Lines: 121                                                         *
**********************************************************************/
odoo.define('web_studio.AbstractViewEditor', function (require) {
"use strict";

var ajax = require('web.ajax');
var AbstractView = require('web.AbstractView');
const RendererWrapper = require('web.RendererWrapper');
const utils = require('web.utils');

AbstractView.include({

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    /**
     * @param {Widget} parent
     * @param {Widget} Editor
     * @param {Object} options
     * @returns {Widget}
     */
    createStudioEditor: function (parent, Editor, options) {
        return this._createStudioRenderer(parent, Editor, options);
    },
    /**
     * @param {Widget} parent
     * @param {Widget} Editor
     * @param {Object} options
     * @returns {Widget}
     */
    createStudioRenderer: function (parent, options) {
        var Renderer = this.config.Renderer;
        if (utils.isComponent(Renderer)) {
            options.Component = Renderer;
            Renderer = RendererWrapper;
        }
        options.viewType = 'viewType' in options ? options.viewType : this.viewType;
        return this._createStudioRenderer(parent, Renderer, options);
    },

    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------

    /**
     * @param {Widget} parent
     * @param {Widget} Renderer
     * @param {Object} options
     * @param {String} [options.viewType]
     * @param {String} [options.controllerState]
     * @returns {Widget}
     */
    _createStudioRenderer: function (parent, Renderer, options) {
        var self = this;
        var model = this.getModel(parent);

        var loadViewDef = this._loadSubviews ? this._loadSubviews(parent) : Promise.resolve();
        return loadViewDef.then(function () {
            const searchQuery = self.controllerParams.searchModel.get('query');
            if (options.viewType === 'list') {
                // reset the group by so lists are not grouped in studio.
                searchQuery.groupBy = [];
            }
            if (options.viewType === 'graph') {
                delete options.mode;
            }
            self._updateMVCParams(searchQuery);
            // This override is a hack because when we load the data for a subview in
            // studio we don't want to display all the record of the list view but only
            // the one set in the parent record.
            if (options.x2mField) {
                self.loadParams.static = true;
            }

            const withSampleData = ['graph', 'pivot'].includes(options.viewType) ? true : false;
            return Promise.all([
                self._loadData(model, { withSampleData }),
                ajax.loadLibs(self)
            ]).then(function (results) {
                var { state } = results[0];
                if (options.x2mField) {
                    self.loadParams.static = false;
                }
                var params = _.extend({}, self.rendererParams, options, {
                    // TODO: why is it defined now? because it is, the no
                    // content is displayed if no record
                    noContentHelp: undefined,
                });
                let editor;
                if (utils.isComponent(Renderer)) {
                    state = Object.assign({}, state, params);
                    const Component = state.Component;
                    const props = filterUnwantedProps(Component, state);
                    return new Renderer(parent, Component, props);
                } else {
                    editor = new Renderer(parent, state, params);
                }
                // the editor needs to have a reference to its BasicModel
                // instance to reuse it in x2m edition
                editor.model = model;
                model.setParent(editor);
                return editor;
            });
        });
    },
});

function filterUnwantedProps(ComponentType, params) {
    const props = ComponentType.props;
    if (!props) {
        return params;
    }
    const newParams = {};
    Object.entries(params).forEach(([k, v]) => {
        if (k in props) {
            newParams[k] = v;
        }
    });
    return newParams;
}

});
;

/**********************************************************************
*  Filepath: /web_studio/static/src/legacy/js/views/action_editor.js  *
*  Bundle: web_studio.studio_assets                                   *
*  Lines: 158                                                         *
**********************************************************************/
odoo.define('web_studio.ActionEditor', function (require) {
"use strict";

var Widget = require('web.Widget');

var ActionEditorSidebar = require('web_studio.ActionEditorSidebar');
var ActionEditorView = require('web_studio.ActionEditorView');

const { SUPPORTED_VIEW_TYPES } = require("@web_studio/studio_service");

var ActionEditor = Widget.extend({
    template: 'web_studio.ActionEditor',
    custom_events: {
        'parameters_clicked': '_onActionParameters',
    },
    VIEW_TYPES: SUPPORTED_VIEW_TYPES.slice(),

    /**
     * @constructor
     */
    init: function (parent, action) {
        this._super.apply(this, arguments);

        this.action = action;
        this.active_view_types = this._getActiveViewTypes();
        this.default_view = this.active_view_types[0];
        if (action.initial_view_types) {
            this.active_view_types = action.initial_view_types;
        }
    },
    /**
     * @override
     */
    start: function () {
        var self = this;

        // order view_types: put active ones at the begining
        var ordered_view_types = this.active_view_types.slice();
        _.each(this.VIEW_TYPES, function (el) {
            if (! _.contains(ordered_view_types, el)) {
                ordered_view_types.push(el);
            }
        });

        _.each(ordered_view_types, function (view_type) {
            var is_default_view = (view_type === self.default_view);
            var active = _.contains(self.active_view_types, view_type);
            var view = new ActionEditorView(self, {
                // search is always active
                active: active || view_type === 'search',
                default_view: is_default_view,
                can_default: !_.contains(['form', 'search'], view_type),
                view_type: view_type,
                can_be_disabled: view_type !== 'search',
            });

            var category = self._getViewCategory(view_type);
            if (category) {
                view.appendTo(
                    self.$('.o_web_studio_view_category[name=' + category + ']')
                );
            }
        });

        this.sidebar = new ActionEditorSidebar(this, this.action);
        return Promise.all([
            this._super.apply(this, arguments),
            this.sidebar.prependTo(this.$el)
        ]);
    },

    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------

    /**
     * @private
     * @returns {string[]} the current action active view types
     */
    _getActiveViewTypes: function () {
        return _.map(this.action.views, function (view) {
            return view[1];
        });
    },
    /**
     * Get the view type category.
     *
     * @private
     * @param {string} viewType
     * @returns {string}
     */
    _getViewCategory: function (viewType) {
        var category;
        switch (viewType) {
            case 'form':
                category = 'general';
                break;
            case 'search':
                category = 'general';
                break;
            case 'activity':
                category = 'general';
                break;
            case 'list':
                category = 'multiple';
                break;
            case 'kanban':
                category = 'multiple';
                break;
            case 'map':
                category = 'multiple';
                break;
            case 'graph':
                category = 'reporting';
                break;
            case 'pivot':
                category = 'reporting';
                break;
            case 'dashboard':
                category = 'reporting';
                break;
            case 'calendar':
                category = 'timeline';
                break;
            case 'gantt':
                category = 'timeline';
                break;
            case 'cohort':
                category = 'timeline';
                break;
        }
        return category;
    },

    //--------------------------------------------------------------------------
    // Handlers
    //--------------------------------------------------------------------------

    /**
     * @private
     */
    _onActionParameters: function () {
        // open action form view
        this.do_action({
            type: 'ir.actions.act_window',
            res_model: 'ir.actions.act_window',
            res_id: this.action.id,
            views: [[false, 'form']],
            target: 'current',
        }, {
            replace_last_action: true,
        });
    },
});

return ActionEditor;

});
;

/******************************************************************************
*  Filepath: /web_studio/static/src/legacy/js/views/action_editor_sidebar.js  *
*  Bundle: web_studio.studio_assets                                           *
*  Lines: 113                                                                 *
******************************************************************************/
odoo.define('web_studio.ActionEditorSidebar', function (require) {
"use strict";

var config = require('web.config');
var relational_fields = require('web.relational_fields');
var StandaloneFieldManagerMixin = require('web.StandaloneFieldManagerMixin');
var Widget = require('web.Widget');

var Many2ManyTags = relational_fields.FieldMany2ManyTags;

var ActionEditorSidebar = Widget.extend(StandaloneFieldManagerMixin, {
    template: 'web_studio.ActionEditorSidebar',
    events: {
        'change input, textarea': '_onActionChange',
        'click .o_web_studio_parameters': '_onParameters',
    },
    /**
     * @constructor
     * @param {Object} action
     */
    init: function (parent, action) {
        this._super.apply(this, arguments);
        StandaloneFieldManagerMixin.init.call(this);

        this.debug = config.isDebug();
        this.action = action;
        this.action_attrs = {
            name: action.display_name || action.name,
            help: action.help && action.help.replace(/\n\s+/g, '\n') || '',
        };
    },
    /**
     * @override
     */
    willStart: function () {
        var self = this;
        var def1 = this.model.makeRecord('ir.actions.act_window', [{
            name: 'groups_id',
            fields: [{
                name: 'id',
                type: 'integer',
            }, {
                name: 'display_name',
                type: 'char',
            }],
            relation: 'res.groups',
            type: 'many2many',
            value: this.action.groups_id,
        }]).then(function (recordID) {
            self.groupsHandle = recordID;
        });
        var def2 = this._super.apply(this, arguments);
        return Promise.all([def1, def2]);
    },
    /**
     * @override
     */
    start: function () {
        var def1 = this._super.apply(this, arguments);
        var record = this.model.get(this.groupsHandle);
        var options = {
            mode: 'edit',
        };
        var many2many = new Many2ManyTags(this, 'groups_id', record, options);
        this._registerWidget(this.groupsHandle, 'groups_id', many2many);
        var def2 = many2many.appendTo(this.$('.o_groups'));
        return Promise.all([def1, def2]);
    },

    //--------------------------------------------------------------------------
    // Handlers
    //--------------------------------------------------------------------------

    /**
     * @private
     * @param {Event} event
     */
    _onActionChange: function (event) {
        var $input = $(event.currentTarget);
        var attribute = $input.attr('name');
        if (attribute) {
            var new_attrs = {};
            new_attrs[attribute] = $input.val();
            this.trigger_up('studio_edit_action', {args: new_attrs});
        }
    },

    /**
     * @private
     */
    _onParameters: function () {
        this.trigger_up('parameters_clicked');
    },

    /*
     * @private
     * @override
     */
    _onFieldChanged: function () {
        var self = this;
        return StandaloneFieldManagerMixin._onFieldChanged.apply(this, arguments).then(function () {
            var record = self.model.get(self.groupsHandle);
            var args = {
                groups_id: record.data.groups_id.res_ids,
            };
            self.trigger_up('studio_edit_action', {args: args});
        });
    },
});

return ActionEditorSidebar;

});
;

/***************************************************************************
*  Filepath: /web_studio/static/src/legacy/js/views/action_editor_view.js  *
*  Bundle: web_studio.studio_assets                                        *
*  Lines: 69                                                               *
***************************************************************************/
odoo.define('web_studio.ActionEditorView', function (require) {
"use strict";

var Widget = require('web.Widget');
var config = require('web.config');

var ActionEditorView = Widget.extend({
    template: 'web_studio.ActionEditorView',
    events: {
        'click .dropdown-item': '_onMenu',
        'click .o_web_studio_thumbnail': '_onThumbnail',
    },
    /**
     * @constructor
     * @param {Object} flags
     */
    init: function (parent, flags) {
        this._super.apply(this, arguments);
        this.debug = config.isDebug();
        this.active = flags.active;
        this.default_view = flags.default_view;
        this.view_type = flags.view_type;
        this.can_default = flags.can_default;
        this.can_be_disabled = flags.can_be_disabled;
    },

    //--------------------------------------------------------------------------
    // Handlers
    //--------------------------------------------------------------------------

    /**
     * @private
     */
    _onThumbnail: function () {
       if (this.active) {
            this.trigger_up('studio_edit_view', {view_type: this.view_type});
        } else {
            this.trigger_up('studio_new_view', {view_type: this.view_type});
        }
    },
    /**
     * @private
     * @param {Event} event
     */
    _onMenu: function (event) {
        event.preventDefault();
        var action = $(event.currentTarget).data('action');

        var eventName;
        switch (action) {
            case 'set_default_view':
                eventName = 'studio_default_view';
                break;
            case 'restore_default_view':
                eventName = 'studio_restore_default_view';
                break;
            case 'disable_view':
                eventName = 'studio_disable_view';
                break;
        }
        if (eventName) {
            this.trigger_up(eventName, {view_type: this.view_type});
        }
    },
});

return ActionEditorView;

});
;

/************************************************************************
*  Filepath: /web_studio/static/src/legacy/js/views/view_components.js  *
*  Bundle: web_studio.studio_assets                                     *
*  Lines: 285                                                           *
************************************************************************/
odoo.define('web_studio.view_components', function (require) {
"use strict";

var config = require('web.config');
var core = require('web.core');
var Registry = require('web.Registry');
var Widget = require('web.Widget');

var _lt = core._lt;

var AbstractComponent = Widget.extend({
    structure: false,
    label: false,
    description: false,
    /**
     * @override
     */
    start: function () {
        var self = this;
        this.$el.addClass('o_web_studio_component');
        this.$el.data('structure', this.structure);
        this.$el.text(this.label);
        if (config.isDebug() && this.description) {
            this.$el.addClass('o_web_studio_debug');
            this.$el.append($('<div>')
                .addClass('o_web_studio_component_description')
                .text(this.description)
            );
        }
        this.$el.draggable({
            helper: 'clone',
            opacity: 0.4,
            scroll: false,
            revert: 'invalid',
            revertDuration: 200,
            refreshPositions: true,
            start: function (e, ui) {
                ui.helper.data(self.$el.data());
                ui.helper.addClass("ui-draggable-helper");
            }
        });
        return this._super.apply(this, arguments);
    },
});
var NotebookComponent = AbstractComponent.extend({
    structure: 'notebook',
    label: _lt('Tabs'),
    type: 'tabs',
    className: 'o_web_studio_field_tabs',
});
var GroupComponent = AbstractComponent.extend({
    structure: 'group',
    label: _lt('Columns'),
    type: 'columns',
    className: 'o_web_studio_field_columns',
});
var FilterComponent = AbstractComponent.extend({
    structure: 'filter',
    label: _lt('Filter'),
    type: 'filter',
    className: 'o_web_studio_filter',
});
var FilterSeparatorComponent = AbstractComponent.extend({
    structure: 'separator',
    label: _lt('Separator'),
    type: 'separator',
    className: 'o_web_studio_filter_separator',
});
var AbstractNewFieldComponent = AbstractComponent.extend({
    structure: 'field',
    type: false,
    special: false,

    /**
     * @override
     * @param {Object} attrs
     */
    init: function (parent, attrs) {
        this._super(parent);
        this.fieldAttrs = attrs;
    },
    /**
     * @override
     */
    start: function () {
        this.description = this.type;
        this.$el.data('field_description', {
            type: this.type,
            field_description: 'New ' + this.label,
            special: this.special,
        });
        this.$el.data('new_attrs', this.fieldAttrs);
        return this._super.apply(this, arguments);
    },
});
var CharFieldComponent = AbstractNewFieldComponent.extend({
    type: 'char',
    label: _lt('Text'),
    className: 'o_web_studio_field_char',
});
var TextFieldComponent = AbstractNewFieldComponent.extend({
    type: 'text',
    label: _lt('Multiline Text'),
    className: 'o_web_studio_field_text',
});
var IntegerFieldComponent = AbstractNewFieldComponent.extend({
    type: 'integer',
    label: _lt('Integer'),
    className: 'o_web_studio_field_integer',
});
var DecimalFieldComponent = AbstractNewFieldComponent.extend({
    type: 'float',
    label: _lt('Decimal'),
    className: 'o_web_studio_field_float',
});
var HtmlFieldComponent = AbstractNewFieldComponent.extend({
    type: 'html',
    label: _lt('Html'),
    className: 'o_web_studio_field_html',
});
var MonetaryFieldComponent = AbstractNewFieldComponent.extend({
    type: 'monetary',
    label: _lt('Monetary'),
    className: 'o_web_studio_field_monetary',
});
var DateFieldComponent = AbstractNewFieldComponent.extend({
    type: 'date',
    label: _lt('Date'),
    className: 'o_web_studio_field_date',
});
var DatetimeFieldComponent = AbstractNewFieldComponent.extend({
    type: 'datetime',
    label: _lt('Date & Time'),
    className: 'o_web_studio_field_datetime',
});
var BooleanFieldComponent = AbstractNewFieldComponent.extend({
    type: 'boolean',
    label: _lt('Checkbox'),
    className: 'o_web_studio_field_boolean',
});
var SelectionFieldComponent = AbstractNewFieldComponent.extend({
    type: 'selection',
    label: _lt('Selection'),
    className: 'o_web_studio_field_selection',
});
var BinaryFieldComponent = AbstractNewFieldComponent.extend({
    type: 'binary',
    label: _lt('File'),
    className: 'o_web_studio_field_binary',
});
var Many2manyFieldComponent = AbstractNewFieldComponent.extend({
    type: 'many2many',
    label: _lt('Many2many'),
    className: 'o_web_studio_field_many2many',
});
var One2manyFieldComponent = AbstractNewFieldComponent.extend({
    type: 'one2many',
    label: _lt('One2many'),
    className: 'o_web_studio_field_one2many',
});
const LinesFieldComponent = AbstractNewFieldComponent.extend({
    type: 'one2many',
    label: _lt('Lines'),
    className: 'o_web_studio_field_lines',
    special: 'lines',
});
var Many2oneFieldComponent = AbstractNewFieldComponent.extend({
    type: 'many2one',
    label: _lt('Many2one'),
    className: 'o_web_studio_field_many2one',
});
var ExistingFieldComponent = AbstractComponent.extend({
    /**
     * @override
     * @param {Widget} parent
     * @param {String} name
     * @param {String} field_description
     * @param {String} type
     * @param {Boolean} store
     * @param {Object} attrs
     */
    init: function (parent, name, field_description, type, store, attrs) {
        this._super(parent);
        this.structure = 'field';
        this.label = field_description;
        this.description = name;
        this.className = 'o_web_studio_field_' + type;
        this.type = type;
        this.store = store;
        this.fieldAttrs = attrs;
    },
    /**
     * @override
     */
    start: function () {
        const newAttrs = Object.assign(this.fieldAttrs || {}, {
            name: this.description,
            label: this.label,
            type: this.type,
            store: this.store ? "true":"false",
        });
        this.$el.data('new_attrs', newAttrs);
        this.$el.attr("title", this.label);
        return this._super.apply(this, arguments);
    },
});
var AbstractNewWidgetComponent = AbstractNewFieldComponent.extend({
    attrs: {},
    /**
     * @override
     */
    start: function () {
        const newAttrs = Object.assign(this.fieldAttrs || {}, this.attrs);
        this.$el.data('new_attrs', newAttrs);
        return this._super.apply(this, arguments);
    },
});
var ImageWidgetComponent = AbstractNewWidgetComponent.extend({
    type: 'binary',
    label: _lt('Image'),
    className: 'o_web_studio_field_picture',
    attrs: {widget: 'image', options: '{"size": [0, 90]}'},
});
var TagWidgetComponent = AbstractNewWidgetComponent.extend({
    type: 'many2many',
    label: _lt('Tags'),
    className: 'o_web_studio_field_tags',
    attrs: {widget: 'many2many_tags'},
});
var PriorityWidgetComponent = AbstractNewWidgetComponent.extend({
    type: 'selection',
    label: _lt('Priority'),
    className: 'o_web_studio_field_priority',
    attrs: {widget: 'priority'},
});
var SignatureWidgetComponent = AbstractNewWidgetComponent.extend({
    type: 'binary',
    label: _lt('Signature'),
    className: 'o_web_studio_field_signature',
    attrs: {widget: 'signature'},
});
var RelatedFieldComponent = AbstractNewFieldComponent.extend({
    type: 'related',
    label: _lt('Related Field'),
    className: 'o_web_studio_field_related',
});
var form_component_widget_registry = new Registry();
form_component_widget_registry
    .add('form_components', [
        NotebookComponent,
        GroupComponent,
    ])
    .add('search_components', [
        FilterComponent,
        FilterSeparatorComponent,
    ])
    .add('new_field', [
        CharFieldComponent,
        TextFieldComponent,
        IntegerFieldComponent,
        DecimalFieldComponent,
        HtmlFieldComponent,
        MonetaryFieldComponent,
        DateFieldComponent,
        DatetimeFieldComponent,
        BooleanFieldComponent,
        SelectionFieldComponent,
        BinaryFieldComponent,
        LinesFieldComponent,
        One2manyFieldComponent,
        Many2oneFieldComponent,
        Many2manyFieldComponent,
        ImageWidgetComponent,
        TagWidgetComponent,
        PriorityWidgetComponent,
        SignatureWidgetComponent,
        RelatedFieldComponent,
    ])
    .add('existing_field', ExistingFieldComponent);

return {
    registry: form_component_widget_registry,
};

});
;

/****************************************************************************
*  Filepath: /web_studio/static/src/legacy/js/views/view_editor_manager.js  *
*  Bundle: web_studio.studio_assets                                         *
*  Lines: 1864                                                              *
****************************************************************************/
odoo.define('web_studio.ViewEditorManager', function (require) {
"use strict";

const { ComponentWrapper } = require('web.OwlCompatibility');
var core = require('web.core');
var data_manager = require('web.data_manager');
var Dialog = require('web.Dialog');
var dom = require('web.dom');
var framework = require('web.framework');
var session = require('web.session');
var view_registry = require('web.view_registry');

var AbstractEditorManager = require('web_studio.AbstractEditorManager');
var bus = require('web_studio.bus');
var EditorMixin = require('web_studio.EditorMixin');
var EditorMixinOwl = require('web_studio.EditorMixinOwl');

var CalendarEditor = require('web_studio.CalendarEditor');
var FormEditor = require('web_studio.FormEditor');
var KanbanEditor = require('web_studio.KanbanEditor');
var ListEditor = require('web_studio.ListEditor');
var SearchEditor = require('web_studio.SearchEditor');
var SearchRenderer = require('web_studio.SearchRenderer');

var FieldSelectorDialog = require('web_studio.FieldSelectorDialog');
var NewButtonBoxDialog = require('web_studio.NewButtonBoxDialog');
var NewFieldDialog = require('web_studio.NewFieldDialog');
var utils = require('web_studio.utils');
var ViewEditorSidebar = require('web_studio.ViewEditorSidebar');
const { isComponent } = require('web.utils');

var _t = core._t;
var QWeb = core.qweb;

var Editors = {
    form: FormEditor,
    kanban: KanbanEditor,
    list: ListEditor,
    calendar: CalendarEditor,
    search: SearchEditor,
};

class EditorWrapper extends ComponentWrapper {
    handleDrop() {
        return this.componentRef.comp &&
            this.componentRef.comp.handleDrop(...arguments);
    }
    highlightNearestHook() {
        return this.componentRef.comp &&
            this.componentRef.comp.highlightNearestHook(...arguments);
    }
    setSelectable() {
        return this.componentRef.comp &&
            this.componentRef.comp.setSelectable(...arguments);
    }
    unselectedElements() {
        return this.componentRef.comp &&
            this.componentRef.comp.unselectedElements(...arguments);
    }
}

var ViewEditorManager = AbstractEditorManager.extend({
    custom_events: _.extend({}, AbstractEditorManager.prototype.custom_events, {
        approval_archive: '_onApprovalArchive',
        approval_change: '_onApprovalChange',
        approval_condition: '_onApprovalCondition',
        approval_group_change: '_onApprovalGroupChange',
        approval_new_rule: '_onApprovalNewRule',
        default_value_change: '_onDefaultValueChange',
        email_alias_change: '_onEmailAliasChange',
        field_edition: '_onFieldEdition',
        field_renamed: '_onFieldRenamed',
        open_defaults: '_onOpenDefaults',
        open_field_form: '_onOpenFieldForm',
        open_record_form_view: '_onOpenRecordFormView',
        toggle_form_invisible: '_onShowInvisibleToggled',
    }),
    /**
     * The init always takes the main view's descriptions as parameters.
     * If we are editing a nested x2m field, the ViewManager's properties are changed
     * in order to target the right field and the right view.
     *
     * @override
     * @param {Widget} parent
     * @param {Object} params
     * @param {Object} params.action
     * @param {Object} params.fields_view
     * @param {string} params.viewType
     * @param {Object} [params.chatter_allowed]
     * @param {String} [params.controllerState]
     * @param {Object} [params.studio_view_id]
     * @param {Object} [params.studio_view_arch]
     */
    init: function (parent, params) {
        this._super.apply(this, arguments);

        this.action = params.action;

        this.fields_view = params.fields_view;
        this.fields = this._processFields(this.fields_view.fields);

        this.model_name = this.fields_view.model;
        this.view_type = params.viewType;
        this.mainViewType = this.view_type;
        this.view_id = this.fields_view.view_id;

        this.studio_view_id = params.studio_view_id;
        this.studio_view_arch = params.studio_view_arch;

        this.isEditingX2m = params.x2mEditorPath && params.x2mEditorPath.length;
        if (this.isEditingX2m) {
            this.x2mEditorPath = params.x2mEditorPath;
            this.chatter_allowed = false;

            const currentX2m = this.x2mEditorPath[this.x2mEditorPath.length - 1];
            this.currentX2m = currentX2m;

            this.x2mField = currentX2m.x2mField;
            this.x2mViewType = currentX2m.x2mViewType;
            this.x2mModel = currentX2m.x2mModel;

            this.view_type = this.x2mViewType;
            this.x2mViewParams = currentX2m.x2mViewParams;
        } else {
            this.chatter_allowed = params.chatter_allowed || false;
            this.controllerState = params.controllerState;
        }

        this.renamingAllowedFields = []; // those fields can be renamed

        this.expr_attrs = {
            'field': ['name'],
            'label': ['for'],
            'page': ['name'],
            'group': ['name'],
            'div': ['name'],
            'filter': ['name'],
            'button': ['name'],
        };
    },
    /**
     * @override
     */
    start: async function () {
        const _super = this._super;
        if (this.isEditingX2m) {
            let fieldsView = this._getX2mFieldsView(this.fields_view);

            if (!fieldsView || fieldsView.name) {
                fieldsView = await this._createInlineView(this.x2mViewType, this.x2mField)
                fieldsView = this._getX2mFieldsView(fieldsView);
            }
            this.fields_view = fieldsView;
            this.fields = await this._getProcessedX2mFields();
        }
        return _super.apply(this, arguments);
    },

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    /**
     * @param {Object} options
     * @returns {Promise}
     */
    updateEditor: function (options) {
        var self = this;
        var rendererScrollTop = this.$el.scrollTop();
        var localState = false;
        if (this.editor && this.editor.getLocalState) {
            localState = this.editor.getLocalState();
        }
        var oldEditor = this.editor;

        return this._instantiateEditor(options).then(function (editor) {
            var fragment = document.createDocumentFragment();
            let prom = undefined;
            if (editor instanceof owl.Component) {
                prom = editor.mount(fragment);
            } else {
                prom = editor.appendTo(fragment);
            }
            return prom.then(function () {
                dom.append(self.$('.o_web_studio_view_renderer'), [fragment], {
                    in_DOM: self.isInDOM,
                    callbacks: [{ widget: editor }],
                });
                self.editor = editor;
                oldEditor.destroy();

                // restore previous state
                self.$el.scrollTop(rendererScrollTop);
                if (localState) {
                    self.editor.setLocalState(localState);
                }
            }).guardedCatch(function (e) {
                self.trigger_up('studio_error', {error: 'view_rendering'});
                self._undo(null, true);
            });
        });
    },

    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------

    /**
     * @private
     * @param {Object} data
     */
    _addAvatarImage: function (data) {
        this._do({
            type: 'avatar_image',
            field: data.field,
        });
    },
    /**
     * Enable approval for a <button> node as well as all other nodes of the
     * same type and the same name in the view; this is done server-side.
     * @private
     * @param {Object} data
     */
    _addApproval: async function (data) {
        const attrs = data.node.attrs;
        // enabling approval on node
        // need to enable it on all similar nodes silently in a single op
        await this._do({
            type: 'enable_approval',
            model: this.model_name,
            btn_type: attrs.type,
            btn_name: attrs.name,
            view_id: this.view_id,
            enable: data.enable,
        })
    },
    /**
     * @private
     * @param {String} type
     */
    _addButton: function (data) {
        var modelName = this.x2mModel ? this.x2mModel : this.model_name;
        var dialog = new NewButtonBoxDialog(this, modelName).open();
        dialog.on('saved', this, function (result) {
            if (data.add_buttonbox) {
                this.operations.push({type: 'buttonbox'});
            }
            this._do({
                type: data.type,
                target: {
                    tag: 'div',
                    attrs: {
                        class: 'oe_button_box',
                    }
                },
                position: 'inside',
                node: {
                    tag: 'button',
                    field: result.field_id,
                    string: result.string,
                    attrs: {
                        class: 'oe_stat_button',
                        icon: result.icon,
                    }
                },
            });
        });
    },
    /**
     * @private
     * @param {Object} data
     */
    _addChatter: function (data) {
        this._do({
            type: 'chatter',
            model: this.model_name,
            remove_activity_ids: data.remove_activity_ids,
            remove_message_ids: data.remove_message_ids,
            remove_follower_ids: data.remove_follower_ids,
        });
    },
    /**
     * @private
     * @param {String} type
     * @param {Object} node
     * @param {Object} xpath_info
     * @param {String} position
     * @param {String} tag
     */
    _addElement: function (type, node, xpath_info, position, tag) {
        this._do({
            type: type,
            target: {
                tag: node.tag,
                attrs: _.pick(node.attrs, this.expr_attrs[node.tag]),
                xpath_info: xpath_info,
            },
            position: position,
            node: {
                tag: tag,
                attrs: {
                    name: 'studio_' + tag + '_' + utils.randomString(5),
                }
            },
        });
    },
    /**
     * @private
     * @param {String} type
     * @param {Object} field_description
     * @param {Object} node
     * @param {Object} xpath_info
     * @param {String} position
     * @param {Object} new_attrs
     * @param {Object} data
     */
    _addField: function (type, field_description, node, xpath_info, position, new_attrs, data) {
        var self = this;
        var def_field_values;
        var dialog;

        var openCurrencyCreationDialog = function (relatedCurrency, resolve) {
            var msg = _t("In order to use a monetary field, you need a currency field on the model. " +
                "Do you want to create a currency field first? You can make this field invisible afterwards.");
            return Dialog.confirm(this, msg, {
                confirm_callback: function () {
                    new_attrs = {};
                    // modifies the current operation in place to create a
                    // currency field instead
                    field_description = {
                        default_value: session.company_currency_id,
                        field_description: 'Currency',
                        model_name: modelName,
                        name: 'x_currency_id',
                        relation: 'res.currency',
                        type: 'many2one',
                    };
                    if (relatedCurrency) {
                        field_description.related = relatedCurrency;
                    }
                    resolve();
                },
            });
        };

        // The field doesn't exist: field_description is the definition of the new field.
        // No need to have field_description of an existing field
        if (field_description) {
            var modelName = this.x2mModel ? this.x2mModel : this.model_name;
            // "extend" avoids having the same reference in "this.operations"
            // We can thus modify it without editing previous existing operations
            field_description = _.extend({}, field_description, {
                name: `x_studio_${field_description.type}_field_${utils.randomString(5)}`,
                model_name: modelName,
            });
            // Fields with requirements
            if (field_description.type === 'selection' && new_attrs.widget === 'priority') {
                // should not be translated at the creation
                field_description.selection = [
                    ['0', "Normal"],
                    ['1', "Low"],
                    ['2', "High"],
                    ['3', "Very High"],
                ];
            } else if (field_description.special === 'lines') {
                // there's nothing to do, the operation will be fully handled server-side
            } else if (_.contains(['selection', 'one2many', 'many2one', 'many2many', 'related'], field_description.type)) {
                def_field_values = new Promise(function (resolve, reject) {
                    var prom;
                    if (field_description.type === 'one2many') {
                        // check for existing m2o fields for current model
                        var modelName = self.x2mModel ? self.x2mModel : self.model_name;
                        prom = self._rpc({
                            model:"ir.model.fields",
                            method: "search_count",
                            args: [[['relation', '=', modelName], ['ttype', '=', 'many2one']]],
                        });
                    } else {
                        prom = Promise.resolve(true);
                    }
                    prom.then(function (openFieldDialog) {
                        if (!openFieldDialog) {
                            // In case of o2m fields, if there's no m2o field available, display a warning instead
                            var $message = $(QWeb.render('web_studio.FieldOne2manyWarning'));
                            dialog = Dialog.alert(self, '', {
                                $content: $('<main/>', {
                                    role: 'alert',
                                    html: $message,
                                }),
                                title: _t("No related many2one fields found"),
                            });
                            dialog.on('closed', self, function () {
                                reject();
                            });
                        } else {
                            // open dialog to precise the required fields for this field
                            dialog = new NewFieldDialog(self, modelName, field_description, _.filter(self.fields, {type: 'many2one'})).open();
                            dialog.on('field_default_values_saved', self, function (values) {
                                if (values.related && values.type === 'monetary') {
                                    if (self._hasCurrencyField()) {
                                        resolve(values);
                                        dialog.close();
                                    } else {
                                        var relatedCurrency = values._currency;
                                        delete values._currency;
                                        var currencyDialog = openCurrencyCreationDialog(relatedCurrency, resolve);
                                        currencyDialog.on('closed', self, function () {
                                            dialog.close();
                                        });
                                    }
                                } else {
                                    resolve(values);
                                    dialog.close();
                                }
                            });
                            dialog.on('closed', self, function () {
                                reject();
                            });
                        }
                    });
                });
            } else if (field_description.type === 'monetary') {
                def_field_values = new Promise(function (resolve, reject) {
                    if (self._hasCurrencyField()) {
                        resolve();
                    } else {
                        dialog = openCurrencyCreationDialog(null, resolve);
                        dialog.on('closed', self, function () {
                            reject();
                        });
                    }
                });
            } else if (field_description.type === 'integer') {
                field_description.default_value = '0'
            }
        }
        // When the field values is selected, close the dialog and update the view
        Promise.resolve(def_field_values).then(function (values) {
            framework.blockUI();
            if (field_description) {
                self.renamingAllowedFields.push(field_description.name);
            }
            if (data.add_statusbar) {
                self.operations.push({type: 'statusbar'});
            }
            var target = data.target || {
                tag: node.tag,
                attrs: _.pick(node.attrs, self.expr_attrs[node.tag]),
                xpath_info: xpath_info,
            };
            self._do({
                type: type,
                target: target,
                position: position,
                node: {
                    tag: 'field',
                    attrs: new_attrs,
                    field_description: _.extend(field_description, values),
                },
            }).then(function () {
                framework.unblockUI();
                if (self.editor.selectField && field_description) {
                    self.editor.selectField(field_description.name);
                }
            }).guardedCatch(framework.unblockUI);
        }).guardedCatch(function () {
            self.updateEditor();
        });
    },
    /**
     * @private
     * @param {String} type
     * @param {Object} node
     * @param {Object} xpath_info
     * @param {String} position
     * @param {Object} new_attrs
     */
    _addFilter: function (type, node, xpath_info, position, new_attrs) {
        this._do({
            type: type,
            target: {
                tag: node.tag,
                attrs: _.pick(node.attrs, this.expr_attrs[node.tag]),
                xpath_info: xpath_info,
            },
            position: position,
            node: {
                tag: 'filter',
                attrs: new_attrs,
            },
        });
    },
    /**
     * @private
     */
    _addKanbanDropdown: function () {
        this._do({
            type: 'kanban_dropdown',
        });
    },
    /**
     * @private
     * @param {string} type
     */
    _editKanbanCover: function (type) {
        if (type === 'kanban_set_cover') {
            var compatibleFields = _.pick(this.fields, function (field) {
               return field.type === "many2one" && field.relation === "ir.attachment";
            });
            var dialog = new FieldSelectorDialog(this, compatibleFields, true).open();
            dialog.on('confirm', this, function (field) {
                this._do({
                    type: type,
                    field: field,
                });
            });
        }
        if (type === 'remove') {
            var fieldToRemove = _.pick(this.view.fieldsInfo[this.view_type], function (field) {
                return field.widget === "attachment_image";
            });

            this._do({
                type: type,
                target: {
                    tag: 'field',
                    attrs: {name: _.keys(fieldToRemove)[0]},
                    extra_nodes: [{
                        tag: "a",
                        attrs: {
                            type: 'set_cover',
                        },
                    }],
                },
            });
        }
    },
    /**
     * @private
     * @param {Object} data
     */
    _addKanbanPriority: function (data) {
        this._do({
            type: 'kanban_priority',
            field: data.field,
        });
    },
    /**
     * @private
     * @param {Object} data
     */
    _addKanbanImage: function (data) {
        this._do({
            type: 'kanban_image',
            field: data.field,
        });
    },
    /**
     * @private
     * @param {String} type
     * @param {Object} node
     * @param {Object} xpath_info
     * @param {String} position
     */
    _addPage: function (type, node, xpath_info, position) {
        this._do({
            type: type,
            target: {
                tag: node.tag,
                attrs: _.pick(node.attrs, this.expr_attrs[node.tag]),
                xpath_info: xpath_info,
            },
            position: position,
            node: {
                tag: 'page',
                attrs: {
                    string: 'New Page',
                    name: 'studio_page_' + utils.randomString(5),
                }
            },
        });
    },
    /**
     * @private
     * @param {String} type
     * @param {Object} node
     * @param {Object} xpath_info
     * @param {String} position
     */
    _addSeparator: function (type, node, xpath_info, position) {
        this._do({
            type: type,
            target: {
                tag: node.tag,
                attrs: _.pick(node.attrs, this.expr_attrs[node.tag]),
                xpath_info: xpath_info,
            },
            position: position,
            node: {
                tag: 'separator',
                attrs: {
                    name: 'studio_separator_' + utils.randomString(5),
                },
            },
        });
    },
    /**
     * @private
     * @param {string} type operation type
     * @param {integer[]} fieldIDs
     */
    _changeMapPopupFields: function (type, fieldIDs) {
        this._do({
            type: 'map_popup_fields',
            target: {
                operation_type: type,
                field_ids: fieldIDs,
            }
        });
    },
    /**
     * @private
     * @param {string} type operation type
     * @param {integer[]} fieldIDs
     */
    _changePivotMeasuresFields(type, fieldIDs) {
        framework.blockUI();
        this._do({
            type: 'pivot_measures_fields',
            target: {
                operation_type: type,
                field_ids: fieldIDs,
            }
        }).finally(framework.unblockUI);
    },
    /**
     * @private
     * @param {string} type operation type
     * @param {object} data
     */
    _changeGraphPivotGroupbysFields(type, data) {
        framework.blockUI();
        this._do({
            type: 'graph_pivot_groupbys_fields',
            target: {
                operation_type: data.options.operationType,
                field_names: data.options.name,
                old_field_names: data.options.oldname,
                view_type: data.options.viewType,
                field_type: data.options.type,
            }
        }).finally(framework.unblockUI);
    },
    /**
     * @override
     */
    _applyChangeHandling: async function (result, opID) {
        var self = this;
        var prom = Promise.resolve();

        if (!result.fields_views) {
            // the operation can't be applied
            this.trigger_up('studio_error', {error: 'wrong_xpath'});
            return this._undo(opID, true).then(function () {
                return Promise.reject();
            });
        }

        // the studio_view could have been created at the first edition so
        // studio_view_id must be updated (but /web_studio/edit_view_arch
        // doesn't return the view id)
        if (result.studio_view_id) {
            this.studio_view_id = result.studio_view_id;
        }

        // NOTE: fields & fields_view are from the base model here.
        // fields will be updated accordingly if editing a x2m (see
        // @_setX2mParameters).
        this.fields = this._processFields(result.fields);
        this.fields_view = result.fields_views[this.mainViewType];
        // TODO: this processing is normally done in data_manager so we need
        // to duplicate it here ; it should be moved in init of
        // abstract_view to avoid the duplication
        this.fields_view.viewFields = this.fields_view.fields;
        this.fields_view.fields = result.fields;

        if (this.isEditingX2m) {
            this.fields_view = this._getX2mFieldsView(this.fields_view);
            this.fields = await this._getProcessedX2mFields();
        }

        return prom.then(self.updateEditor.bind(self));
    },
    /**
     * Find a currency field on the current model ; a monetary field can not be
     * added if such a field does not exist on the model.
     *
     * @private
     * @return {boolean} the presence of a currency field
     */
    _hasCurrencyField: function () {
        var currencyField = _.find(this.fields, function (field) {
            return field.type === 'many2one' && field.relation === 'res.currency' &&
                (field.name === 'currency_id' || field.name === 'x_currency_id');
        });
        return !!currencyField;
    },
    /**
     * @override
     * @param {Object} [lastOp]
     */
    _cleanOperationsStack: function (lastOp) {
        // As the studio view arch is stored in this widget, if this view
        // is updated directly with the XML editor, the arch should be updated.
        // The operations may not have any sense anymore so they are dropped.
        if (lastOp && lastOp.view_id === this.studio_view_id) {
            this.studio_view_arch = lastOp.new_arch;
            this._super.apply(this, arguments);
        }
    },
    /**
     * Makes a RPC to modify the studio view in order to add the x2m view
     * inline. This is done to avoid modifying the x2m default view.
     *
     * @private
     * @param {string} type
     * @param {string} field_name
     * @return {Promise}
     */
    _createInlineView: async function (type, field_name) {
        var subviewType = type === 'list' ? 'tree' : type;
        // We build the correct xpath if we are editing a 'sub' subview
        var subviewXpath = this._getSubviewXpath(this.x2mEditorPath.slice(0, -1));
        var context = _.extend({}, session.user_context, {lang: false});
        // Use specific view if available in context
        var specific_view = this.x2mViewParams.context[subviewType+'_view_ref'];
        if (specific_view) {
            context[subviewType+'_view_ref'] = specific_view;
        }
        const studioViewArch = await this._rpc({
            route: '/web_studio/create_inline_view',
            params: {
                model: this.x2mModel,
                view_id: this.view_id,
                field_name: field_name,
                subview_type: subviewType,
                subview_xpath: subviewXpath,
                // We write views in the base language to make sure we do it on the source term field
                // of ir.ui.view
                context: context,
            },
        });

        this.operations = [];
        this.studio_view_arch = studioViewArch;

        const viewInfo = await this.loadViews(
            this.model_name,
            this.currentX2m.x2mViewContext || {},
            [[this.view_id, this.mainViewType]]
        );

        return viewInfo[this.mainViewType];
    },
    /**
     * @override
     */
    _do: function (op) {
        // If we are editing an x2m field, we specify the xpath needed in front
        // of the one generated by the default route.
        if (this.x2mField && op.target) {
            this._setSubViewXPath(op);
        }

        return this._super.apply(this, arguments);
    },
    /**
     * @private
     * @param {String} type
     * @param {Object} node
     * @param {Object} xpath_info
     * @param {Object} new_attrs
     */
    _editElementAttributes: function (type, node, xpath_info, new_attrs) {
        var newOp = {
            type: type,
            target: {
                tag: node.tag,
                attrs: _.pick(node.attrs, this.expr_attrs[node.tag]),
                xpath_info: xpath_info,
            },
            position: 'attributes',
            node: node,
            new_attrs: new_attrs,
        };
        if (node.tag === 'field' && new_attrs.string &&
            _.contains(this.renamingAllowedFields, node.attrs.name)) {
            if (this.x2mField) {
                this._setSubViewXPath(newOp);
            }
            this.operations.push(newOp);

            // find a new name that doesn't exist yet, acording to the label
            var baseName = 'x_studio_' + this._slugify(new_attrs.string);
            var newName = baseName;
            var index = 1;
            while (newName in this.fields) {
                newName = baseName + '_' + index;
                index++;
            }

            this._renameField(node.attrs.name, newName);
        } else {
            this._do(newOp);
        }
    },
    _editField(modelName, fieldName, values, forceEdit) {
        return this._rpc({
            route: '/web_studio/edit_field',
            params: {
                model_name: modelName,
                field_name: fieldName,
                values: values,
                force_edit: forceEdit,
            }
        })
    },
    /**
     * @override
     */
    _editView: function (view_id, studio_view_arch, operations) {
        core.bus.trigger('clear_cache');
        return this._rpc({
            route: '/web_studio/edit_view',
            params: {
                view_id: view_id,
                studio_view_arch: studio_view_arch,
                operations: operations,
                model: this.x2mModel ? this.x2mModel : this.model_name,
                // We write views in the base language to make sure we do it on the source term field
                // of ir.ui.view
                context: _.extend({}, session.user_context, {lang: false}),
            },
        });
    },
    /**
     * @override
     */
    _editViewArch: function (view_id, view_arch) {
        core.bus.trigger('clear_cache');
        return this._rpc({
            route: '/web_studio/edit_view_arch',
            params: {
                view_id: view_id,
                view_arch: view_arch,
                // We write views in the base language to make sure we do it on the source term field
                // of ir.ui.view
                context: _.extend({}, session.user_context, {lang: false}),
            },
        });
    },
    /**
     * @private
     * @param {String} type
     * @param {Object} new_attrs
     */
    _editViewAttributes: function (type, new_attrs) {
        this._do({
            type: type,
            target: {
                tag: this.view_type === 'list' ? 'tree' : this.view_type,
                isSubviewAttr: true,
            },
            position: 'attributes',
            new_attrs: new_attrs,
        });
    },
    /**
     * Fetch the full spec of the approval rules for a specific
     * action on the model. This is used by the sidebar to display the
     * approval rules on a <button> node.
     * @private
     * @param {String} model_name
     * @param {String} method
     * @param {String} action
     * @returns {Promise}
     */
    _getApprovalSpec: async function (model_name, method, action) {
        const spec = await this._rpc({
            model: 'studio.approval.rule',
            method: 'get_approval_spec',
            args: [model_name, method, action],
            kwargs: { res_id: false },
        });
        return {approvalData: spec};
    },
    /**
     * @private
     * @param {String} model_name
     * @param {String} field_name
     * @returns {Promise}
     */
    _getDefaultValue: function (model_name, field_name) {
        return this._rpc({
            route: '/web_studio/get_default_value',
            params: {
                model_name: model_name,
                field_name: field_name,
            },
        });
    },
    /**
     * @private
     */
    _getDefaultSidebarMode: function () {
        return _.contains(['form', 'list', 'search'], this.view_type) ? 'new' : 'view';
    },
    /**
     * @private
     * @param {String} model_name
     * @returns {Promise}
     */
    _getEmailAlias: function (model_name) {
        return this._rpc({
            route: '/web_studio/get_email_alias',
            params: {
                model_name: model_name,
            },
        });
    },
    /**
     * @private
     * @returns {boolean}
     */
    _getShowInvisible() {
        return Boolean(
            this.sidebar &&
            this.sidebar.state &&
            this.sidebar.state.show_invisible
        );
    },
    /**
     * Makes a fields_get onto the current x2m model
     * @private
     */
    async _getProcessedX2mFields() {
        const fields = await this._rpc({
            model: this.x2mModel,
            method: 'fields_get',
        })
        return this._processFields(fields);
    },
    /**
     * @override
     * @param {Object} [params]
     * @param {Object} [params.node] mandatory if mode "properties"
     */
    _getSidebarState: function (mode, params) {
        var newState;
        var def = Promise.resolve();
        if (mode) {
            newState = _.extend({}, params, {
                renamingAllowedFields: this.renamingAllowedFields,
                mode: mode,
                show_invisible: this._getShowInvisible(),
            });
        } else {
            newState = this.sidebar.state;
        }
        switch (mode) {
            case 'view':
                newState = _.extend(newState, {
                    attrs: this.view.arch.attrs,
                });
                break;
            case 'new':
                break;
            case 'properties':
                var attrs;
                var node = params.node;
                if (node.tag === 'field' && this.view_type !== 'search') {
                    var viewType = this.editor.state.viewType;
                    attrs = this.editor.state.fieldsInfo[viewType][node.attrs.name];
                } else {
                    attrs = node.attrs;
                }
                newState = _.extend(newState, {
                    attrs: attrs,
                });

                var modelName = this.x2mModel ? this.x2mModel : this.model_name;
                if (node.tag === 'field') {
                    def = this._getDefaultValue(modelName, node.attrs.name);
                }
                if (node.tag === 'div' && node.attrs.class === 'oe_chatter') {
                    def = this._getEmailAlias(modelName);
                }
                if (node.tag === 'button' && node.attrs.studio_approval && node.attrs.studio_approval !== 'False') {
                    let method, action;
                    if (node.attrs.type === 'object') {
                        method = node.attrs.name;
                    } else if (node.attrs.type === 'action') {
                        action = parseInt(node.attrs.name);
                    }
                    def = this._getApprovalSpec(modelName, method, action);
                }
                break;
        }

        return def.then(function (result) {
            return _.extend(newState, result);
        });
    },
    /**
     * @private
     * @param  {Array} x2mEditorPath
     * @return {String}
     */
    _getSubviewXpath: function (x2mEditorPath) {
        var subviewXpath = "";
        _.each(x2mEditorPath, function (x2mPath) {
            var x2mViewType = x2mPath.x2mViewType === 'list' ? 'tree' : x2mPath.x2mViewType;
            subviewXpath += "//field[@name='" + x2mPath.x2mField + "']/" + x2mViewType;
        });
        return subviewXpath;
    },
    /**
     * From the main view's fields_view, go through the x2mEditorPath to get the current x2m fields_view
     *
     * @private
     * @param {Object} fieldsView: the main view's field_view
     * @return {Object} the fields_view of the x2m field
     */
    _getX2mFieldsView(fieldsView) {
        // this is a crappy way of processing the arch received as string
        // because we need a processed fields_view to find the x2m fields view
        const View = view_registry.get(this.mainViewType);
        const view = new View(fieldsView, _.extend({}, this.x2mViewParams));

        let fields_view = view.fieldsView;

        const x2mEditorPath = this.x2mEditorPath;
        for (let index = 0; index < x2mEditorPath.length; index++) {
            const step = x2mEditorPath[index];
            const x2mField = fields_view.fieldsInfo[step.parentViewType][step.x2mField];
            fields_view = x2mField.views[step.x2mViewType];
        }
        if (fields_view) {
            fields_view.model = this.x2mModel;
        }
        return fields_view;
    },
    /**
     * @override
     * @returns {Promise<Widget>}
     */
    _instantiateEditor: async function (params) {
        params = params || {};

        const fields_view = this.fields_view;

        var viewParams = this.x2mField ? this.x2mViewParams : {
            action: this.action,
            context: this.action.context,
            controllerState: this.controllerState,
            withSearchPanel: false,
            domain: this.action.domain,
        };

        var def;
        // Different behaviour for the search view because
        // it's not defined as a "real view", no inherit to abstract view.
        // The search view in studio has its own renderer.
        if (this.view_type === 'search') {
            if (this.mode === 'edition') {
                const editorParams = _.defaults(params, {
                    show_invisible: this._getShowInvisible(),
                });
                this.view = new Editors.search(this, fields_view, editorParams);
            } else {
                this.view = new SearchRenderer(this, fields_view);
            }
            def = Promise.resolve(this.view);
        } else {
            var View = view_registry.get(this.view_type);
            this.view = new View(fields_view, _.extend({}, viewParams));
            if (this.mode === 'edition') {
                var Editor = Editors[this.view_type];
                if (!Editor) {
                    // generate the Editor on the fly if it doesn't exist
                    if (isComponent(View.prototype.config.Renderer)) {
                        const Renderer = class extends EditorMixinOwl(View.prototype.config.Renderer) { };
                        const propsValidation = View.prototype.config.Renderer.props;
                        if (propsValidation) {
                            const optString = { type: String, optional: 1 };
                            Renderer.props = Object.assign({}, propsValidation, {
                                mode: propsValidation.mode || String,
                                chatter_allowed: propsValidation.chatter_allowed || Boolean,
                                show_invisible: propsValidation.show_invisible || Boolean,
                                arch: propsValidation.arch || Object,
                                x2mField: propsValidation.x2mField || optString,
                                viewType: propsValidation.viewType || String,
                            });
                        }
                        params.Component = Renderer;
                        Editor = EditorWrapper;
                    } else {
                        Editor = View.prototype.config.Renderer.extend(EditorMixin);
                    }
                }
                var chatterAllowed = this.x2mField ? false : this.chatter_allowed;
                var editorParams = _.defaults(params, {
                    mode: 'readonly',
                    chatter_allowed: chatterAllowed,
                    show_invisible: this._getShowInvisible(),
                    arch: this.view.arch,
                    x2mField: this.x2mField,
                    viewType: this.view_type,
                });

                if (this.view_type === 'list') {
                    editorParams.hasSelectors = false;
                }
                def = this.view.createStudioEditor(this, Editor, editorParams);
            } else {
                def = this.view.createStudioRenderer(this, {
                    mode: 'readonly',
                });
            }
        }
        const editor = await def;
        return editor;
    },
    /**
     * @override
     */
    _instantiateSidebar: function (state, previousState) {

        var defaultMode = this._getDefaultSidebarMode();
        state = _.defaults(state || {}, {
            mode: defaultMode,
            attrs: defaultMode === 'view' ? this.view.arch.attrs : {},
        });
        var modelName = this.x2mModel ? this.x2mModel : this.model_name;
        var params = {
            view_type: this.view_type,
            model_name: modelName,
            fields: this.fields,
            renamingAllowedFields: this.renamingAllowedFields,
            state: state,
            previousState: previousState,
            isEditingX2m: !!this.x2mField,
            // In case of a search view, the editor doesn't have state
            editorData: this.editor.state && this.editor.state.data || {},
            fieldsInfo: this.view.fieldsInfo ? this.view.fieldsInfo[this.view_type] : false,
            defaultOrder: this.view.arch.attrs.default_order || false,
        };

        if (_.contains(['list', 'form', 'kanban'], this.view_type)) {
            var fields_in_view = _.pick(this.fields, this.editor.state.getFieldNames());
            var fields_not_in_view = _.omit(this.fields, this.editor.state.getFieldNames());
            params.fields_not_in_view = fields_not_in_view;
            params.fields_in_view = fields_in_view;
        } else if (this.view_type === 'search') {
            // we return all the model fields since it's possible
            // to have multiple times the same field defined in the search view.
            params.fields_not_in_view = this.fields;
            params.fields_in_view = [];
        } else if (this.view_type === 'pivot') {
            params.colGroupBys = this.view.loadParams.colGroupBys;
            params.rowGroupBys = this.view.loadParams.rowGroupBys;
            params.measures = this.view.controllerParams.measures;
        } else if (this.view_type === 'graph') {
            params.groupBys = this.view.loadParams.groupBys;
            params.measure = this.view.loadParams.measure;
        }

        return new ViewEditorSidebar(this, params);
    },

    _computeX2mPath(x2mField, x2mViewType, fieldsView=null, x2mData=null) {
        let fields = this.fields;
        if (fieldsView) {
            fields = fieldsView.fields;
        }
        const x2mModel = fields[x2mField].relation;

        let data = x2mData;
        if (x2mViewType === 'form' && data.count) {
            // the x2m data is a datapoint type list and we need the datapoint
            // type record to open the form view with an existing record
            data = data.data[0];
        }
        const context = _.omit(data.getContext(), function (val, key) {
            return key.startsWith('default_');
        });

        const x2mViewParams = {
            currentId: data.res_id,
            context: context,
            ids: data.res_ids,
            model: this.editor.model,  // reuse the same BasicModel instance
            modelName: x2mModel,
            parentID: this.editor.state.id,
        };

        return  {
            parentViewType: this.view_type,
            x2mField: x2mField,
            x2mViewType: x2mViewType,
            x2mModel,
            x2mData,
            x2mViewParams,
            x2mViewContext: this.view.loadParams.context,
        };
    },
    /**
     * Processes the fields to write the field name inside the description. This
     * name is mainly used in the sidebar.
     *
     * @private
     * @param {Object} fields
     * @returns {Object} a deep copy of fields with the key as attribute `name`
     */
    _processFields: function (fields) {
        fields = $.extend(true, {}, fields);  // deep copy
        _.each(fields, function (value, key) {
            value.name = key;
        });
        return fields;
    },
    /**
     * @private
     * @param {String} type
     * @param {Object} node
     * @param {Object} xpath_info
     */
    _removeElement: function (type, node, xpath_info) {
        // After the element removal, if the parent doesn't contain any children
        // anymore, the parent node is also deleted (except if the parent is
        // the only remaining node and if we are editing a x2many subview)
        if (!this.x2mField) {
            var parent_node = findParent(this.view.arch, node, this.expr_attrs);
            var is_root = !findParent(this.view.arch, parent_node, this.expr_attrs);
            var is_group = parent_node.tag === 'group';
            if (parent_node.children.length === 1 && !is_root && !is_group) {
                node = parent_node;
                // Since we changed the node being deleted, we recompute the xpath_info
                // if necessary
                if (node && _.isEmpty(_.pick(node.attrs, this.expr_attrs[node.tag]))) {
                    xpath_info = findParentsPositions(this.view.arch, node);
                }
            }
        }

        this.editor.unselectedElements();
        this._resetSidebarMode();
        this._do({
            type: type,
            target: {
                tag: node.tag,
                attrs: _.pick(node.attrs, this.expr_attrs[node.tag]),
                xpath_info: xpath_info,
            },
        });
    },
    /**
     * Rename field.
     *
     * @private
     * @param {string} oldName
     * @param {string} newName
     * @returns {Promise}
     */
    _renameField: function (oldName, newName) {
        var self = this;

        // blockUI is used to prevent the user from doing any operation
        // because the hooks are still related to the old field name
        framework.blockUI();
        this.sidebar.$('input').attr('disabled', true);
        this.sidebar.$('select').attr('disabled', true);

        return this._rpc({
            route: '/web_studio/rename_field',
            params: {
                studio_view_id: this.studio_view_id,
                studio_view_arch: this.studio_view_arch,
                model: this.x2mModel ? this.x2mModel : this.model_name,
                old_name: oldName,
                new_name: newName,
            },
        }).then(function () {
            self._updateOperations(oldName, newName);
            var oldFieldIndex = self.renamingAllowedFields.indexOf(oldName);
            self.renamingAllowedFields.splice(oldFieldIndex, 1);
            self.renamingAllowedFields.push(newName);
            return self._applyChanges().then(framework.unblockUI).guardedCatch(framework.unblockUI);
        }).guardedCatch(framework.unblockUI);
    },
    /**
     * @private
     */
    _resetSidebarMode: function () {
        this._updateSidebar(this._getDefaultSidebarMode());
    },
    /**
     * @private
     * @param {int} view_id
     * @returns {Promise}
     */
    _restoreDefaultView: async function (view_id) {
        core.bus.trigger('clear_cache');
        const result = await this._rpc({
            route: '/web_studio/restore_default_view',
            params: {
                view_id: view_id,
            },
        });
        await this._applyChangeHandling(result);
        this.studio_view_id = null;
        this.operations = [];
        this.operations_undone = [];
        this.studio_view_arch = "";
        this._updateButtons();
        await this._updateSidebar(this.sidebar.state.mode);
        bus.trigger('toggle_snack_bar', 'saved');
    },
    /**
     * @private
     * @param {String} model_name
     * @param {String} field_name
     * @param {*} value
     * @returns {Promise}
     */
    _setDefaultValue: function (model_name, field_name, value) {
        var params = {
            model_name: model_name,
            field_name: field_name,
            value: value,
        };
        return this._rpc({route: '/web_studio/set_default_value', params: params});
    },
    /**
     * @private
     * @param {String} model_name
     * @param {[type]} value
     * @returns {Promise}
     */
    _setEmailAlias: function (model_name, value) {
        return this._rpc({
            route: '/web_studio/set_email_alias',
            params: {
                model_name: model_name,
                value: value,
            },
        });
    },
    /**
     * Modifies in place the operation to add `subview_xpath` on the target key.
     *
     * @private
     * @param {Object} op
     */
    _setSubViewXPath: function (op) {
        var subviewXpath = this._getSubviewXpath(this.x2mEditorPath);
        // If the xpath_info last element is the same than the subview type
        // we remove it since it will be added by the subviewXpath.
        if (op.target.xpath_info && op.target.xpath_info[0].tag === this.x2mViewType) {
            op.target.xpath_info.shift();
        }
        op.target.subview_xpath = subviewXpath;

        if (op.type === 'move') {
            // the node also comes from the subview in 'move' operations
            op.node.subview_xpath = subviewXpath;
        }
    },
    /**
     * Slugifies a string (used to transform a label into a field name)
     * Source: https://gist.github.com/mathewbyrne/1280286
     *
     * @private
     * @param {string} text
     * @returns {string}
     */
    _slugify: function (text) {
        return text.toString().toLowerCase().trim()
            .replace(/[^\w\s-]/g, '') // remove non-word [a-z0-9_], non-whitespace, non-hyphen characters
            .replace(/[\s_-]+/g, '_') // swap any length of whitespace, underscore, hyphen characters with a single _
            .replace(/^-+|-+$/g, ''); // remove leading, trailing -
    },
    /**
     * Updates the list of operations after a field renaming (i.e. replace all
     * occurences of @oldName by @newName).
     *
     * @private
     * @param {string} oldName
     * @param {string} newName
     */
    _updateOperations: function (oldName, newName) {
        var strOperations = JSON.stringify(this.operations);
        // We only want to replace exact matches of the field name, but it can
        // be preceeded/followed by other characters, like parent.my_field or in
        // a domain like [('...', '...', my_field)] etc.
        // Note that negative lookbehind is not correctly handled in JS ...
        var chars = '[^\\w\\u007F-\\uFFFF]';
        var re = new RegExp('(' + chars + '|^)' + oldName + '(' + chars + '|$)', 'g');
        this.operations = JSON.parse(strOperations.replace(re, '$1' + newName + '$2'));
    },

    //--------------------------------------------------------------------------
    // Handlers
    //--------------------------------------------------------------------------

    /**
    * Handler for 'Remove rule' button.
    * @private
    * @param {OdooEvent} ev
    */
    _onApprovalArchive: async function (ev) {
        bus.trigger("toggle_snack_bar", "saving");
        await this._rpc({
            model: "studio.approval.rule",
            method: "write",
            args: [[ev.data.ruleId], { active: false }],
        });
        await this._updateSidebar(this.sidebar.state.mode, {
            node: this.sidebar.state.node,
        });
        bus.trigger("toggle_snack_bar", "saved");
        this.updateEditor();
    },
    /**
     * Handler for generic edition of approval rule.
     * @private
     * @param {OdooEvent} ev
     */
    _onApprovalChange: async function(ev) {
        const node = ev.data.node;
        // modifying approval spec, everything done server-side
        // and widgets will fetch their spec on re-render
        const isMethod = node.attrs.type === 'object';
        bus.trigger('toggle_snack_bar', 'saving');
        const result = await this._rpc({
            route: '/web_studio/edit_approval',
            params: {
                model: this.model_name,
                method: isMethod?node.attrs.name:false,
                action: isMethod?false:node.attrs.name,
                operations: [[ev.data.type, ev.data.ruleId, ev.data.payload]],
            }
        });
        bus.trigger('toggle_snack_bar', 'saved');
    },
    /**
    * Handler for writing the domain on an approval rule (when the domain
    * selection dialog is closed).
    * @private
    * @param {OdooEvent} ev
    */
   _onApprovalCondition: async function (ev) {
        bus.trigger("toggle_snack_bar", "saving");
        await this._rpc({
            model: "studio.approval.rule",
            method: "write",
            args: [[ev.data.ruleId], { domain: ev.data.domain }],
        });
        bus.trigger("toggle_snack_bar", "saved");
        this._updateSidebar(this.sidebar.state.mode, {
            node: this.sidebar.state.node,
        });
    },
    /**
    * Handler for changes on the 'group_id' field of an approval rule.
    * @private
    * @param {OdooEvent} ev
    */
    _onApprovalGroupChange: async function (ev) {
        bus.trigger("toggle_snack_bar", "saving");
        await this._rpc({
            model: "studio.approval.rule",
            method: "write",
            args: [[ev.data.ruleId], { group_id: ev.data.groupId }],
        });
        bus.trigger("toggle_snack_bar", "saved");
        this._updateSidebar(this.sidebar.state.mode, {
            node: this.sidebar.state.node,
        });
    },
    /**
    * Handler for 'add approval rule' button.
    * @private
    * @param {OdooEvent} ev
    */
    _onApprovalNewRule: async function (ev) {
        bus.trigger("toggle_snack_bar", "saving");
        await this._rpc({
            model: "studio.approval.rule",
            method: "create_rule",
            args: [],
            kwargs: {
                model: ev.data.model,
                method: ev.data.method,
                action_id: parseInt(ev.data.action),
            },
        });
        await this._updateSidebar(this.sidebar.state.mode, {
            node: this.sidebar.state.node,
        });
        bus.trigger("toggle_snack_bar", "saved");
        this.updateEditor();
    },
    /**
     * @override
     */
    _onCloseXMLEditor: function () {
        this._super.apply(this, arguments);
        this.updateEditor();
    },
    /**
     * Show nearrest hook.
     *
     * @override
     */
    _onDragComponent: function (ev) {
        var is_nearest_hook = this.editor.highlightNearestHook(ev.data.$helper, ev.data.position);
        ev.data.$helper.toggleClass('ui-draggable-helper-ready', is_nearest_hook);
    },
    /**
     * @private
     * @param {OdooEvent} event
     */
    _onDefaultValueChange: function (event) {
        var data = event.data;
        var modelName = this.x2mModel ? this.x2mModel : this.model_name;
        this._setDefaultValue(modelName, data.field_name, data.value)
            .guardedCatch(function () {
                if (data.on_fail) {
                    data.on_fail();
                }
            });
    },
    /**
     * @private
     * @param {OdooEvent} event
     */
    _onEmailAliasChange: function (event) {
        var value = event.data.value;
        var modelName = this.x2mModel ? this.x2mModel : this.model_name;
        this._setEmailAlias(modelName, value);
    },
    /**
     * @private
     * @param {OdooEvent} event
     */
    _onFieldEdition: function (event) {
        var self = this;
        var node = event.data.node;
        var field = this.fields[node.attrs.name];
        var dialog = new NewFieldDialog(this, this.model_name, field, this.fields).open();
        var modelName = this.x2mModel ? this.x2mModel : this.model_name;
        dialog.on('field_default_values_saved', this, function (values) {
            self._editField(modelName, field.name, values).then(function (result) {
                const _closeDialog = function () {
                    dialog.close();
                    self._applyChanges(false, false);
                };
                if (result && result.records_linked) {
                    const message = result.message || _t("Are you sure you want to remove the selection values?");
                    Dialog.confirm(self, message, {
                        confirm_callback: async function () {
                            await self._editField(modelName, field.name, values, true);
                            _closeDialog();
                        },
                        dialogClass: 'o_web_studio_preserve_space'
                    });
                } else {
                    _closeDialog();
                }
            });
        });
    },
    /**
     * @private
     * @param {OdooEvent} event
     */
    _onFieldRenamed: function (event) {
        this._renameField(event.data.oldName, event.data.newName);
    },
    /**
     * Toggle editor sidebar.
     *
     * @param {Object} ev.data.node
     * @param {jQueryElement} [ev.data.$node]
     * @override
     *
     */
    _onNodeClicked: function (ev) {
        var self = this;
        var node = ev.data.node;
        var $node = ev.data.$node;
        if (this.view_type === 'form' && node.tag === 'field') {
            var field = this.fields[node.attrs.name];
            var attrs = this.editor.state.fieldsInfo[this.editor.state.viewType][node.attrs.name];
            var isX2Many = _.contains(['one2many','many2many'], field.type);
            var notEditableWidgets = ['many2many_tags', 'hr_org_chart'];
            if (isX2Many && !_.contains(notEditableWidgets, attrs.widget)) {
                // If the node is a x2many we offer the possibility to edit or
                // create the subviews
                var message = $(QWeb.render('web_studio.X2ManyEdit'));
                var options = {
                    baseZ: 1000, // reset z-index to 1000 from 1100 for element blocking else dialog hides behind it
                    message: message,
                    css: {
                        cursor: 'auto',
                    },
                    overlayCSS: {
                        cursor: 'auto',
                    }
                };
                // Only the o_field_x2many div needs to be overlaid.
                // So if the node is not the div we find it before applying the overlay.
                if ($node.hasClass('o_field_one2many') || $node.hasClass('o_field_many2many')) {
                    $node.block(options);
                } else {
                    $node.find('div.o_field_one2many, div.o_field_many2many').block(options);
                }
                $node.find('.o_web_studio_editX2Many').click(function (e) {
                    e.preventDefault();
                    e.stopPropagation();
                    const x2mFieldName = node.attrs.name;
                    const x2mViewType = e.currentTarget.dataset.type;
                    // trigger on studioBus
                    bus.trigger('STUDIO_ENTER_X2M',
                        self._computeX2mPath(x2mFieldName, x2mViewType, null, self.editor.state.data[x2mFieldName])
                    );
                });
            }
        }
        this._updateSidebar('properties', ev.data);
    },
    /**
     * @private
     * @param {OdooEvent} event
     */
    _onOpenDefaults: function () {
        var modelName = this.x2mModel ? this.x2mModel : this.model_name;
        this.do_action({
            name: _t('Default Values'),
            type: 'ir.actions.act_window',
            res_model: 'ir.default',
            target: 'current',
            views: [[false, 'list'], [false, 'form']],
            domain: [['field_id.model', '=', modelName]],
        });
    },
    /**
     * @private
     * @param {OdooEvent} event
     */
    _onOpenFieldForm: function (event) {
        var self = this;
        var field_name = event.data.field_name;
        var modelName = this.x2mModel ? this.x2mModel : this.model_name;
        this._rpc({
            model: 'ir.model.fields',
            method: 'search_read',
            fields: ['id'],
            domain: [['model', '=', modelName], ['name', '=', field_name]],
        }).then(function (result) {
            var res_id = result.length && result[0].id;
            if (res_id) {
                self.do_action({
                    type: 'ir.actions.act_window',
                    res_model: 'ir.model.fields',
                    res_id: res_id,
                    views: [[false, 'form']],
                    target: 'current',
                });
            }
        });
    },
    /**
     * @private
     */
    _onOpenRecordFormView: function () {
        this.do_action({
            type: 'ir.actions.act_window',
            res_model: 'ir.ui.view',
            res_id: this.view_id,
            views: [[false, 'form']],
            target: 'current',
        });
    },
    /**
     * @override
     */
    _onOpenXMLEditor: function () {
        this._super.apply(this, arguments);
        this.renamingAllowedFields = [];
        this.updateEditor();  // the editor will be rendered in `rendering` mode
    },
    /**
     * @private
     * @param {OdooEvent} ev
     */
    _onShowInvisibleToggled: function (ev) {
        this.updateEditor({ show_invisible: Boolean(ev.data.show_invisible) });
    },
    /**
     * @private
     * @param {OdooEvent} event
     */
    _onViewChange: function (event) {
        var structure = event.data.structure;
        var type = event.data.type;
        var node = event.data.node;
        var new_attrs = event.data.new_attrs || {};
        var position = event.data.position || 'after';
        var xpath_info;
        if (node) {
            const arch = Editors[this.view_type].prototype.preprocessArch(this.view.arch);
            xpath_info = findParentsPositions(arch, node);
        }
        switch (structure) {
            case 'text':
                break;
            case 'picture':
                break;
            case 'group':
                this._addElement(type, node, xpath_info, position, 'group');
                break;
            case 'button':
                this._addButton(event.data);
                break;
            case 'notebook':
                this._addElement(type, node, xpath_info, position, 'notebook');
                break;
            case 'page':
                this._addPage(type, node, xpath_info, position);
                break;
            case 'field':
                var field_description = event.data.field_description;
                new_attrs = _.pick(new_attrs, ['name', 'widget', 'options', 'display', 'optional']);
                this._addField(type, field_description, node, xpath_info, position,
                    new_attrs, event.data);
                break;
            case 'chatter':
                this._addChatter(event.data);
                break;
            case 'kanban_cover':
                this._editKanbanCover(type);
                break;
            case 'kanban_dropdown':
                this._addKanbanDropdown();
                break;
            case 'kanban_priority':
                this._addKanbanPriority(event.data);
                break;
            case 'kanban_image':
                this._addKanbanImage(event.data);
                break;
            case 'remove':
                this._removeElement(type, node, xpath_info);
                break;
            case 'view_attribute':
                this._editViewAttributes(type, new_attrs);
                break;
            case 'edit_attributes':
                this._editElementAttributes(type, node, xpath_info,
                    new_attrs);
                break;
            case 'filter':
                new_attrs = _.pick(new_attrs, ['name', 'string', 'domain', 'context', 'create_group', 'date']);
                this._addFilter(type, node, xpath_info, position, new_attrs);
                break;
            case 'separator':
                this._addSeparator(type, node, xpath_info, position);
                break;
            case 'restore':
                this._restoreDefaultView(this.view_id);
                break;
            case 'map_popup':
                this._changeMapPopupFields(type, event.data.field_ids);
                break;
            case 'pivot_popup':
                this._changePivotMeasuresFields(type, event.data.field_ids);
                break;
            case 'graph_pivot_groupbys_fields':
                this._changeGraphPivotGroupbysFields(type, event.data);
                break;
            case 'avatar_image':
                this._addAvatarImage(event.data);
                break;
            case 'enable_approval':
                this._addApproval(event.data);
                break;
        }
    },
});

function findParent(arch, node, expr_attrs) {
    var parent = arch;
    var result;
    var xpathInfo = findParentsPositions(arch, node);
    _.each(parent.children, function (child) {
        var deepEqual = true;
        // If there is not the expr_attr, we can't compare the nodes with it
        // so we compute the child xpath_info and compare it to the node
        // we are looking in the arch.
        if (_.isEmpty(_.pick(child.attrs, expr_attrs[child.tag]))) {
            var childXpathInfo = findParentsPositions(arch, child);
            _.each(xpathInfo, function (node, index) {
                if (index >= childXpathInfo.length) {
                    deepEqual = false;
                } else if (!_.isEqual(xpathInfo[index], childXpathInfo[index])) {
                    deepEqual = false;
                }
            });
        }
        if (deepEqual && child.attrs && child.attrs.name === node.attrs.name) {
            result = parent;
        } else {
            var res = findParent(child, node, expr_attrs);
            if (res) {
                result = res;
            }
        }
    });
    return result;
}

function findParentsPositions(arch, node) {
    return _findParentsPositions(arch, node, [], 1);
}

function _findParentsPositions(parent, node, positions, indice) {
    var result;
    positions.push({
        'tag': parent.tag,
        'indice': indice,
    });
    if (parent === node) {
        return positions;
    } else {
        var current_indices = {};
        _.each(parent.children, function (child) {
            // Save indice of each sibling node
            current_indices[child.tag] = current_indices[child.tag] ? current_indices[child.tag] + 1 : 1;
            var res = _findParentsPositions(child, node, positions, current_indices[child.tag]);
            if (res) {
                result = res;
            } else {
                positions.pop();
            }
        });
    }
    return result;
}

return ViewEditorManager;

});
;

/****************************************************************************
*  Filepath: /web_studio/static/src/legacy/js/views/view_editor_sidebar.js  *
*  Bundle: web_studio.studio_assets                                         *
*  Lines: 1462                                                              *
****************************************************************************/
odoo.define('web_studio.ViewEditorSidebar', function (require) {
"use strict";

var config = require('web.config');
var core = require('web.core');
var Dialog = require('web.Dialog');
var DomainSelectorDialog = require("web.DomainSelectorDialog");
var Domain = require("web.Domain");
var field_registry = require('web.field_registry');
var fieldRegistryOwl = require('web.field_registry_owl');
var pyUtils = require('web.py_utils');
var relational_fields = require('web.relational_fields');
var session = require("web.session");
var StandaloneFieldManagerMixin = require('web.StandaloneFieldManagerMixin');
var utils = require('web.utils');
var view_components = require('web_studio.view_components');
var Widget = require('web.Widget');

var form_component_widget_registry = view_components.registry;
var _lt = core._lt;
var _t = core._t;
var Many2ManyTags = relational_fields.FieldMany2ManyTags;
const Many2One = relational_fields.FieldMany2One;


/**
 * This object is used to define all the options editable through the Studio
 * sidebar, by field widget.
 *
 * An object value must be an array of Object (one object by option).
 * An option object must have as attributes a `name`, a `string` and a `type`
 * (currently among `boolean` and `selection`):
 *
 * * `selection` option must have an attribute `selection` (array of tuple).
 * * `boolean` option can have an attribute `leaveEmpty` (`checked` or
 *     `unchecked`).
 *
 * @type {Object}
 */
var OPTIONS_BY_WIDGET = {
    image: [
        {name: 'size', type: 'selection', string: _lt("Size"), selection: [
            [[0, 90], _lt("Small")], [[0, 180], _lt("Medium")], [[0, 270], _lt("Large")],
        ]},
    ],
    many2one: [
        {name: 'no_create', type: 'boolean', string: _lt("Disable creation"), leaveEmpty: 'unchecked'},
        {name: 'no_open', type: 'boolean', string: _lt("Disable opening"), leaveEmpty: 'unchecked'},
    ],
    many2many_tags: [
        { name: 'no_create', type: 'boolean', string: _lt("Disable creation"), leaveEmpty: 'unchecked' },
        {name: 'color_field', type: 'boolean', string: _lt("Use colors"), leaveEmpty: 'unchecked'},
    ],
    many2many_tags_avatar: [
        { name: 'no_create', type: 'boolean', string: _lt("Disable creation"), leaveEmpty: 'unchecked' },
    ],
    many2many_avatar_user: [
        { name: 'no_create', type: 'boolean', string: _lt("Disable creation"), leaveEmpty: 'unchecked' },
    ],
    many2many_avatar_employee: [
        { name: 'no_create', type: 'boolean', string: _lt("Disable creation"), leaveEmpty: 'unchecked' },
    ],
    radio: [
        {name: 'horizontal', type: 'boolean', string: _lt("Display horizontally")},
    ],
    signature: [
        {name: 'full_name', type: 'selection', string: _lt('Auto-complete with'), selection: [[]]},
        // 'selection' will be computed later on for the attribute to be dynamic (based on model fields)
    ],
    daterange: [
        {name: 'related_start_date', type: 'selection', string: _lt("Related Start Date"), selection: [[]]},
        {name: 'related_end_date', type: 'selection', string: _lt("Related End Date"), selection: [[]]},
    ],
    phone: [
        {name: 'enable_sms', type: 'boolean', string: _lt("Enable SMS")},
    ],
};

const UNSUPPORTED_WIDGETS_BY_VIEW = {
    list: ['many2many_checkboxes'],
};

return Widget.extend(StandaloneFieldManagerMixin, {
    template: 'web_studio.ViewEditorSidebar',
    events: {
        'click .o_web_studio_new:not(.inactive)':            '_onTab',
        'click .o_web_studio_view':                          '_onTab',
        'click .o_web_studio_xml_editor':                    '_onXMLEditor',
        'click .o_display_view .o_web_studio_parameters':    '_onViewParameters',
        'click .o_display_field .o_web_studio_parameters':   '_onFieldParameters',
        'click .o_display_view .o_web_studio_defaults':      '_onDefaultValues',
        'change #show_invisible':                            '_onShowInvisibleToggled',
        'click .o_web_studio_remove':                        '_onElementRemoved',
        'click .o_web_studio_restore':                       '_onRestoreDefaultView',
        'change .o_display_view input':                      '_onViewChanged',
        'change .o_display_view select':                     '_onViewChanged',
        'click .o_web_studio_edit_selection_values':         '_onSelectionValues',
        'change .o_display_field [data-type="attributes"]':  '_onElementChanged',
        'change .o_display_field [data-type="options"]':     '_onOptionsChanged',
        'change .o_display_div input[name="set_cover"]':     '_onSetCover',
        'change .o_display_field input[data-type="field_name"]': '_onFieldNameChanged',
        'focus .o_display_field input[data-type="attributes"][name="domain"]': '_onDomainEditor',
        'change .o_display_field [data-type="default_value"]': '_onDefaultValueChanged',
        'change .o_display_page input':                      '_onElementChanged',
        'change .o_display_label input':                     '_onElementChanged',
        'change .o_display_group input':                     '_onElementChanged',
        'change .o_display_button input':                    '_onElementChanged',
        'change .o_display_button select':                   '_onElementChanged',
        'click .o_web_studio_sidebar_approval .o_approval_archive':  '_onApprovalArchive',
        'change .o_web_studio_sidebar_approval':                     '_onApprovalChange',
        'click .o_web_studio_sidebar_approval .o_approval_domain':   '_onApprovalDomain',
        'click .o_web_studio_sidebar_approval .o_approval_new':      '_onApprovalNewRule',
        'click .o_display_button .o_img_upload':             '_onUploadRainbowImage',
        'click .o_display_button .o_img_reset':              '_onRainbowImageReset',
        'change .o_display_filter input':                    '_onElementChanged',
        'change .o_display_chatter input[data-type="email_alias"]': '_onEmailAliasChanged',
        'click .o_web_studio_attrs':                         '_onDomainAttrs',
        'focus .o_display_filter input#domain':              '_onDomainEditor',
        'keyup .o_web_studio_sidebar_search_input':          '_onSearchInputChange',
        'click .o_web_studio_existing_fields_header':        '_onClickExistingFieldHeader',
    },
    /**
     * @constructor
     * @param {Widget} parent
     * @param {Object} params
     * @param {Object} params.state
     * @param {Object} params.view_type
     * @param {Object} params.model_name
     * @param {Object} params.fields
     * @param {Object} params.fields_in_view
     * @param {Object} params.fields_not_in_view
     * @param {boolean} params.isEditingX2m
     * @param {Array} params.renamingAllowedFields
     */
    init: function (parent, params) {
        this._super.apply(this, arguments);
        StandaloneFieldManagerMixin.init.call(this);
        var self = this;
        this.accepted_file_extensions = 'image/*';
        this.debug = config.isDebug();

        this.view_type = params.view_type;
        this.model_name = params.model_name;
        this.isEditingX2m = params.isEditingX2m;
        this.editorData = params.editorData;
        this.renamingAllowedFields = params.renamingAllowedFields;

        this.fields = params.fields;
        this.fieldsInfo = params.fieldsInfo;
        if (params.defaultOrder) {
            if (params.defaultOrder.includes(',')) {
                params.defaultOrder = params.defaultOrder.split(',')[0];
            }
            this.defaultOrder = params.defaultOrder.split(' ');
        }
        this.orderered_fields = _.sortBy(this.fields, function (field) {
            return field.string.toLowerCase();
        });
        this.fields_in_view = params.fields_in_view;
        this.fields_not_in_view = params.fields_not_in_view;

        this.GROUPABLE_TYPES = ['many2one', 'char', 'boolean', 'selection', 'date', 'datetime'];
        // FIXME: At the moment, it's not possible to set default value for these types
        this.NON_DEFAULT_TYPES = ['many2one', 'many2many', 'one2many', 'binary'];
        this.MODIFIERS_IN_NODE_AND_ATTRS = ['readonly', 'invisible', 'required'];

        this.state = params.state || {};
        this.previousState = params.previousState || {};

        this._searchValue = '';
        this._isSearchValueActive = false;
        if (['kanban', 'search'].includes(this.view_type)) {
            this._isExistingFieldFolded = false;
        } else if ('_isExistingFieldFolded' in this.previousState) {
            this._isExistingFieldFolded = this.previousState._isExistingFieldFolded;
        } else {
            this._isExistingFieldFolded = true;
        }

        const Widget = this.state.attrs.Widget;
        this.widgetKey = this._getWidgetKey(Widget);

        const allowedModifiersNode = ['group', 'page', 'field', 'filter'];
        if (this.state.node && allowedModifiersNode.includes(this.state.node.tag)) {
            this.state.modifiers = this.state.attrs.modifiers || {};
        }

        if (this.state.node && (this.state.node.tag === 'field' || this.state.node.tag === 'filter')) {
            // deep copy of field because the object is modified
            // in this widget and this shouldn't impact it
            var field = jQuery.extend(true, {}, this.fields[this.state.attrs.name]);
            var unsupportedWidgets = UNSUPPORTED_WIDGETS_BY_VIEW[this.view_type] || [];

            // fieldRegistryMap contains all widgets and components but we want to filter
            // these widgets based on field types (and description for non debug mode)
            const fieldRegistryMap = Object.assign({}, field_registry.map, fieldRegistryOwl.map);
            field.field_widgets = _.chain(fieldRegistryMap)
                .pairs()
                .filter(function (arr) {
                    const supportedFieldTypes = utils.isComponent(arr[1]) ?
                        arr[1].supportedFieldTypes :
                        arr[1].prototype.supportedFieldTypes;
                    const description = self.getFieldInfo(arr[1], 'description');
                    const isWidgetKeyDescription = arr[0] === self.widgetKey && !description;
                    var isSupported = _.contains(supportedFieldTypes, field.type)
                        && arr[0].indexOf('.') < 0 && unsupportedWidgets.indexOf(arr[0]) < 0;
                    return config.isDebug() ? isSupported : isSupported && description || isWidgetKeyDescription;
                })
                .sortBy(function (arr) {
                    const description = self.getFieldInfo(arr[1], 'description');
                    return description || arr[0];
                })
                .value();

            this.state.field = field;

            // only for list & tree view
            this._computeFieldAttrs();

            // Get dynamic selection for 'full_name' node option of signature widget
            if (this.widgetKey === 'signature') {
                var selection = [[]]; // By default, selection should be empty
                var signFields = _.chain(_.sortBy(_.values(this.fields_in_view), 'string'))
                    .filter(function (field) {
                        return _.contains(['char', 'many2one'], field.type);
                    })
                    .map(function (val, key) {
                        return [val.name, config.isDebug() ? _.str.sprintf('%s (%s)', val.string, val.name) : val.string];
                    })
                    .value();
                _.findWhere(OPTIONS_BY_WIDGET[this.widgetKey], {name: 'full_name'}).selection = selection.concat(signFields);
            }
            // Get dynamic selection for 'related_start_date' and 'related_end_date' node option of daterange widget
            if (this.widgetKey === 'daterange') {
                var selection = [[]];
                var dateFields = _.chain(_.sortBy(_.values(this.fields_in_view), 'string'))
                    .filter(function (field) {
                        return _.contains([self.state.field.type], field.type);
                    })
                    .map(function (val, key) {
                        return [val.name, config.isDebug() ? _.str.sprintf('%s (%s)', val.string, val.name) : val.string];
                    })
                    .value();
                selection = selection.concat(dateFields);
                _.each(OPTIONS_BY_WIDGET[this.widgetKey], function (option) {
                    if (_.contains(['related_start_date', 'related_end_date'], option.name)) {
                        option.selection = selection;
                    }
                });
            }
            this.OPTIONS_BY_WIDGET = OPTIONS_BY_WIDGET;

            this.has_placeholder = Widget && Widget.prototype.has_placeholder || false;

            // aggregate makes no sense with some widgets
            this.hasAggregate = _.contains(['integer', 'float', 'monetary'], field.type) &&
                !_.contains(['progressbar', 'handle'], this.state.attrs.widget);

            if (this.view_type === 'kanban') {
                this.showDisplay = this.state.$node && !this.state.$node
                    .parentsUntil('.o_kanban_record')
                    .filter(function () {
                        // if any parent is display flex, display options (float
                        // right, etc.) won't work
                        return $(this).css('display') === 'flex';
                    }).length;
            }
        }
        // Upload image related stuff
        if (this.state.node && this.state.node.tag === 'button') {
            const isStatBtn = this.state.node.attrs.class === 'oe_stat_button';
            const isMethodBtn = this.state.node.attrs.type == 'object';
            this.showRainbowMan = !isStatBtn && isMethodBtn
            if (this.showRainbowMan) {
                this.state.node.widget = "image";
                this.user_id = session.uid;
                this.fileupload_id = _.uniqueId('o_fileupload');
                $(window).on(this.fileupload_id, this._onUploadRainbowImageDone.bind(this));
            }
        }
        if (this.state.mode === 'view' && this.view_type === 'gantt') {
            // precision attribute in gantt is complicated to write so we split it
            // {'day': 'hour:half', 'week': 'day:half', 'month': 'day', 'year': 'month:quarter'}
            this.state.attrs.ganttPrecision = this.state.attrs.precision ? pyUtils.py_eval(this.state.attrs.precision) : {};

        }
        if (this.state.mode === 'view' && this.view_type === 'pivot') {
            this.state.attrs.colGroupBys = params.colGroupBys;
            this.state.attrs.rowGroupBys = params.rowGroupBys;
            this.measures = params.measures;
        }
        if (this.state.mode === 'view' && this.view_type === 'graph') {
            this.state.attrs.groupBys = params.groupBys;
            this.state.attrs.measure = params.measure;
        }
    },
    /**
     * @override
     */
    start: function () {
        return this._super.apply(this, arguments).then(this._render.bind(this));
    },
    /**
     * Called each time the view editor sidebar is attached into the DOM.
    */
    on_attach_callback: function () {
        // focus only works on the elements attached on DOM, so we focus
        // and select the label once the sidebar is attached to DOM
        if (this.state.mode === 'properties') {
            this.$('input[name=string]').focus().select();
        }
    },
    /**
     * @override
     */
    destroy: function () {
        $(window).off(this.fileupload_id);
        return this._super.apply(this, arguments);
    },

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    /**
     * @override
     */
    getLocalState: function () {
        return { _isExistingFieldFolded: this._isExistingFieldFolded };
    },
    /**
     * Transform an array domain into its string representation.
     *
     * @param {Array} domain
     * @returns {String}
     */
    domainToStr: function (domain) {
        return Domain.prototype.arrayToString(domain);
    },
    /**
     * Returns class property's value.
     *
     * @param {any} fieldType
     * @param {string} propName
     */
    getFieldInfo(fieldType, propName) {
        return utils.isComponent(fieldType) ?
            (fieldType.hasOwnProperty(propName) && fieldType[propName]) :
            (fieldType.prototype.hasOwnProperty(propName) && fieldType.prototype[propName]);
    },
    /**
     * @param {string} fieldName
     * @returns {boolean} if the field can be renamed
     */
    isRenamingAllowed: function (fieldName) {
        return _.contains(this.renamingAllowedFields, fieldName);
    },
    /**
     * @param {String} value
     * @returns {Boolean}
     */
    isTrue: function (value) {
        return value !== 'false' && value !== 'False';
    },

    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------

    /**
     * Called by _onFieldChanged when the field changed is the M2O of an approval
     * rule for its res.groups field. Update the according rule server-side.
     * @private
     */
    _changeApprovalGroup: function (approvalField) {
        const record = this.model.get(this.approvalHandle);
        const groupId = record.data[approvalField].res_id;
        const ruleId = parseInt(/rule_group_(\d+)/.exec(approvalField)[1]);
        this.trigger_up('approval_group_change', {
            ruleId,
            groupId,
        });
    },
    /**
     * @private
     */
    _changeFieldGroup: function () {
        var record = this.model.get(this.groupsHandle);
        var new_attrs = {};
        new_attrs.groups = record.data.groups.res_ids;
        this.trigger_up('view_change', {
            type: 'attributes',
            structure: 'edit_attributes',
            node: this.state.node,
            new_attrs: new_attrs,
        });
    },
    /**
     * @private
     * @param {OdooEvent} ev
     * @param {Object} oldMapPopupField
     */
    _changeMapPopupFields: function (ev, oldMapPopupField) {
        const options = {structure: 'map_popup'};
        if (ev.data.changes.map_popup.operation === 'ADD_M2M') {
            const ids = ev.data.changes.map_popup.ids;
            options.type = 'add';
            options.field_ids = Array.isArray(ids) ? ids.map(i => i.id) : [ids.id];
        } else {
            options.type = 'remove';
            options.field_ids = [oldMapPopupField.data.find(i => i.id === ev.data.changes.map_popup.ids[0]).res_id];
        }
        this.trigger_up('view_change', options);
    },
    /**
     * @private
     * @param {OdooEvent} ev
     * @param {Object} oldPivotMeasuresField
     */
    _changePivotMeasuresFields(ev, oldPivotMeasuresField) {
        const options = {structure: 'pivot_popup'};
        if (ev.data.changes.pivot_popup.operation === 'ADD_M2M') {
            const ids = ev.data.changes.pivot_popup.ids;
            options.type = 'add';
            options.field_ids = Array.isArray(ids) ? ids.map(i => i.id) : [ids.id];
        } else {
            options.type = 'remove';
            options.field_ids = [oldPivotMeasuresField.data.find(i => i.id === ev.data.changes.pivot_popup.ids[0]).res_id];
        }
        this.trigger_up('view_change', options);
    },
    /**
     * @private
     */
    _computeFieldAttrs: function () {
        /* Compute field attributes.
         * These attributes are either taken from modifiers or attrs
         * so attrs store their combinaison.
         */
        this.state.attrs.invisible = this.state.modifiers.invisible || this.state.modifiers.column_invisible;
        this.state.attrs.readonly = this.state.modifiers.readonly;
        this.state.attrs.string = this.state.attrs.string || this.state.field.string;
        this.state.attrs.help = this.state.attrs.help || this.state.field.help;
        this.state.attrs.placeholder = this.state.attrs.placeholder || this.state.field.placeholder;
        this.state.attrs.required = this.state.field.required || this.state.modifiers.required;
        this.state.attrs.domain = this.state.attrs.domain || this.state.field.domain;
        this.state.attrs.context = this.state.attrs.context || this.state.field.context;
        this.state.attrs.related = this.state.field.related ? this.state.field.related : false;
    },
    /**
     * @private
     * @param {Object} modifiers
     * @returns {Object}
     */
    _getNewAttrsFromModifiers: function (modifiers) {
        var self = this;
        var newAttributes = {};
        var attrs = [];
        var originNodeAttr = this.state.modifiers;
        var originSubAttrs =  pyUtils.py_eval(this.state.attrs.attrs || '{}', this.editorData);
        _.each(modifiers, function (value, key) {
                var keyInNodeAndAttrs = _.contains(self.MODIFIERS_IN_NODE_AND_ATTRS, key);
                var keyFromView = key in originSubAttrs;
                var trueValue = value === true || _.isEqual(value, []);
                var isOriginNodeAttr = key in originNodeAttr;

                if (keyInNodeAndAttrs && !isOriginNodeAttr && trueValue) { // modifier always applied, use modifier attribute
                    newAttributes[key] = "1";
                } else if (keyFromView || !trueValue) { // modifier not applied or under certain condition, remove modifier attribute and use attrs if any
                    newAttributes[key] = "";
                    if (value !== false) {
                        attrs.push(_.str.sprintf("\"%s\": %s", key, Domain.prototype.arrayToString(value)));
                    }
                }
        });
        newAttributes.attrs = _.str.sprintf("{%s}", attrs.join(", "));
        return newAttributes;
    },
    /**
     * @private
     * @param {Class} Widget
     * @returns {string} the field key
     */
    _getWidgetKey: function (Widget) {
        var widgetKey = this.state.attrs.widget;
        if (!widgetKey) {
            const fieldRegistryMap = Object.assign({}, field_registry.map, fieldRegistryOwl.map);
            _.each(fieldRegistryMap, function (val, key) {
                if (val === Widget) {
                    widgetKey = key;
                }
            });
            // widget key can be prefixed by a view type (like form.many2many_tags)
            if (_.str.include(widgetKey, '.')) {
                widgetKey = widgetKey.split('.')[1];
            }
        }
        return widgetKey;
    },
    /**
     * Render additional sections according to the sidebar mode
     * i.e. the new & existing field if 'new', etc.
     *
     * @private
     * @returns {Promise}
     */
    _render: function () {
        this.defs = [];
        if (this.state.mode === 'new') {
            if (!this._isSearchValueActive) {
                if (_.contains(['form', 'search'], this.view_type)) {
                    this._renderComponentsSection();
                }
                if (_.contains(['list', 'form'], this.view_type)) {
                    this._renderNewFieldsSection();
                }
            }
            this._renderExistingFieldsSection();
            return Promise.all(this.defs).then(() => {
                delete(this.defs);
                this.$('.o_web_studio_component').on("drag", _.throttle((event, ui) => {
                    this.trigger_up('drag_component', {position: {pageX: event.pageX, pageY: event.pageY}, $helper: ui.helper});
                }, 200));
            });
        } else if (this.state.mode === 'properties') {
            if (this.$('.o_groups').length) {
                this.defs.push(this._renderWidgetsM2MGroups());
            }
            if (this.el.querySelectorAll('.o_studio_sidebar_approval_rule').length) {
                this.defs.push(this._renderWidgetsApprovalRules());
            }
            return Promise.all(this.defs).then(() => delete(this.defs));
        }
        if (this.view_type === 'map' && this.$('.o_map_popup_fields').length) {
            delete(this.defs);
            return this._renderWidgetsMapPopupFields();
        }
        if (this.view_type === 'pivot' && this.$('.o_pivot_measures_fields').length) {
            delete(this.defs);
            return this._renderWidgetsPivotMeasuresFields();
        }
    },
    /**
     * @private
     */
    _renderComponentsSection: function () {
        const widgetClasses = form_component_widget_registry.get(this.view_type + '_components');
        const formWidgets = widgetClasses.map(FormComponent => new FormComponent(this));
        const $sectionTitle = $('<h3>', {
            html: _t('Components'),
        });
        const $section = this._renderSection(formWidgets);
        $section.addClass('o_web_studio_new_components');
        const $sidebarContent = this.$('.o_web_studio_sidebar_content');
        $sidebarContent.append($sectionTitle, $section);
    },
    /**
     * @private
     */
    _renderExistingFieldsSection: function () {
        const $existingFields = this.$('.o_web_studio_existing_fields');
        if ($existingFields.length) {
            $existingFields.remove();  // clean up before re-rendering
        }

        let formWidgets;
        const formComponent = form_component_widget_registry.get('existing_field');
        if (this.view_type === 'search') {
            formWidgets = Object.values(this.fields).map(field =>
                new formComponent(this, field.name, field.string, field.type, field.store));
        } else {
            const fields = _.sortBy(this.fields_not_in_view, function (field) {
                return field.string.toLowerCase();
            });
            const attrs = {};
            if (this.view_type === 'list') {
                attrs.optional = 'show';
            }
            formWidgets = fields.map(field => {
                return new formComponent(this, field.name, field.string, field.type, field.store, Object.assign({}, attrs));
            });
        }

        if (this._searchValue) {
            formWidgets = formWidgets.filter(result => {
                const searchValue = this._searchValue.toLowerCase();
                if (this.debug) {
                    return result.label.toLowerCase().includes(searchValue) ||
                        result.description.toLowerCase().includes(searchValue);
                }
                return result.label.toLowerCase().includes(searchValue);
            });
        }

        const $sidebarContent = this.$('.o_web_studio_sidebar_content');
        const $existingFieldsSection = $('<div/>', {class: `o_web_studio_existing_fields_section`});
        const $section = this._renderSection(formWidgets);
        $section.addClass('o_web_studio_existing_fields');
        if ($existingFields.length) {
            this.$('.o_web_studio_existing_fields_section').append($section);
        } else {
            const $sectionTitle = $('<h3>', {
                text: _t('Existing Fields'),
                class: 'o_web_studio_existing_fields_header',
            }).append($('<i/>', {class: `o_web_studio_existing_fields_icon fa fa-caret-right ml-2`}));
            const $sectionSubtitle = $('<h6>', {
                class: 'small text-white',
                text: _t('The following fields are currently not in the view.'),
            });
            const $sectionSearchDiv = core.qweb.render('web_studio.ExistingFieldsInputSearch');
            $existingFieldsSection.append($sectionSubtitle, $sectionSearchDiv, $section);
            $sidebarContent.append($sectionTitle, $existingFieldsSection);
        }

        this._updateExistingFieldSection();
    },
    /**
     * @private
     */
    _renderNewFieldsSection: function () {
        const widgetClasses = form_component_widget_registry.get('new_field');
        const attrs = {};
        if (this.view_type === 'list') {
            attrs.optional = 'show';
        }
        const formWidgets = widgetClasses.map(FormComponent => {
            return new FormComponent(this, Object.assign({}, attrs));
        });
        const $sectionTitle = $('<h3>', {
            html: _t('New Fields'),
        });
        const $section = this._renderSection(formWidgets);
        $section.addClass('o_web_studio_new_fields');

        const $sidebarContent = this.$('.o_web_studio_sidebar_content');
        $sidebarContent.append($sectionTitle, $section);
    },
    /**
     * @private
     * @param {Object} form_widgets
     * @returns {JQuery}
     */
    _renderSection: function (form_widgets) {
        var self = this;
        var $components_container = $('<div>').addClass('o_web_studio_field_type_container');
        form_widgets.forEach(function (form_component) {
            self.defs.push(form_component.appendTo($components_container));
        });
        return $components_container;
    },
    /**
     * Render and attach group widget for each approval rule.
     * @private
     * @returns {Promise}
     */
    _renderWidgetsApprovalRules: async function () {
        const groupTargets = this.el.querySelectorAll('.o_approval_group');
        const fields = [];
        groupTargets.forEach((node) => {
            fields.push({
                name: 'rule_group_' + node.dataset.ruleId,
                fields: [{
                    name: 'id',
                    type: 'integer',
                }, {
                    name: 'display_name',
                    type: 'char',
                }],
                relation: 'res.groups',
                type: 'many2one',
                value: parseInt(node.dataset.groupId),
            })
        });
        this.approvalHandle  = await this.model.makeRecord('ir.model.fields', fields);
        const record = this.model.get(this.approvalHandle);
        const defs = [];
        groupTargets.forEach((node, index) => {
            const options = {
                idForLabel: 'group',
                mode: 'edit',
                noOpen: true,
            };
            const fieldName = fields[index].name;
            const many2one = new Many2One(this, fieldName, record, options);
            this._registerWidget(this.approvalHandle, 'group', many2one);
            defs.push(many2one.prependTo($(node)));
        });
        return Promise.all(defs);
    },
    /**
     * @private
     * @returns {Promise}
     */
    _renderWidgetsM2MGroups: function () {
        var self = this;
        var studio_groups = this.state.attrs.studio_groups && JSON.parse(this.state.attrs.studio_groups);
        return this.model.makeRecord('ir.model.fields', [{
            name: 'groups',
            fields: [{
                name: 'id',
                type: 'integer',
            }, {
                name: 'display_name',
                type: 'char',
            }],
            relation: 'res.groups',
            type: 'many2many',
            value: studio_groups,
        }]).then(function (recordID) {
            self.groupsHandle = recordID;
            var record = self.model.get(self.groupsHandle);
            var options = {
                idForLabel: 'groups',
                mode: 'edit',
                no_quick_create: true,
            };
            var many2many = new Many2ManyTags(self, 'groups', record, options);
            self._registerWidget(self.groupsHandle, 'groups', many2many);
            return many2many.appendTo(self.$('.o_groups'));
        });
    },
    /**
     * @private
     * @returns {Promise}
     */
    _renderWidgetsMapPopupFields: function () {
        const fieldIDs = JSON.parse(this.state.attrs.studio_map_field_ids || '[]');
        return this.model.makeRecord('ir.model', [{
            name: 'map_popup',
            fields: [{
                name: 'id',
                type: 'integer',
            }, {
                name: 'display_name',
                type: 'char',
            }],
            domain: [
                ['model', '=', this.model_name],
                ['ttype', 'not in', ['many2many', 'one2many', 'binary']]
            ],
            relation: 'ir.model.fields',
            type: 'many2many',
            value: fieldIDs,
        }], {
            map_popup: {
                can_create: false
            },
        }).then(recordID => {
            this.mapPopupFieldHandle = recordID;
            const record = this.model.get(this.mapPopupFieldHandle);
            const many2many = new Many2ManyTags(this, 'map_popup', record, {mode: 'edit'});
            this._registerWidget(this.mapPopupFieldHandle, 'map_popup', many2many);
            return many2many.appendTo(this.$('.o_map_popup_fields'));
        });
    },
    /**
     * Applies the correct classNames on the "Existing Fields" section according
     * to the "_isExistingFieldFolded" flag.
     *
     * @private
     */
    _updateExistingFieldSection() {
        const icon = this.el.querySelector('.o_web_studio_existing_fields_icon');
        const section = this.el.querySelector('.o_web_studio_existing_fields_section');
        if (this._isExistingFieldFolded) {
            icon.classList.replace('fa-caret-down', 'fa-caret-right');
            section.classList.add('d-none');
        } else {
            icon.classList.replace('fa-caret-right', 'fa-caret-down');
            section.classList.remove('d-none');
        }
    },
    /**
     * @private
     * @returns {Promise}
     */
    _renderWidgetsPivotMeasuresFields() {
        const measuresKeys = Object.keys(this.measures);
        const fieldIDs = JSON.parse(this.state.attrs.studio_pivot_measure_field_ids || '[]');
        return this.model.makeRecord('ir.model', [{
            name: 'pivot_popup',
            fields: [{
                name: 'id',
                type: 'integer',
            }, {
                name: 'display_name',
                type: 'char',
            }],
            domain: [
                ['model', '=', this.model_name],
                ['name', 'in', Object.keys(this.measures)]
            ],
            relation: 'ir.model.fields',
            type: 'many2many',
            value: fieldIDs,
        }], {
            pivot_popup: {
                can_create: false
            },
        }).then(recordID => {
            this.pivotPopupFieldHandle = recordID;
            const record = this.model.get(this.pivotPopupFieldHandle);
            const many2many = new Many2ManyTags(this, 'pivot_popup', record, { mode: 'edit' });
            this._registerWidget(this.pivotPopupFieldHandle, 'pivot_popup', many2many);
            return many2many.appendTo(this.$('.o_pivot_measures_fields'));
        });
    },

    //--------------------------------------------------------------------------
    // Handlers
    //--------------------------------------------------------------------------

    /**
     * Handle a click on 'remove rule' for approvals; dispatch to view editor
     * manager.
     * @private
     * @param {DOMEvent} ev
     */
    _onApprovalArchive: function (ev) {
        const ruleId = parseInt(ev.currentTarget.dataset.ruleId);
        this.trigger_up('approval_archive', {
            ruleId,
        });
    },
    /**
     * Handle a click on 'add approval rule'; dispatch to view editor
     * manager.
     * @private
     * @param {DOMEvent} ev
     */
    _onApprovalNewRule: function (ev) {
        const model = this.model_name;
        const isMethod = this.state.node.attrs.type === 'object';
        const method = isMethod?this.state.node.attrs.name:false
        const action = isMethod?false:this.state.node.attrs.name;
        this.trigger_up('approval_new_rule', {
            model,
            method,
            action,
        });
    },
    /**
     * Handler for the 'set condition' button of approval rules; instanciate
     * a domain selector dialog that will dispatch an event to the view editor
     * manager upon submission.
     * @private
     * @param {DOMEvent} ev
     */
    _onApprovalDomain: function(ev) {
        const ruleId = parseInt(ev.currentTarget.dataset.ruleId);
        const rule = this.state.approvalData.rules.find(r => r.id === ruleId);
        const dialog = new DomainSelectorDialog(this, this.model_name, rule.domain||[], {
            title: _t('Condition'),
            readonly: false,
            fields: this.fields,
            size: 'medium',
            operators: ["=", "!=", "<", ">", "<=", ">=", "in", "not in", "set", "not set"],
            followRelations: true,
            debugMode: config.isDebug(),
            $content: $('<div>').append('<p>', {text: _t('The approval rule is only applied to records matching the following condition:')}),
        }).open();
        dialog.on("domain_selected", this, function (e) {
            this.trigger_up('approval_condition', {
                ruleId: ruleId,
                domain: e.data.domain,
            });
        });
    },
    /**
     * Generic handlers for other operations on approvals; dispatch the correct event
     * to the view editor manager.
     * @private
     * @param {DOMEvent} ev
     */
    _onApprovalChange: function(ev) {
        let type, payload;
        // input name for approval rules are formatted as `input`_`rule_id`
        const inputName = ev.target.name;
        const parsedInput = /([a-zA-Z_]*)_(\d+)/.exec(inputName);
        let input, ruleId;
        if (parsedInput) {
            input = parsedInput[1];
            ruleId = parseInt(parsedInput[2]);
        } else {
            input = inputName;
        }
        switch (input) {
            case 'studio_approval':
                // special case: this is the one that actually edits the view
                return this.trigger_up('view_change', {
                    structure: 'enable_approval',
                    node: this.state.node,
                    enable: ev.target.checked,
                });
            case 'approval_message':
                type = 'operation_approval_message';
                payload = ev.target.value;
                break;
            case 'exclusive_user':
                type = 'operation_different_users';
                payload = ev.target.checked;
                break;
            default:
                console.debug('unsupported operation for approval modification', ev.target.name);
                return false;
        }
        this.trigger_up('approval_change', {
            type: type,
            payload: payload,
            ruleId: parseInt(ruleId),
            node: this.state.node,
        });
    },
    /**
     * @private
     */
    _onDefaultValues: function () {
        this.trigger_up('open_defaults');
    },
    /**
     * @private
     * @param {Event} ev
     */
    _onDefaultValueChanged: function (ev) {
        var self = this;
        var $input = $(ev.currentTarget);
        var value = $input.val();
        if (value !== this.state.default_value) {
            this.trigger_up('default_value_change', {
                field_name: this.state.attrs.name,
                value: value,
                on_fail: function () {
                    $input.val(self.default_value);
                }
            });
        }
    },
    /**
     * @private
     * @param {Event} ev
     */
    _onDomainAttrs: function (ev) {
        ev.preventDefault();
        var modifier = ev.currentTarget.dataset.type;

        // Add id to the list of usable fields
        var fields = this.fields_in_view;
        if (!fields.id) {
            fields = _.extend({
                id: {
                    searchable: true,
                    string: "ID",
                    type: "integer",
                },
            }, fields);
        }

        var dialog = new DomainSelectorDialog(this, this.model_name, _.isArray(this.state.modifiers[modifier]) ? this.state.modifiers[modifier] : [], {
            readonly: false,
            fields: fields,
            size: 'medium',
            operators: ["=", "!=", "<", ">", "<=", ">=", "in", "not in", "set", "not set"],
            followRelations: false,
            debugMode: config.isDebug(),
            $content: $(_.str.sprintf(
                _t("<div><p>The <strong>%s</strong> property is only applied to records matching this filter.</p></div>"),
                modifier
            )),
        }).open();
        dialog.on("domain_selected", this, function (e) {
            var newModifiers = _.extend({}, this.state.modifiers);
            newModifiers[modifier] = e.data.domain;
            var new_attrs = this._getNewAttrsFromModifiers(newModifiers);
            this.trigger_up('view_change', {
                type: 'attributes',
                structure: 'edit_attributes',
                node: this.state.node,
                new_attrs: new_attrs,
            });
        });
    },
    /**
     * @private
     * @param {Event} ev
     */
    _onDomainEditor: function (ev) {
        ev.preventDefault();
        var $input = $(ev.currentTarget);

        // If we want to edit a filter domain, we don't have a specific
        // field to work on but we want a domain on the current model.
        var model = this.state.node.tag === 'filter' ? this.model_name : this.state.field.relation;
        var dialog = new DomainSelectorDialog(this, model, $input.val(), {
            readonly: false,
            debugMode: config.isDebug(),
        }).open();
        dialog.on("domain_selected", this, function (e) {
            $input.val(Domain.prototype.arrayToString(e.data.domain)).change();
        });
    },
    /**
     * @private
     * @param {Event} ev
     */
    _onElementChanged: function (ev) {
        var $input = $(ev.currentTarget);
        var attribute = $input.attr('name');
        if (attribute && $input.attr('type') !== 'file') {
            var new_attrs = {};
            // rainbow attribute on button needs JSON value, so on change of any rainbow related
            // attributes, re-form rainbow attribute in required format, excluding falsy/empty
            // values
            if (attribute.match('^rainbow')) {
                if (this.$('input#rainbow').is(':checked')) {
                    new_attrs.effect = JSON.stringify(_.pick({
                            message: this.$('input#rainbow_message').val(),
                            img_url: this.$('input#rainbow_img_url').val(),
                            fadeout: this.$('select#rainbow_fadeout').val(),
                        }, _.identity)
                    );
                } else {
                    new_attrs.effect = 'False';
                }
            } else if (attribute === 'widget') {
                // reset widget options
                var widget = $input.val();
                new_attrs = {
                    widget: widget,
                    options: '',
                };
                if (widget === 'image') {
                    // add small as a default size for image widget
                    new_attrs.options = JSON.stringify({size: [0, 90]});
                }
            } else if ($input.attr('type') === 'checkbox') {
                if (!_.contains(this.MODIFIERS_IN_NODE_AND_ATTRS, attribute)) {
                    if ($input.is(':checked')) {
                        new_attrs[attribute] = $input.data('leave-empty') === 'checked' ? '': 'True';
                    } else {
                        new_attrs[attribute] = $input.data('leave-empty') === 'unchecked' ? '': 'False';
                    }
                } else {
                    var newModifiers = _.extend({}, this.state.modifiers);
                    newModifiers[attribute] = $input.is(':checked');
                    new_attrs = this._getNewAttrsFromModifiers(newModifiers);
                    if (attribute === 'readonly' && $input.is(':checked')) {
                        new_attrs.force_save = 'True';
                    }
                }
            } else if (attribute === 'aggregate') {
                var aggregate = $input.find('option:selected').attr('name');
                // only one of them can be set at the same time
                new_attrs = {
                    avg: aggregate === 'avg' ? 'Average of ' + this.state.attrs.string : '',
                    sum: aggregate === 'sum' ? 'Sum of ' +  this.state.attrs.string : '',
                };
            } else {
                new_attrs[attribute] = $input.val();
            }

            this.trigger_up('view_change', {
                type: 'attributes',
                structure: 'edit_attributes',
                node: this.state.node,
                new_attrs: new_attrs,
            });
        }
    },
    /**
     * @private
     */
    _onElementRemoved: function () {
        var self = this;
        var elementName = this.state.node.tag;
        if (elementName === 'div' && this.state.node.attrs.class === 'oe_chatter') {
            elementName = 'chatter';
        }
        var message = _.str.sprintf(_t('Are you sure you want to remove this %s from the view?'), elementName);

        Dialog.confirm(this, message, {
            confirm_callback: function () {
                self.trigger_up('view_change', {
                    type: 'remove',
                    structure: 'remove',
                    node: self.state.node,
                });
            }
        });
    },
    /**
     * @private
     * @param {Event} ev
     */
    _onEmailAliasChanged: function (ev) {
        var $input = $(ev.currentTarget);
        var value = $input.val();
        if (value !== this.state.email_alias) {
            this.trigger_up('email_alias_change', {
                value: value,
            });
        }
    },
    /**
     * @override
     * @private
     */
    _onFieldChanged: async function (ev) {
        const approvalChanges = Object.keys(ev.data.changes).filter(f => f.startsWith('rule_group_'));
        const isApprovalChange = approvalChanges.length;
        const isMapChange = Object.keys(ev.data.changes).filter(f => f === 'map_popup').length;
        const isPivotChange = Object.keys(ev.data.changes).filter(f => f === 'pivot_popup').length;
        const approvalField = isApprovalChange && approvalChanges[0];
        const oldMapPopupField = this.mapPopupFieldHandle && this.model.get(this.mapPopupFieldHandle).data.map_popup;
        const oldPivotMeasureField = this.pivotPopupFieldHandle && this.model.get(this.pivotPopupFieldHandle).data.pivot_popup;
        const result = await StandaloneFieldManagerMixin._onFieldChanged.apply(this, arguments);
        if (isMapChange) {
            this._changeMapPopupFields(ev, oldMapPopupField);
        } else if (isApprovalChange) {
            this._changeApprovalGroup(approvalField);
        } else if (isPivotChange) {
            this._changePivotMeasuresFields(ev, oldPivotMeasureField);
        } else {
            this._changeFieldGroup();
        }
        return result;
    },
    /**
     * Renames the field after confirmation from user.
     *
     * @private
     * @param {Event} ev
     */
    _onFieldNameChanged: function (ev) {
        var $input = $(ev.currentTarget);
        var attribute = $input.attr('name');
        if (!attribute) {
            return;
        }
        var newName = 'x_studio_' + $input.val().replace(/^_+/,"");
        var message;
        if (newName.match(/[^a-z0-9_]/g) || newName.length >= 54) {
            message = _.str.sprintf(_t('The new name can contain only a to z lower letters, numbers and _, with ' +
                'a maximum of 53 characters.'));
            Dialog.alert(this, message);
            return;
        }
        if (newName in this.fields) {
            message = _.str.sprintf(_t('A field with the same name already exists.'));
            Dialog.alert(this, message);
            return;
        }
        this.trigger_up('field_renamed', {
            oldName: this.state.node.attrs.name,
            newName: newName,
        });
    },
    /**
     * @private
     */
    _onFieldParameters: function () {
        this.trigger_up('open_field_form', {field_name: this.state.attrs.name});
    },
    /**
     * @private
     * @param {jQueryEvent} ev
     */
    _onOptionsChanged: function (ev) {
        var $input = $(ev.currentTarget);

        // We use the original `options` attribute on the node here and evaluate
        // it (same processing as in basic_view) ; we cannot directly take the
        // options dict because it usually has been modified in place in field
        // widgets (see Many2One @init for example).
        var nodeOptions = this.state.node.attrs.options;
        var newOptions = nodeOptions ? pyUtils.py_eval(nodeOptions) : {};
        var optionName = $input.attr('name');

        var optionValue;
        if ($input.attr('type') === 'checkbox') {
            optionValue = $input.is(':checked');

            if ((optionValue && $input.data('leave-empty') !== 'checked') ||
                (!optionValue && $input.data('leave-empty') !== 'unchecked')) {
                newOptions[optionName] = optionValue;
            } else {
                delete newOptions[optionName];
            }
        } else {
            optionValue = $input.val();
            try {
                // the value might have been stringified
                optionValue = JSON.parse(optionValue);
            } catch (e) {}

            newOptions[optionName] = optionValue;
        }

        this.trigger_up('view_change', {
            type: 'attributes',
            structure: 'edit_attributes',
            node: this.state.node,
            new_attrs: {
                options: JSON.stringify(newOptions),
            },
        });
    },
    /**
     * @private
     */
    _onRainbowImageReset: function () {
        this.$('input#rainbow_img_url').val('');
        this.$('input#rainbow_img_url').trigger('change');
    },
    /**
     * Called when the search input value is changed -> adapts the fields list
     *
     * @private
     */
    _onSearchInputChange: function () {
        this._searchValue = this.$('.o_web_studio_sidebar_search_input').val();
        this._isSearchValueActive = true;
        this._render();
    },
    /**
     * fold/unfold the 'existing fields' section.
     *
     * @private
     */
    _onClickExistingFieldHeader: function () {
        this._isExistingFieldFolded = !this._isExistingFieldFolded;
        this._updateExistingFieldSection();
    },
    /**
     * @private
     */
    _onRestoreDefaultView: function () {
        var self = this;
        var message = _t('Are you sure you want to restore the default view?\r\nAll customization done with Studio on this view will be lost.');

        Dialog.confirm(this, message, {
            confirm_callback: function () {
                self.trigger_up('view_change', {
                    structure: 'restore',
                });
            },
            dialogClass: 'o_web_studio_preserve_space'
        });
    },
    /**
     * @private
     * @param {Event} ev
     */
    _onSelectionValues: function (ev) {
        ev.preventDefault();
        this.trigger_up('field_edition', {
            node: this.state.node,
        });
    },
    /**
     * @private
     * @param {Event} ev
     */
    _onSetCover: function (ev) {
        var $input = $(ev.currentTarget);
        this.trigger_up('view_change', {
            node: this.state.node,
            structure: 'kanban_cover',
            type: $input.is(':checked') ? 'kanban_set_cover' : 'remove',
        });
        // If user closes the field selector pop up, check-box should remain unchecked.
        // Updated sidebar property will set this box to checked if the cover image
        // is enabled successfully.
        $input.prop("checked", false);
    },
    /**
     * @private
     * @param {Event} ev
     */
    _onShowInvisibleToggled: function (ev) {
        this.state.show_invisible = !!$(ev.currentTarget).is(":checked");
        this.trigger_up('toggle_form_invisible', {show_invisible : this.state.show_invisible});
    },
    /**
     * @private
     */
    _onTab: function (ev) {
        var mode = $(ev.currentTarget).attr('name');
        this.trigger_up('sidebar_tab_changed', {
            mode: mode,
        });
    },
    /**
     * @private
     */
    _onUploadRainbowImage: function () {
        var self = this;
        this.$('input.o_input_file').on('change', function () {
            self.$('form.o_form_binary_form').submit();
        });
        this.$('input.o_input_file').click();
    },
    /**
     * @private
     * @param {Event} event
     * @param {Object} result
     */
    _onUploadRainbowImageDone: function (event, result) {
        this.$('input#rainbow_img_url').val(_.str.sprintf('/web/content/%s', result.id));
        this.$('input#rainbow_img_url').trigger('change');
    },
    /**
     * @private
     * @param {string} attribute
     * @param {string} input
     * @param {Object} newAttrs
     */
    _onChangedGroupBys(attribute, input, newAttrs) {
        const options = {};
        if (!newAttrs.length || (['measure'].includes(attribute) && newAttrs.length === 1 && newAttrs[0] === '__count__') ||
            (['second_groupby', 'second_row_groupby'].includes(attribute) && newAttrs.length < 2)) {
            options.operationType = 'add';
            options.name = [input];
        } else if (newAttrs.length && input.length) {
            options.operationType = 'replace';
            options.oldname = ['second_groupby', 'second_row_groupby'].includes(attribute) ? newAttrs[1] : newAttrs[0];
            options.name = [input];
        } else {
            options.operationType = 'remove';
            options.name = ['second_groupby', 'second_row_groupby'].includes(attribute) ? [newAttrs[1]] : [newAttrs[0]];
        }
        return options;
    },
    /**
     * @private
     * @param {Event} ev
     */
    _onViewChanged: function (ev) {
        var $input = $(ev.currentTarget);
        var attribute = $input.attr('name');
        if (this.view_type === 'gantt' && _.str.include(attribute, 'precision_')) {
            // precision attribute in gantt is complicated to write so we split it
            var newPrecision = this.state.attrs.ganttPrecision;
            newPrecision[attribute.split('precision_')[1]] = $input.val();

            this.trigger_up('view_change', {
                type: 'attributes',
                structure: 'view_attribute',
                new_attrs: {
                    precision: JSON.stringify(newPrecision),
                },
            });
        } else if (this.view_type === 'list' && ['sort_field', 'sort_order'].includes(attribute)) {
            const new_attrs = {};
            if (attribute === 'sort_field' && !$input.val()) {
                this.$('#sort_order_div').addClass('d-none');
                if (!this.defaultOrder) return;
                new_attrs['default_order'] = '';
            } else {
                new_attrs ['default_order'] = this.$("#sort_field").val() + ' ' + this.$("#sort_order").val();
            }
            this.trigger_up('view_change', {
                type: 'attributes',
                structure: 'view_attribute',
                new_attrs: new_attrs,
            });
        } else if (this.view_type === 'map' && attribute === 'routing') {
            // Remove Sort By(default_order) value when routing is disabled
            const newAttrs = {};
            if ($input.is(':checked')) {
                newAttrs[attribute] = $input.data('leave-empty') === 'checked' ? '' : 'true';
            } else {
                newAttrs[attribute] = $input.data('leave-empty') === 'unchecked' ? '' : 'false';
                newAttrs['default_order'] = '';
            }
            this.trigger_up('view_change', {
                type: 'attributes',
                structure: 'view_attribute',
                new_attrs: newAttrs,
            });
        } else if (this.view_type === 'graph' && ['stacked', 'first_groupby', 'second_groupby', 'measure'].includes(attribute)) {
            if (attribute === 'stacked') {
                const newAttrs = {};
                newAttrs['stacked'] = attribute && $input.is(':checked') ? 'true' : 'False';
                this.trigger_up('view_change', {
                    type: 'attributes',
                    structure: 'view_attribute',
                    new_attrs: newAttrs,
                });
            } else {
                let options = {};
                options.type = $input.attr('type');
                options.viewType = this.view_type;
                if (attribute === 'first_groupby') {
                    const newoptions = this._onChangedGroupBys(attribute, $input.val(), this.state.attrs.groupBys);
                    options = {...options, ...newoptions};
                }
                if (attribute === 'second_groupby') {
                    const newoptions = this._onChangedGroupBys(attribute, $input.val(), this.state.attrs.groupBys);
                    options = {...options, ...newoptions};
                }
                if (attribute === 'measure') {
                    const newoptions = this._onChangedGroupBys(attribute, $input.val(), [this.state.attrs.measure]);
                    options = {...options, ...newoptions};
                }
                this.trigger_up('view_change', {
                    structure: 'graph_pivot_groupbys_fields',
                    options,
                });
            }
        } else if (this.view_type === 'pivot' && ['column_groupby', 'first_row_groupby', 'second_row_groupby'].includes(attribute)) {
            let options = {};
            options.type = $input.attr('type');
            options.viewType = this.view_type;
            if (attribute === 'column_groupby') {
                const newoptions = this._onChangedGroupBys(attribute, $input.val(), this.state.attrs.colGroupBys);
                options = {...options, ...newoptions};
            }
            if (attribute === 'first_row_groupby') {
                const newoptions = this._onChangedGroupBys(attribute, $input.val(), this.state.attrs.rowGroupBys);
                options = {...options, ...newoptions};
            }
            if (attribute === 'second_row_groupby') {
                const newoptions = this._onChangedGroupBys(attribute, $input.val(), this.state.attrs.rowGroupBys);
                options = {...options, ...newoptions};
            }
            this.trigger_up('view_change', {
                structure: 'graph_pivot_groupbys_fields',
                options,
            });
        } else if (attribute) {
            var new_attrs = {};
            if ($input.attr('type') === 'checkbox') {
                if (($input.is(':checked') && !$input.data('inverse')) || (!$input.is(':checked') && $input.data('inverse'))) {
                    new_attrs[attribute] = $input.data('leave-empty') === 'checked' ? '': 'true';
                } else {
                    new_attrs[attribute] = $input.data('leave-empty') === 'unchecked' ? '': 'false';
                }
            } else {
                new_attrs[attribute] = $input.val();
            }
            this.trigger_up('view_change', {
                type: 'attributes',
                structure: 'view_attribute',
                new_attrs: new_attrs,
            });
        }
    },
    /**
     * @private
     */
    _onViewParameters: function () {
        this.trigger_up('open_record_form_view');
    },
    /**
     * @private
     */
    _onXMLEditor: function () {
        this.trigger_up('open_xml_editor');
    },
});

});
;

/**********************************************************************************
*  Filepath: /web_studio/static/src/legacy/js/views/renderers/search_renderer.js  *
*  Bundle: web_studio.studio_assets                                               *
*  Lines: 222                                                                     *
**********************************************************************************/
odoo.define('web_studio.SearchRenderer', function (require) {
"use strict";

var config = require('web.config');
var core = require('web.core');
var utils = require('web.utils');
var Widget = require('web.Widget');

var qweb = core.qweb;


var SearchRenderer = Widget.extend({
    className: "o_search_view",

    /**
     * @constructor
     * @param {Object} fields_view
     * @param {Object} fields_view.arch
     * @param {Object} fields_view.fields
     * @param {String} fields_view.model
     */
    init: function (parent, fields_view) {
        this._super.apply(this, arguments);
        // see SearchView init
        fields_view = this._processFieldsView(_.clone(fields_view));
        this.arch = fields_view.arch;
        this.fields = fields_view.fields;
        this.model = fields_view.model;
    },
    /**
     * @override
     */
    start: function () {
        this.$el.addClass(this.arch.attrs.class);
        return this._super.apply(this, arguments).then(this._render.bind(this));
    },

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    /**
     * This is the reverse operation from getLocalState.  With this method, we
     * expect the renderer to restore all DOM state, if it is relevant.
     *
     * This method is called after each updateState, by the controller.
     * Needed here because the search widget is not a view anymore
     * in the web client but used as one in studio
     *
     * @see getLocalState
     * @param {any} localState the result of a call to getLocalState
     */
    setLocalState: function () {
    },
    /**
     * Returns any relevant state that the renderer might want to keep.
     *
     * The idea is that a renderer can be destroyed, then be replaced by another
     * one instantiated with the state from the model and the localState from
     * the renderer, and the end result should be the same.
     *
     * The kind of state that we expect the renderer to have is mostly DOM state
     * such as the scroll position, the currently active tab page, ...
     *
     * This method is called before each updateState, by the controller.
     *
     * @see setLocalState
     * @returns {any}
     */
    getLocalState: function () {
    },

    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------

    /**
     * Return nodes which can be displayed in search view for Studio.
     * This method is overridden in search_editor to admit invisible fields.
     *
     * @private
     * @returns {Array} the list of elements to display
     */
    _getNodesToTreat() {
        return this.arch.children.slice().filter(node => node.attrs.invisible !== "1");
    },
    /**
     * Processes a fieldsView in place. In particular, parses its arch.
     *
     * @todo: this function is also defined in SearchView and AbstractView ; the
     * code duplication could be removed once the SearchView will be rewritten.
     * @private
     * @param {Object} fv
     * @param {string} fv.arch
     * @returns {Object} the processed fieldsView
     */
    _processFieldsView: function (fv) {
        var doc = $.parseXML(fv.arch).documentElement;
        fv.arch = utils.xml_to_json(doc, true);
        return fv;
    },
    /**
     * Parse the arch to render each node.
     *
     * @private
     */
    _render: function () {
        var self = this;
        this.defs = [];
        this.$el.empty();
        this.$el.html(qweb.render('web_studio.searchRenderer', this.widget));
        this.first_field = undefined;
        this.first_filter = undefined;
        this.first_group_by = undefined;
        let nodesToTreat = this._getNodesToTreat();
        while (nodesToTreat.length) {
            var node = nodesToTreat.shift();
            if (node.tag === "field"){
                if (!self.first_field){
                    self.first_field = node;
                }
                self._renderField(node);
            } else if (node.tag === "filter") {
                if (/(['"])group_by\1\s*:/.test(node.attrs.context || '')) {
                    if (!self.first_group_by) {
                        self.first_group_by = node;
                    }
                    self._renderGroupBy(node);
                } else {
                    if (!self.first_filter) {
                        self.first_filter = node;
                    }
                    self._renderFilter(node);
                }
            } else if (node.tag === "separator") {
                if (!self.first_filter){
                    self.first_filter = node;
                }
                self._renderSeparator(node);
            } else if (node.tag === "group") {
                nodesToTreat = nodesToTreat.concat(node.children);
            }
        }
        return Promise.all(this.defs);
    },
    /**
     * @private
     * @param {Object} node
     *
     * @returns {jQueryElement}
     */
    _renderField: function (node) {
        var $tbody = this.$('.o_web_studio_search_autocompletion_fields tbody');
        var field_string = this.fields[node.attrs.name].string;
        var display_string = node.attrs.string || field_string;
        if (config.isDebug()) {
            display_string += ' (' + node.attrs.name +')';
        }
        var $new_row = $('<tr>').append(
            $('<td>').append(
            $('<span>').text(display_string)
        ));
        $tbody.append($new_row);
        return $new_row;
    },
    /**
     * @private
     * @param {Object} node
     *
     * @returns {jQueryElement}
     */
    _renderFilter: function (node) {
        var $tbody = this.$('.o_web_studio_search_filters tbody');
        var display_string = node.attrs.string || node.attrs.help;
        var $new_row = $('<tr>').append(
            $('<td>').append(
            $('<span>').text(display_string)
        ));
        $tbody.append($new_row);
        return $new_row;
    },
    /**
     * @private
     * @param {Object} node
     *
     * @returns {jQueryElement}
     */
    _renderGroupBy: function (node) {
        var $tbody = this.$('.o_web_studio_search_group_by tbody');
        // the domain is define like this:
        // context="{'group_by': 'field'}"
        // we use a regex to get the field string
        var display_string = node.attrs.string;
        var field_name = node.attrs.context.match(":.?'(.*)'")[1];
        if (config.isDebug()) {
            display_string += ' (' + field_name +')';
        }
        var $new_row = $('<tr>').append(
            $('<td>').append(
            $('<span>').text(display_string)
        ));
        $tbody.append($new_row);
        return $new_row;
    },
    /**
     * @private
     * @param {Object} node
     *
     * @returns {jQueryElement}
     */
    _renderSeparator: function () {
        var $tbody = this.$('.o_web_studio_search_filters tbody');
        var $new_row = $('<tr class="o_web_studio_separator">').html('<td><hr/></td>');

        $tbody.append($new_row);
        return $new_row;
    },
});

return SearchRenderer;

});
;

/*************************************************************************************
*  Filepath: /web_studio/static/src/legacy/js/views/renderers/list_renderer_lazy.js  *
*  Bundle: web_studio.studio_assets                                                  *
*  Lines: 20                                                                         *
*************************************************************************************/
odoo.define('web_studio.ListRendererLazy', function (require) {
"use_strict";

const ListRenderer = require('web.ListRenderer');

ListRenderer.include({
    /**
    * @override
    *
    * The point of this function is to disable the optional fields dropdown icon.
    */
    _onToggleOptionalColumnDropdown: function(ev) {
        const ctx = this.state.getContext();
        if (!ctx.studio) {
            this._super.apply(this, arguments);
        }
    },
});

});
;

/*************************************************************************************
*  Filepath: /web_studio/static/src/legacy/js/views/view_editors/calendar_editor.js  *
*  Bundle: web_studio.studio_assets                                                  *
*  Lines: 11                                                                         *
*************************************************************************************/
odoo.define('web_studio.CalendarEditor', function (require) {
"use strict";

var CalendarRenderer = require('web.CalendarRenderer');

var EditorMixin = require('web_studio.EditorMixin');

return CalendarRenderer.extend(EditorMixin, {
});

});
;

/**********************************************************************************
*  Filepath: /web_studio/static/src/legacy/js/views/view_editors/editor_mixin.js  *
*  Bundle: web_studio.studio_assets                                               *
*  Lines: 136                                                                     *
**********************************************************************************/
odoo.define('web_studio.EditorMixin', function() {
"use strict";

return {
    /**
     * Find and return the first node found in the view arch
     * satifying the given node description.
     * Breadth-first search.
     * @param {Object} viewArch
     * @param {Object} nodeDescription
     * @param {string} nodeDescription.tag
     * @param {Object} nodeDescription.attrs
     * @returns {Object}
     */
    findNode: function (viewArch, nodeDescription) {
        // TODO transparently check t-att- attributes ?
        // TODO support modifiers objects ?
        const nodesToCheck = [viewArch];
        while (nodesToCheck.length > 0) {
            const node = nodesToCheck.shift();
            const match = this._satisfiesNodeDescription(node, nodeDescription);
            if (match) return node;
            nodesToCheck.push(...(node.children || []));
        }
    },
    /**
     * Handles the drag and drop of a jQuery UI element.
     *
     * @param {JQuery} $drag
     * @param {Object} node
     * @param {string} position
     */
    handleDrop: function ($drag, node, position) {
        var isNew = $drag.hasClass('o_web_studio_component');
        var values;
        if (isNew) {
            values = {
                type: 'add',
                structure: $drag.data('structure'),
                field_description: $drag.data('field_description'),
                node: node,
                new_attrs: $drag.data('new_attrs'),
                position: position,
            };
        } else {
            var movedFieldName = $drag.data('name');
            if (node.attrs.name === movedFieldName) {
                // the field is dropped on itself
                return;
            }
            values = {
                type: 'move',
                node: node,
                position: position,
                structure: 'field',
                new_attrs: {
                    name: movedFieldName,
                },
            };
        }
        this.trigger_up('on_hook_selected');
        this.trigger_up('view_change', values);
    },
    /**
     * Highlight the nearest hook regarding the position and remove the
     * highlighto on other elements.
     *
     * @param {JQuery} $helper - the helper being dragged
     * @param {Object} position - {pageX: x, pageY: y}
     */
    highlightNearestHook: function ($helper, position) {
        this.$('.o_web_studio_nearest_hook').removeClass('o_web_studio_nearest_hook');
        // to be implemented by each editor
    },
    /*
     * Set the style and the corresponding event on a selectable node (fields,
     * groups, etc.) of the editor
     */
    setSelectable: function ($el) {
        var self = this;
        $el.click(function () {
            self.unselectedElements();
            $(this).addClass('o_web_studio_clicked');
        })
        .mouseover(function () {
            if (self.$('.ui-draggable-dragging').length) {
                return;
            }
            $(this).addClass('o_web_studio_hovered');
        })
        .mouseout(function () {
            $(this).removeClass('o_web_studio_hovered');
        });
    },
    unselectedElements: function () {
        this.selected_node_id = false;
        var $el = this.$('.o_web_studio_clicked');
        $el.removeClass('o_web_studio_clicked');
        if ($el.find('.blockUI')) {
            $el.find('.blockUI').parent().unblock();
        }
    },

    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------

    /**
     * Check if the node satifies the given node description
     * @param {Object} node
     * @param {Object} nodeDescription
     * @param {Object} nodeDescription.attrs
     * @param {string} nodeDescription.tag
     * @returns {boolean}
     */
    _satisfiesNodeDescription: function (node, nodeDescription) {
        const attrs = Object.assign({}, nodeDescription);
        const tag = attrs.tag;
        delete attrs.tag;
        const checkAttrs = Object.keys(attrs).length !== 0;
        if (tag && tag !== node.tag) return false;
        if (tag && !checkAttrs) return true;
        const match = (a1, a2) => typeof(a1) === 'string' ? a1.includes(a2) : a1 === a2;
        const matchedAttrs = Object
            .entries(attrs)
            .filter(([attr, value]) => match(node.attrs[attr], value))
            .map(([attr, value]) => attr);
        return matchedAttrs.length > 0 && matchedAttrs.length === Object.keys(attrs).length;
    },

    preprocessArch: function(arch) {
        return arch;
    },
};

});
;

/**************************************************************************************
*  Filepath: /web_studio/static/src/legacy/js/views/view_editors/editor_mixin_owl.js  *
*  Bundle: web_studio.studio_assets                                                   *
*  Lines: 14                                                                          *
**************************************************************************************/
odoo.define('web_studio.EditorMixinOwl', function (require) {
    "use strict";

    return Editor => class extends Editor {
        handleDrop() { }

        highlightNearestHook() { }

        setSelectable() { }

        unselectedElements() { }
    };

});
;

/****************************************************************************
*  Filepath: /web_studio/static/src/legacy/js/views/view_editors/fields.js  *
*  Bundle: web_studio.studio_assets                                         *
*  Lines: 29                                                                *
****************************************************************************/
odoo.define('web_studio.fields', function (require) {
"use strict";

var AbstractField = require('web.AbstractField');
var basic_fields = require('web.basic_fields');
var relational_fields = require('web.relational_fields');

var InputField = basic_fields.InputField;
var FieldText = basic_fields.FieldText;
var FieldMany2ManyTags = relational_fields.FieldMany2ManyTags;
var FieldMany2One = relational_fields.FieldMany2One;


AbstractField.include({
    has_placeholder: false,
});
InputField.include({
    has_placeholder: true,
});
FieldText.include({
    has_placeholder: true,
});
FieldMany2ManyTags.include({
    has_placeholder: true,
});
FieldMany2One.include({
    has_placeholder: true,
});
});
;

/*********************************************************************************
*  Filepath: /web_studio/static/src/legacy/js/views/view_editors/form_editor.js  *
*  Bundle: web_studio.studio_assets                                              *
*  Lines: 791                                                                    *
*********************************************************************************/
odoo.define('web_studio.FormEditor', function (require) {
"use strict";

const { getMessagingComponent } = require('@mail/utils/messaging_component');

var core = require('web.core');
var FormRenderer = require('web.FormRenderer');
var pyUtils = require('web.py_utils');

var EditorMixin = require('web_studio.EditorMixin');
var FieldSelectorDialog = require('web_studio.FieldSelectorDialog');
var FormEditorHook = require('web_studio.FormEditorHook');

var _t = core._t;

const { ComponentWrapper } = require('web.OwlCompatibility');

// ensure `.include()` on `mail_enterprise` is applied before `web_studio`
require('@mail_enterprise/widgets/form_renderer/form_renderer');

class ChatterContainerWrapperComponent extends ComponentWrapper {}

var FormEditor =  FormRenderer.extend(EditorMixin, {
    nearest_hook_tolerance: 50,
    className: FormRenderer.prototype.className + ' o_web_studio_form_view_editor',
    events: _.extend({}, FormRenderer.prototype.events, {
        'click .o_web_studio_add_chatter': '_onAddChatter',
    }),
    custom_events: _.extend({}, FormRenderer.prototype.custom_events, {
        'on_hook_selected': '_onSelectedHook',
    }),
    /**
     * @constructor
     * @param {Object} params
     * @param {Boolean} params.show_invisible
     * @param {Boolean} params.chatter_allowed
     */
    init: function (parent, state, params) {
        this._super.apply(this, arguments);
        this.show_invisible = params.show_invisible;
        this.renderInvisible = this.show_invisible;
        this.chatter_allowed = params.chatter_allowed;
        this._chatterNode = undefined;
        this._chatterContainerOverview = undefined;
        this.silent = false;
        this.node_id = 1;
        this.hook_nodes = {};
    },
    /**
     * @override
     */
    destroy() {
        this._super(...arguments);
        this._chatterContainerOverview = undefined;
    },

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    /**
     * @override
     */
    getLocalState: function () {
        var state = this._super.apply(this, arguments) || {};
        if (this.selected_node_id) {
            state.selected_node_id = this.selected_node_id;
        }
        return state;
    },
    /**
     * @override
     */
    highlightNearestHook: function ($helper, position) {
        var self = this;
        EditorMixin.highlightNearestHook.apply(this, arguments);

        var $nearest_form_hooks = this.$('.o_web_studio_hook')
            .touching({
                    x: position.pageX - this.nearest_hook_tolerance,
                    y: position.pageY - this.nearest_hook_tolerance,
                    w: this.nearest_hook_tolerance*2,
                    h: this.nearest_hook_tolerance*2
                },{
                    container: document.body
                }
            ).nearest({x: position.pageX, y: position.pageY}, {container: document.body});

        var is_nearest_hook = false;
        $nearest_form_hooks.each(function () {
            var hook_id = $(this).data('hook_id');
            var hook = self.hook_nodes[hook_id];
            if ($helper.data('structure') === 'notebook') {
                // a notebook cannot be placed inside a page or in a group
                if (hook.type !== 'page' && !$(this).parents('.o_group').length) {
                    is_nearest_hook = true;
                }
            } else if ($helper.data('structure') === 'group') {
                // a group cannot be placed inside a group
                if (hook.type !== 'insideGroup' && !$(this).parents('.o_group').length) {
                    is_nearest_hook = true;
                }
            } else {
                is_nearest_hook = true;
            }

            // Prevent drops outside of groups if not in whitelist
            var whitelist = ['o_web_studio_field_picture', 'o_web_studio_field_html',
                'o_web_studio_field_many2many', 'o_web_studio_field_one2many',
                'o_web_studio_field_tabs', 'o_web_studio_field_columns', 'o_web_studio_field_lines'];
            var hookTypeBlacklist = ['genericTag', 'afterGroup', 'afterNotebook', 'insideSheet'];
            var fieldClasses = $helper[0].className.split(' ');
            if (_.intersection(fieldClasses, whitelist).length === 0 && hookTypeBlacklist.indexOf(hook.type) > -1) {
                is_nearest_hook = false;
            }

            if (is_nearest_hook) {
                $(this).addClass('o_web_studio_nearest_hook');
                return false;
            }
        });

        return is_nearest_hook;
    },
    /**
     * @override
     */
    setLocalState: function (state) {
        this.silent = true;
        this._super.apply(this, arguments);
        this.silent = false;
        this.unselectedElements();
        if (state.selected_node_id) {
            var $selected_node = this.$('[data-node-id="' + state.selected_node_id + '"]');
            if ($selected_node) {
                $selected_node.click();
            }
        }
    },
    /**
     * Selects the field on view
     *
     * @param {string} fieldName
     */
    selectField: function (fieldName) {
        this.$('[name=' + fieldName + ']').click();
    },

    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------

    /**
     * Add Studio handler for button clicks; will parse the `effect` attribute
     * on the node to pre-populate the 'rainbow man' section with the current
     * settings for the button as well as the generic node clicked handler that
     * enable edition of the node in the sidebar.
     * @private
     * @param {Object} node
     * @param {jQueryElement} $button
     */
    _addButtonHandler: function (node, $button) {
        this.setSelectable($button);
        const nodeID = this.node_id++;
        $button.attr('data-node-id', nodeID);
        if (node.attrs.effect) {
            node.attrs.effect = _.defaults(pyUtils.py_eval(node.attrs.effect), {
                fadeout: 'medium'
            });
        }
        $button.click((event) => {
            event.preventDefault();
            event.stopPropagation();
            this.selected_node_id = nodeID;
            this.trigger_up('node_clicked', {node: node});
        });
        return $button;
    },

    /**
     * @override
     * @private
     */
    _applyModifiers: function (modifiersData, record, element) {
        var def = this._super.apply(this, arguments);

        if (this.show_invisible) {
            var elements = element ? [element] : modifiersData.elements;
            _.each(elements, function (element) {
                if (element.$el.hasClass('o_invisible_modifier')) {
                    element.$el
                        .removeClass('o_invisible_modifier')
                        .addClass('o_web_studio_show_invisible');
                }
            });
        }

        return def;
    },
    /**
     * @private
     * @param {MouseEvent} ev
     * @param {Object} ui
     */
    _handleDrop: function (ev, ui) {
        var $hook = this.$('.o_web_studio_nearest_hook');
        if ($hook.length) {
            var hook_id = $hook.data('hook_id');
            var hook = this.hook_nodes[hook_id];
            // draggable is only set on `droppable` elements, not `draggable`
            var $drag = ui.draggable || $(ev.target);
            this.handleDrop($drag, hook.node, hook.position);
            ui.helper.removeClass('ui-draggable-helper-ready');
            $hook.removeClass('o_web_studio_nearest_hook');
        }
    },
    /**
     * Override to always return false to get chatter always below form sheet.
     *
     * @override
     * @returns {Boolean}
     */
    _isChatterAside() {
        return false;
    },
    /**
     * @override
     * @private
     */
    _postProcessField: function (widget, node) {
        this._super.apply(this, arguments);
        // make empty widgets appear if there is no label
        if (!widget.isSet() && (!node.has_label || node.attrs.nolabel)) {
            widget.$el.removeClass('o_field_empty').addClass('o_web_studio_widget_empty');
            // statusbar needs to be rendered normally
            if (node.attrs.widget !== 'statusbar') {
                widget.$el.text(widget.string);
            }
        }
        // remove all events on the widget as we only want to click for edition
        widget.$el.off();
        this._processField(node, widget.$el);
    },
    /**
     * Process a field node, in particular, bind an click handler on $el to edit
     * its field attributes.
     *
     * @private
     * @param {Object} node
     * @param {JQuery} $el
     */
    _processField: function (node, $el) {
        var self = this;
        // detect presence of mail fields
        if (node.attrs.name === "message_ids") {
            this.has_message_field = true;
        } else if (node.attrs.name === "message_follower_ids") {
            this.has_follower_field = true;
        } else if (node.attrs.name === "activity_ids") {
            this.has_activity_field = true;
        } else {
            var modifiers = self._getEvaluatedModifiers(node, this.state);
            if (modifiers.invisible && !this.show_invisible) {
                return;
            }
            $el.attr('data-node-id', this.node_id++);
            this.setSelectable($el);
            $el.click(function (event) {
                event.preventDefault();
                event.stopPropagation();
                self.selected_node_id = $el.data('node-id');
                self.trigger_up('node_clicked', {node: node, $node:$el});
            });
        }
    },
    /**
     * @override
     * @private
     */
    _render: function () {
        var self = this;
        this.has_follower_field = false;
        this.has_message_field = false;
        this.has_activity_field = false;

        this.$el.droppable({
            accept: ".o_web_studio_component",
            drop: this._handleDrop.bind(this),
        });

        return this._super.apply(this, arguments).then(async function () {
            // Add chatter hook + chatter preview
            if (!self._hasChatter() && self.chatter_allowed) {
                var $chatter_hook = $('<div>').addClass('o_web_studio_add_chatter o_chatter');
                // Append non-hover content
                $chatter_hook.append($('<span>', {class: 'container'})
                    .append($('<span>', {
                        text: _t('Add Chatter Widget'),
                    }).prepend($('<i>', {
                        class: 'fa fa-comments',
                        style: 'margin-right:10px',
                    })))
                );
                const $studioChatterContainer = $('<div>').addClass('o_Studio_ChatterContainer');
                $chatter_hook.append($studioChatterContainer);
                // Append hover content (chatter preview)
                if (!self._chatterContainerOverview) {
                    self._chatterContainerOverview = new ChatterContainerWrapperComponent(
                        self,
                        getMessagingComponent('ChatterContainer'),
                        {
                            threadModel: self.state.model,
                        },
                    );
                }
                await self._chatterContainerOverview.mount($studioChatterContainer[0]);
                $chatter_hook.insertAfter(self.$('.o_form_sheet'));
            }
            // Add buttonbox hook
            if (!self.$('.oe_button_box').length) {
                var $buttonbox_hook = $('<button>')
                    .addClass('btn oe_stat_button o_web_studio_button_hook')
                    .click(function (event) {
                        event.preventDefault();
                        self.trigger_up('view_change', {
                            type: 'add',
                            add_buttonbox: true,
                            structure: 'button',
                        });
                    });
                var $buttonbox = $('<div>')
                    .addClass('oe_button_box')
                    .append($buttonbox_hook);
                self.$('.o_form_sheet').prepend($buttonbox);
            }
            // Add statusbar
            if (!self.$('.o_statusbar_status').length) {
                var $statusbar = $('<div>', {
                    text: _t("Add a pipeline status bar"),
                    class: 'o_web_studio_statusbar_hook',
                }).click(function () {
                    var values = {
                        add_statusbar: !self.$('.o_form_statusbar').length,
                        type: 'add',
                        structure: 'field',
                        field_description: {
                            field_description: "Pipeline status bar",
                            type: 'selection',
                            selection: [
                                ['status1', _t('First Status')],
                                ['status2', _t('Second Status')],
                                ['status3', _t('Third Status')],
                            ],
                            default_value: true,
                        },
                        target: {
                            tag: 'header',
                        },
                        new_attrs: {
                            widget: 'statusbar',
                            options: "{'clickable': '1'}",
                        },
                        position: 'inside',
                    };
                    self.trigger_up('view_change', values);
                });
                self.$('.o_form_sheet_bg').prepend($statusbar);
            }
            // Add avtar
            if (self.$('.oe_title').length & !self.$('.oe_title').siblings('.oe_avatar').length && !self.$('.oe_title > h1 > .oe_avatar').length) {
                const $avatar = $('<div>', {
                    text: _t("Add Picture"),
                    class: self.$('.oe_title > h1.d-flex.flex-row').length ? 'oe_avatar ml-3 p-3 o_web_studio_avatar h4': 'oe_avatar ml-3 mr-3 o_web_studio_avatar',
                }).click(function () {
                    const compatibleFields = _.pick(self.state.fields, function (e) {
                        return e.type === 'binary';
                    });
                    const dialog = new FieldSelectorDialog(self, compatibleFields, true).open();
                    dialog.on('confirm', self, function (field) {
                        self.trigger_up('view_change', {
                            structure: 'avatar_image',
                            field: field,
                        });
                    });
                });
                if (self.$('h1').hasClass('d-flex flex-row')) {
                    self.$('.oe_title > h1').append($avatar);
                } else {
                    self.$('.oe_title').before($avatar);
                }
            }
            // Apply 'text-muted' class on optional field dropdown
            self.$('i.o_optional_columns_dropdown_toggle')
                .addClass('text-muted')
        });
    },
    /**
     * @private
     * @returns {JQuery}
     */
    _renderAddingContentLine: function (node) {
        var formEditorHook = this._renderHook(node, 'after', 'tr');
         // start the widget
        return formEditorHook.appendTo($('<div>')).then(function() {
            return formEditorHook.$el;
        })
    },
    /**
     * @override
     * @private
     */
    _renderButtonBox: function () {
        var self = this;
        var $buttonbox = this._super.apply(this, arguments);
        var $buttonhook = $('<button>').addClass('btn oe_stat_button o_web_studio_button_hook');
        $buttonhook.click(function (event) {
            event.preventDefault();

            self.trigger_up('view_change', {
                type: 'add',
                structure: 'button',
            });
        });

        $buttonhook.prependTo($buttonbox);
        return $buttonbox;
    },
    /**
     * @override
     * @private
     */
    _renderGenericTag: function (node) {
        var $result = this._super.apply(this, arguments);
        if (node.attrs.class === 'oe_title') {
            var formEditorHook = this._renderHook(node, 'after', '', 'genericTag')
            this.defs.push(formEditorHook.appendTo($result));
        }
        return $result;
    },
    /**
     * @override
     * @private
     * @param {Object} node
     * @returns {jQueryElement}
     */
    _renderHeaderButton: function (node) {
        var self = this;
        var $button = this._super.apply(this, arguments);
        $button = this._addButtonHandler(node, $button);
        return $button;
    },
    /**
     * @override
     * @private
     *
     * FIXME wrong, studio has never been able to handle groups will col > 2...
     *
     */
    _renderInnerGroup: function (node) {
        var self = this;
        var formEditorHook;
        var $result = this._super.apply(this, arguments);
        _.each(node.children, function (child) {
            if (child.tag === 'field') {
                Promise.all(self.defs).then(function () {
                    var $widget = $result.find('[name="' + child.attrs.name + '"]');
                    var $tr = $widget.closest('tr');
                    if (!$widget.is('.o_invisible_modifier')) {
                        self._renderAddingContentLine(child).then(function(element) {
                            element.insertAfter($tr);
                            // apply to the entire <tr> o_web_studio_show_invisible
                            // rather then inner label/input
                            if ($widget.hasClass('o_web_studio_show_invisible')) {
                                $widget.removeClass('o_web_studio_show_invisible');
                                $tr.find('label[for="' + $widget.attr('id') + '"]').removeClass('o_web_studio_show_invisible');
                                $tr.addClass('o_web_studio_show_invisible');
                            }
                        });
                    }
                    if (child.has_label) {
                        // as it's not possible to move the label, we only allow to
                        // move fields with a default label (otherwise the field
                        // will be moved but the label will stay)
                        self._setDraggable(child, $tr);
                    }
                    self._processField(child, $tr);
                });
            }
        });
        const modifiers = this._getEvaluatedModifiers(node, this.state);
        if (!modifiers.invisible || this.show_invisible) {
            // Add click event to see group properties in sidebar
            $result.attr('data-node-id', this.node_id++);
            this.setSelectable($result);
            $result.click(function (event) {
                event.stopPropagation();
                self.selected_node_id = $result.data('node-id');
                self.trigger_up('node_clicked', { node: node });
            });
        }
        // Add hook for groups that have not yet content.
        if (!node.children.length) {
            formEditorHook = this._renderHook(node, 'inside', 'tr', 'insideGroup');
            this.defs.push(formEditorHook.appendTo($result));
        } else {
            // Add hook before the first node in a group.
            var $firstRow = $result.find('tr:first');
            formEditorHook = this._renderHook(node.children[0], 'before', 'tr');
            if (node.attrs.string) {
                // the group string is displayed in a tr
                this.defs.push(formEditorHook.insertAfter($firstRow));
            } else {
                this.defs.push(formEditorHook.insertBefore($firstRow));
            }
        }
        return $result;
    },

    /**
     * @override
     * @private
     */
    _renderInnerGroupField: function (node) {
        node.has_label = (node.attrs.nolabel !== "1");
        return this._super.apply(this, arguments);
    },
    /**
     * @override
     * @private
     */
    _renderNode: function (node) {
        var $el = this._super.apply(this, arguments);
        if (node.tag === 'div' && node.attrs.class === 'oe_chatter') {
            this._chatterNode = node;
        }
        return $el;
    },
    /**
     * @override
     * @private
     */
    _renderStatButton: function (node) {
        var self = this;
        var $button = this._super.apply(this, arguments);
        $button.attr('data-node-id', this.node_id++);
        this.setSelectable($button);
        $button.click(function (ev) {
            if (! $(ev.target).closest('.o_field_widget').length) {
                // click on the button and not on the field inside this button
                self.selected_node_id = $button.data('node-id');
                self.trigger_up('node_clicked', {node: node});
            }
        });
        return $button;
    },
    /**
     * @override
     * @private
     */
    _renderTabPage: function (node) {
        var $result = this._super.apply(this, arguments);
        // Add hook only for pages that have not yet outergroups.
        if (!$result.children('.o_group:not(.o_inner_group):last-child').length) {
            var formEditorHook = this._renderHook(node, 'inside', 'div', 'page');
            this.defs.push(formEditorHook.appendTo($result));
        }
        return $result;
    },
    /**
     * @override
     * @private
     */
    _renderOuterGroup: function (node) {
        var $result = this._super.apply(this, arguments);

        // Add hook after this group
        var formEditorHook = this._renderHook(node, 'after', '', 'afterGroup');
        this.defs.push(formEditorHook.insertAfter($result));
        return $result;
    },

    /**
     * @override
     * @private
     */
    _renderTagButton: function (node) {
        let $result = this._super.apply(this, arguments);
        $result = this._addButtonHandler(node, $result);
        return $result;
    },

    /**
     * @override
     * @private
     */
    _renderTagLabel: function (node) {
        var self = this;
        var $result = this._super.apply(this, arguments);

        // only handle label tags, not labels associated to fields (already
        // handled in @_renderInnerGroup with @_processField)
        if (node.tag === 'label') {
            $result.attr('data-node-id', this.node_id++);
            this.setSelectable($result);
            $result.click(function (event) {
                event.preventDefault();
                event.stopPropagation();
                self.selected_node_id = $result.data('node-id');
                self.trigger_up('node_clicked', {node: node});
            });
        }
        return $result;
    },
    /**
     * @override
     * @private
     */
    _renderTagNotebook: function (node) {
        var self = this;
        var $result = this._super.apply(this, arguments);

        var $addTag = $('<li>', {class: 'nav-item'}).append('<a href="#" class="nav-link"><i class="fa fa-plus-square"/></a>');
        $addTag.click(function (event) {
            event.preventDefault();
            event.stopPropagation();
            self.trigger_up('view_change', {
                type: 'add',
                structure: 'page',
                position: 'inside',
                node: node,
            });
        });
        $result.find('ul.nav-tabs').append($addTag);

        var formEditorHook = this._renderHook(node, 'after', '', 'afterNotebook');
        this.defs.push(formEditorHook.appendTo($result));

        // add node-id data on all tabs once whole notebook tabs are rendered
        // as registerModifiers of all tabs are called from _renderTagNotebook
        // so we need to evaluate modifiers here else we will not get modifiers
        Object.entries(node.children).forEach(([index, child]) => {
            const modifiers = this._getEvaluatedModifiers(child, this.state);
            if (!modifiers.invisible || this.show_invisible) {
                const $page = $result.find(`.nav-item:eq(${index})`);
                $page.attr('data-node-id', this.node_id++);
                this.setSelectable($page);
                $page.click(function (event) {
                    event.preventDefault();
                    if (!self.silent) {
                        self.selected_node_id = $page.data('node-id');
                        self.trigger_up('node_clicked', { node: child });
                    }
                });
            }
        });
        return $result;
    },
    /**
     * @override
     * @private
     */
    _renderTagSheet: function (node) {
        var $result = this._super.apply(this, arguments);
        var formEditorHook = this._renderHook(node, 'inside', '', 'insideSheet');
        this.defs.push(formEditorHook.prependTo($result));
        return $result;
    },
    /**
     * @override
     * @private
     */
    async _renderView() {
        await this._super(...arguments);
        if (this._hasChatter()) {
            const $el = $(this._chatterContainerComponent.el);
            this.setSelectable($el);
            // Put a div in overlay preventing all clicks chatter's elements
            $el.append($('<div>', { 'class': 'o_web_studio_overlay' }));
            $el.attr('data-node-id', this.node_id++);
            $el.click(() => {
                this.selected_node_id = $el.data('node-id');
                this.trigger_up('node_clicked', { node: this._chatterNode });
            });
        }
    },
    /**
     * @private
     * @param {Object} node
     * @param {String} position
     * @param {String} tagName
     * @param {String} type
     * @returns {Widget} FormEditorHook
     */
    _renderHook: function (node, position, tagName, type) {
        var hook_id = _.uniqueId();
        this.hook_nodes[hook_id] = {
            node: node,
            position: position,
            type: type,
        };
        return new FormEditorHook(this, position, hook_id, tagName);
    },
    /**
     * Set a jQuery element as draggable.
     * Note that we only set fields as draggable for now.
     *
     * @param {Object} node
     * @param {jQuery} $el
     */
    _setDraggable: function (node, $el) {
        var self = this;

        if ($el.is('tr')) {
            // *** HACK ***
            // jQuery.ui draggable cannot be set on a <tr> in Chrome because
            // position: relative has just no effect on a <tr> so we keep the
            // first <td> instead
            $el = $el.find('td:first');
        }

        $el.draggable({
            revertDuration: 200,
            refreshPositions: true,
            start: function (e, ui) {
                self.$('.o_web_studio_hovered').removeClass('o_web_studio_hovered');
                self.$('.o_web_studio_clicked').removeClass('o_web_studio_clicked');
                ui.helper.addClass('ui-draggable-helper');
                ui.helper.data('name', node.attrs.name);
            },
            revert: function () {
                // a field cannot be dropped on the same place
                var $hook = self.$('.o_web_studio_nearest_hook');
                if ($hook.length) {
                    var hook_id = $hook.data('hook_id');
                    var hook = self.hook_nodes[hook_id];
                    if (hook.node.attrs.name !== node.attrs.name) {
                        return false;
                    }
                }
                self.$('.ui-draggable-helper').removeClass('ui-draggable-helper');
                self.$('.ui-draggable-helper-ready').removeClass('ui-draggable-helper-ready');
                return true;
            },
            stop: this._handleDrop.bind(this),
        });

        // display nearest hook (handled by the ViewEditorManager)
        $el.on('drag', _.throttle(function (event, ui) {
            self.trigger_up('drag_component', {
                position: {pageX: event.pageX, pageY: event.pageY},
                $helper: ui.helper,
            });
        }, 200));
    },

    //--------------------------------------------------------------------------
    // Handlers
    //--------------------------------------------------------------------------

    /**
     * @private
     */
    _onAddChatter: function (ev) {
        // prevent multiple click
        $(ev.currentTarget).css('pointer-events', 'none');
        this.trigger_up('view_change', {
            structure: 'chatter',
            remove_follower_ids: this.has_follower_field,
            remove_message_ids: this.has_message_field,
            remove_activity_ids: this.has_activity_field,
        });
    },
    /**
     * @private
     */
    _onButtonBoxHook: function () {
        this.trigger_up('view_change', {
            structure: 'buttonbox',
        });
    },
    /**
     * @private
     */
    _onSelectedHook: function () {
        this.selected_node_id = false;
    },
});

return FormEditor;

});
;

/**************************************************************************************
*  Filepath: /web_studio/static/src/legacy/js/views/view_editors/form_editor_hook.js  *
*  Bundle: web_studio.studio_assets                                                   *
*  Lines: 56                                                                          *
**************************************************************************************/
odoo.define('web_studio.FormEditorHook', function (require) {
"use strict";

var Widget = require('web.Widget');

var FormEditorHook = Widget.extend({
    className: 'o_web_studio_hook',
    /**
     * @constructor
     * @param {Widget} parent
     * @param {String} position values: inside | after | before
     * @param {Integer} hook_id
     * @param {String} tagName values: generidTag | '' | tr | div
     */
    init: function (parent, position, hook_id, tagName) {
        this._super.apply(this, arguments);
        this.position = position;
        this.hook_id = hook_id;
        this.tagName = tagName || 'div';
    },
    /**
     * @override
     */
    start: function () {
        this.$el.data('hook_id', this.hook_id);

        var $content;
        switch (this.tagName) {
            case 'tr':
                $content = $('<td colspan="2">').append(this._renderSpan());
                break;
            default:
                $content = this._renderSpan();
                break;
        }
        this.$el.append($content);

        return this._super.apply(this, arguments);
    },

    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------

    /**
     * @private
     * @returns {JQuery}
     */
    _renderSpan: function () {
        return $('<span>').addClass('o_web_studio_hook_separator');
    },
});

return FormEditorHook;

});
;

/***********************************************************************************
*  Filepath: /web_studio/static/src/legacy/js/views/view_editors/kanban_editor.js  *
*  Bundle: web_studio.studio_assets                                                *
*  Lines: 170                                                                      *
***********************************************************************************/
odoo.define('web_studio.KanbanEditor', function (require) {
"use strict";

var BasicModel = require('web.BasicModel');
var KanbanRecordEditor = require('web_studio.KanbanRecordEditor');
var KanbanRenderer = require('web.KanbanRenderer');

var EditorMixin = require('web_studio.EditorMixin');

return KanbanRenderer.extend(EditorMixin, {
    className: KanbanRenderer.prototype.className + ' o_web_studio_kanban_view_editor',
    /**
     * @constructor
     * @param {Object} params
     * @param {boolean} params.show_invisible
     */
    init: function (parent, state, params) {
        this._super.apply(this, arguments);

        this.recordOptions.showInvisible = params.show_invisible;

        // We only want to display one record to ease the edition.
        // If grouped, render the record from only one of the groups that
        // contains records like if it was ungrouped (fallback on the first
        // group if all groups are empty).
        this.isGrouped = !!this.state.groupedBy.length;
        if (this.isGrouped) {
            state = _.find(this.state.data, function (group) {
                return group.count > 0;
            }) || this.state.data[0];
        }
        this.kanbanRecord = state && state.data[0];
    },
    /**
     * @override
     */
    willStart: function () {
        var self = this;
        return this._super.apply(this, arguments).then(function () {
            if (!self.kanbanRecord) {
                // add an empty record to be able to edit something
                var model = new BasicModel(self);
                return model.load({
                    fields: self.state.fields,
                    fieldsInfo: self.state.fieldsInfo,
                    modelName: self.state.model,
                    type: 'record',
                    viewType: self.state.viewType,
                }).then(function (record_id){
                    self.kanbanRecord = model.get(record_id);
                });
            }
        });
    },

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    /**
     * @override
     */
    highlightNearestHook: function ($helper, position) {
        if (this.recordEditor) {
            return this.recordEditor.highlightNearestHook($helper, position);
        }
    },
    /**
     * @override
     */
    getLocalState: function () {
        var state = this._super.apply(this, arguments) || {};
        if (this.recordEditor && this.recordEditor.selected_node_id) {
            state.selected_node_id = this.recordEditor.selected_node_id;
        }
        return state;
    },
    /**
     * @override
     */
    setLocalState: function (state) {
        if (this.recordEditor) {
            this.recordEditor.setLocalState(state);
        }
    },
    /**
     * @override
     */
    unselectedElements: function () {
        EditorMixin.unselectedElements.apply(this, arguments);
        if (this.recordEditor) {
            this.recordEditor.selected_node_id = false;
        }
    },

    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------

    /**
     * @private
     * @returns {Promise}
     */
    _render: function () {
        var self = this;
        var fragment = document.createDocumentFragment();
        this.defs = [];
        this._renderUngrouped(fragment);
        var defs = this.defs;
        delete this.defs;
        return Promise.all(defs).then(function () {
            self.$el.empty();
            self.$el.toggleClass('o_kanban_grouped', self.isGrouped);
            self.$el.toggleClass('o_kanban_ungrouped', !self.isGrouped);

            if (self.isGrouped) {
                var $group = $('<div>', {class: 'o_kanban_group'});
                $group.append(fragment);
                self.$el.append($group);

                // render a second empty column
                var fragment_empty = document.createDocumentFragment();
                self._renderDemoDivs(fragment_empty, 7);
                self._renderGhostDivs(fragment_empty, 6);
                var $group_empty = $('<div>', {class: 'o_kanban_group'});
                $group_empty.append(fragment_empty);
                self.$el.append($group_empty);
            } else {
                self.$el.append(fragment);
            }
        });

    },
    /**
     * Renders empty demo divs in a document fragment.
     *
     * @private
     * @param {DocumentFragment} fragment
     * @param {integer} nbDivs the number of divs to append
     */
    _renderDemoDivs: function (fragment, nbDivs) {
        for (var i = 0, demo_div; i < nbDivs; i++) {
            demo_div = $("<div>").addClass("o_kanban_record o_kanban_demo");
            demo_div.appendTo(fragment);
        }
    },
    /**
     * Override this method to only render one record and to use the
     * KanbanRecordEditor.
     *
     * @private
     * @param {DocumentFragment} fragment
     */
    _renderUngrouped: function (fragment) {
        var self = this;
        var isDashboard = this.$el.hasClass('o_kanban_dashboard');
        this.recordEditor = new KanbanRecordEditor(
            this, this.kanbanRecord, this.recordOptions, this.arch, isDashboard);
        this.widgets.push(this.recordEditor);
        this.defs.push(this.recordEditor.appendTo(fragment));

        Promise.all(this.defs).then(function () {
            // these divs need to be rendered after the kanban record
            self._renderDemoDivs(fragment, 6);
            self._renderGhostDivs(fragment, 6);
        });
    },
});

});
;

/******************************************************************************************
*  Filepath: /web_studio/static/src/legacy/js/views/view_editors/kanban_record_editor.js  *
*  Bundle: web_studio.studio_assets                                                       *
*  Lines: 446                                                                             *
******************************************************************************************/
odoo.define('web_studio.KanbanRecordEditor', function (require) {
"use strict";

var config = require('web.config');
var core = require('web.core');
var Dialog = require('web.Dialog');
var KanbanRecord = require('web.KanbanRecord');
var utils = require('web.utils');

var EditorMixin = require('web_studio.EditorMixin');
var FieldSelectorDialog = require('web_studio.FieldSelectorDialog');

var _t = core._t;
const qweb = core.qweb;

var KanbanRecordEditor = KanbanRecord.extend(EditorMixin, {
    nearest_hook_tolerance: 50,
    /**
     * @constructor
     * @param {Widget} parent
     * @param {Object} state
     * @param {Object} options
     * @param {Object} viewArch
     * @param {Boolean} is_dashboard
     */
    init: function (parent, state, options, viewArch, is_dashboard) {
        this._super.apply(this, arguments);
        this.node_id = 1;
        this.hook_nodes = [];
        this.viewArch = viewArch;
        this.is_dashboard = is_dashboard;
    },
    /**
     * @override
     * @private
     */
    _render: function () {
        var self = this;
        return this._super.apply(this, arguments).then(function () {
            // prevent the click on the record and remove the corresponding style
            self.$el.removeClass('oe_kanban_global_click oe_kanban_global_click_edit');

            // prevent the color dropdown to be displayed
            self.$('.o_dropdown_kanban > a')
                .removeAttr('data-toggle')
                .click(function (event) {
                    event.preventDefault();
                });

            self.$el.droppable({
                accept: ".o_web_studio_component",
                drop: function (event, ui) {
                    var $hook = self.$('.o_web_studio_nearest_hook');
                    if ($hook.length) {
                        var hook_id = $hook.data('hook_id');
                        var hook = self.hook_nodes[hook_id];

                        var values = {
                            type: 'add',
                            structure: ui.draggable.data('structure'),
                            field_description: ui.draggable.data('field_description'),
                            node: hook.node,
                            new_attrs: _.defaults(ui.draggable.data('new_attrs'), {
                                display: 'full',
                            }),
                            position: hook.position,
                        };
                        ui.helper.removeClass('ui-draggable-helper-ready');
                        self.trigger_up('on_hook_selected');
                        self.trigger_up('view_change', values);
                    }
                },
            });
        });
    },
    /**
     * @override
     */
    start: function () {
        this._undelegateEvents();
        this.$el.click(function (e) {
            e.stopPropagation();
            e.preventDefault();
        });
        return this._super.apply(this, arguments);
    },

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    /**
     * @override
     */
    highlightNearestHook: function ($helper, position) {
        EditorMixin.highlightNearestHook.apply(this, arguments);

        var $nearest_form_hook = this.$('.o_web_studio_hook')
            .touching({
                    x: position.pageX - this.nearest_hook_tolerance,
                    y: position.pageY - this.nearest_hook_tolerance,
                    w: this.nearest_hook_tolerance*2,
                    h: this.nearest_hook_tolerance*2
                },{
                    container: document.body
                }
            ).nearest({x: position.pageX, y: position.pageY}, {container: document.body}).eq(0);
        if ($nearest_form_hook.length) {
            $nearest_form_hook.addClass('o_web_studio_nearest_hook');
            return true;
        }
        return false;
    },
    /**
     * @override
     */
    setLocalState: function (state) {
        if (state.selected_node_id) {
            var $selected_node = this.$('[data-node-id="' + state.selected_node_id + '"]');
            if ($selected_node) {
                $selected_node.click();
            }
        }
    },

    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------

    /**
     * @private
     */
    _addSpecialHooks: function () {
        var self = this;

        // add the tags hook
        const tagsWidget =this.findNode(this.viewArch, {
            tag: 'field',
            widget: 'many2many_tags',
        });
        if (_.isUndefined(tagsWidget)) {
            var $kanban_tags_hook = $('<span>')
                .addClass('o_web_studio_add_kanban_tags')
                .append($('<span>', {
                    text: _t('Add tags'),
                }));
            let has_kanban_body = true;
            let $hook_attach_node = this.$el.find('.o_kanban_record_body');
            if ($hook_attach_node.length === 0) {
                $hook_attach_node = this.$el;
                has_kanban_body = false;
            }
            $kanban_tags_hook.prependTo($hook_attach_node);
            $kanban_tags_hook.click(function () {
                var compatible_fields = _.pick(self.state.fields, function (e) {
                    return e.type === 'many2many';
                });
                if (_.isEmpty(compatible_fields)) {
                    Dialog.alert(self, _t('You first need to create a many2many field in the form view.'));
                    return;
                }
                var dialog = new FieldSelectorDialog(self, compatible_fields, false);
                dialog.open();
                dialog.on('confirm', self, function (field_name) {
                    self.trigger_up('view_change', {
                        type: 'add',
                        structure: 'field',
                        new_attrs: { name: field_name },
                        node: {
                            tag: has_kanban_body?'div[hasclass("o_kanban_record_body")]':'div/*[1]',
                        },
                        position: 'inside',
                    });
                });
            });
        }

        // add the dropdown hook
        var $dropdown = this.$('.o_dropdown_kanban');
        if ($dropdown.length) {
            $dropdown.attr('data-node-id', this.node_id++);
            // find dropdown node from the arch
            var node = this.findNode(this.viewArch, {
                tag: 'div',
                class: 'o_dropdown_kanban',
            });
            // bind handler on dropdown clicked to be able to remove it
            this.setSelectable($dropdown);
            $dropdown.click(function () {
                self.selected_node_id = $dropdown.data('node-id');
                self.trigger_up('node_clicked', {
                    node: node,
                    $node: $dropdown,
                });
            });
        } else {
            var $top_left_hook = $('<div>')
                .addClass('o_web_studio_add_dropdown o_dropdown_kanban dropdown')
                .append($('<a>', {
                    class: 'dropdown-toggle o-no-caret btn',
                    'data-toggle': 'dropdown',
                    href: '#',
                }).append($('<span>', {
                    class: 'fa fa-ellipsis-v',
                })));
            $top_left_hook.prependTo(this.$el);
            $top_left_hook.click(function () {
                Dialog.confirm(self, _t("Do you want to add a dropdown with colors?"), {
                    size: 'small',
                    confirm_callback: function () {
                        self.trigger_up('view_change', {
                            structure: 'kanban_dropdown',
                        });
                    },
                });
            });
        }

        // add the priority hook
        var priorityWidget = this.findNode(this.viewArch, {
            tag: 'field',
            widget: 'priority',
        });
        const favoriteWidget =this.findNode(this.viewArch, {
            tag: 'field',
            widget: 'boolean_favorite',
        });
        if (_.isUndefined(priorityWidget) && _.isUndefined(favoriteWidget)) {
            var $priority_hook = $('<div>')
                .addClass('o_web_studio_add_priority oe_kanban_bottom_left')
                .append($('<span>', {
                    text: _t('Add a priority'),
                }));
            $priority_hook.appendTo(this.$el);
            $priority_hook.click(function () {
                var compatible_fields = _.pick(self.state.fields, function (e) {
                    return e.type === 'selection';
                });
                var dialog = new FieldSelectorDialog(self, compatible_fields, true).open();
                dialog.on('confirm', self, function (field) {
                    self.trigger_up('view_change', {
                        structure: 'kanban_priority',
                        field: field,
                    });
                });
            });
        }

        // add the avatar hook
        const avatarNode = this.findNode(this.viewArch, {
                tag: 'img',
                class: 'oe_kanban_avatar',
            }
        );
        let $hook_attach_node = this.$el.find('.o_kanban_record_bottom');
        if ($hook_attach_node.length === 0) {
            $hook_attach_node = this.$el;
        }
        var $image = this.$('img.oe_kanban_avatar');
        if (avatarNode) {
            if (!$image.length) {
                $image = $(qweb.render('web_studio.AvatarPlaceholder'));
                $image.appendTo($hook_attach_node);
            }
            $image.attr('data-node-id', this.node_id++);
            // bind handler on image clicked to be able to remove it
            this.setSelectable($image);
            $image.click(function () {
                self.selected_node_id = $image.data('node-id');
                self.trigger_up('node_clicked', {
                    node: avatarNode,
                    $node: $image,
                });
            });
        } else {
            var $kanban_image_hook = $('<div>')
                .addClass('o_web_studio_add_kanban_image oe_kanban_bottom_right')
                .append($('<span>', {
                    text: _t('Add an avatar'),
                }));
            $kanban_image_hook.appendTo($hook_attach_node);
            $kanban_image_hook.click(function () {
                var compatible_fields = _.pick(self.state.fields, function (e) {
                    return e.type === 'many2one' && (e.relation === 'res.partner' || e.relation === 'res.users');
                });
                if (_.isEmpty(compatible_fields)) {
                    Dialog.alert(self, _t('You first need to create a many2one field to Partner or User in the form view.'));
                    return;
                }
                var dialog = new FieldSelectorDialog(self, compatible_fields, false).open();
                dialog.on('confirm', self, function (field) {
                    self.trigger_up('view_change', {
                        structure: 'kanban_image',
                        field: field,
                    });
                });
            });
        }
    },
    /**
     * @private
     * @param {jQueryElement} $node
     * @param {String} fieldName
     */
    _bindHandler: function ($node, fieldName) {
        var self = this;

        var node = {
            tag: 'field',
            attrs: { name: fieldName }
        };

        this.setSelectable($node);
        $node.click(function (ev) {
            ev.preventDefault();
            ev.stopPropagation();
            self.selected_node_id = $node.data('node-id');
            self.trigger_up('node_clicked', {
                node: node,
                $node: $node,
            });
        });

        // insert a hook to add new fields
        var $hook = this._renderHook(node);
        $hook.insertAfter($node);

        var invisibleModifier = this.fieldsInfo[fieldName].modifiers.invisible;
        if (invisibleModifier && this._computeDomain(invisibleModifier)) {
            $node.addClass('o_web_studio_show_invisible');
        }
    },
    /**
     * @private
     * @param {any} value
     * @returns {Boolean}
     */
    _isEmpty: function (value) {
        if (typeof(value) === 'object') {
            return _.isEmpty(value);
        } else {
            return !value && value !== 0;
        }
    },
    /**
     * @override
     */
    _processFields: function () {
        this._super.apply(this, arguments);

        // the layout of the special hooks are broken in the kanban dashboards
        if (!this.is_dashboard) {
            this._addSpecialHooks();
        }
    },
    /**
     * @override
     */
    _processField: function ($field, field_name) {
        $field = this._super.apply(this, arguments);

        var field = this.record[field_name];
        // make empty widgets appear
        if (this._isEmpty(field.value)) {
            $field.text(field.string);
            $field.addClass('o_web_studio_widget_empty');
        }
        $field.attr('data-node-id', this.node_id++);

        // bind handler on field clicked to edit field's attributes
        this._bindHandler($field, field_name);

        var invisibleModifier = this.fieldsInfo[field_name].modifiers.invisible;
        if (invisibleModifier && this._computeDomain(invisibleModifier)) {
            $field.addClass('o_web_studio_show_invisible');
        }

        return $field;
    },
    /**
     * @override
     */
    _processWidget: function ($field, field_name) {
        var self = this;
        // '_processWidget' in KanbanRecord adds a promise to this.defs only if
        // the widget is async. Here, we need to hook on this def to access the
        // widget's $el (it doesn't exist until the def is resolved). As calling
        // '_super' may or may not push a promise in this.defs, we store the
        // length of this.defs as index before calling '_super'. Note that if
        // it doesn't push a promise, this.defs[currentDefIndex] is undefined.
        // FIXME: get rid of this hack in master with a small refactoring
        var currentDefIndex = this.defs.length;
        var widget = this._super.apply(this, arguments);
        Promise.resolve(this.defs[currentDefIndex]).then(function () {
            widget.$el.off();

            // make empty widgets appear
            if (self._isEmpty(widget.value)) {
                widget.$el.addClass('o_web_studio_widget_empty');
                widget.$el.text(widget.string);
            }
            widget.$el.attr('data-node-id', self.node_id++);

            // bind handler on field clicked to edit field's attributes
            self._bindHandler(widget.$el, field_name);
        });

        return widget;
    },
    /**
     * @private
     * @param {Object} node
     * @returns {JQuery}
     */
    _renderHook: function (node) {
        var hook_id = _.uniqueId();
        this.hook_nodes[hook_id] = {
            node: node,
            position: 'after',
        };
        var $hook = $('<span>', {
            class: 'o_web_studio_hook',
            data: {
                hook_id: hook_id,
            }
        });
        return $hook;
    },
    /**
     * @override
     */
    _setState: function () {
        this._super.apply(this, arguments);

        if (this.options.showInvisible) {
            this.qweb_context.kanban_compute_domain = function () {
                // always consider a domain falsy to see invisible elements
                return false;
            };
        }
    },
});

return KanbanRecordEditor;

});
;

/*********************************************************************************
*  Filepath: /web_studio/static/src/legacy/js/views/view_editors/list_editor.js  *
*  Bundle: web_studio.studio_assets                                              *
*  Lines: 438                                                                    *
*********************************************************************************/
odoo.define('web_studio.ListEditor', function (require) {
"use strict";

var ListRenderer = require('web.ListRenderer');
var EditorMixin = require('web_studio.EditorMixin');

return ListRenderer.extend(EditorMixin, {
    nearest_hook_tolerance: 200,
    className: ListRenderer.prototype.className + ' o_web_studio_list_view_editor',
    events: _.extend({}, ListRenderer.prototype.events, {
        'click th:not(.o_web_studio_hook), td:not(.o_web_studio_hook)': '_onExistingColumn',
    }),
    custom_events: _.extend({}, ListRenderer.prototype.custom_events, {
        'on_hook_selected': '_onSelectedHook',
    }),
    /**
     * @constructor
     */
    init: function (parent, state, params) {
        this._super.apply(this, arguments);
        this.show_invisible = params.show_invisible;
        this.node_id = 1;
    },
    /**
     * Columns visibility is computed in the willStart of the list renderer.
     * Here, we override the result of this computation to force the visibility
     * of otherwise invisible columns so that they can be properly edited.
     *
     * @override
     */
    willStart: function () {
        var self = this;
        return this._super.apply(this, arguments).then(function () {
            if (self.show_invisible) {
                var validChildren = _.filter(self.arch.children, function (child) {
                    // Editing controls is not supported in studio
                    return child.tag !== 'control' && child.tag !== 'header';
                });
                self.invisible_columns = _.difference(validChildren, self.columns);
                self.columns = validChildren;
            } else {
                self.invisible_columns = [];
            }
        });
    },

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    /**
     * @override
     */
    getLocalState: function() {
        var state = this._super.apply(this, arguments) || {};
        if (this.selected_node_id) {
            state.selected_node_id = this.selected_node_id;
        }
        return state;
    },
    /**
     * @override
     */
    highlightNearestHook: function ($helper, position) {
        EditorMixin.highlightNearestHook.apply(this, arguments);

        var $nearest_list_hook = this.$('.o_web_studio_hook')
            .touching({
                    x: position.pageX - this.nearest_hook_tolerance,
                    y: position.pageY - this.nearest_hook_tolerance,
                    w: this.nearest_hook_tolerance*2,
                    h: this.nearest_hook_tolerance*2
                },{
                    container: document.body
                }
            ).nearest({x: position.pageX, y: position.pageY}, {container: document.body}).eq(0);
        if ($nearest_list_hook.length) {
            var $elements = this._getColumnElements($nearest_list_hook);
            $elements.addClass('o_web_studio_nearest_hook');
            return true;
        }
        return false;
    },
    /**
     * @override
     */
    setLocalState: function(state) {
        if (state.selected_node_id) {
            var $selected_node = this.$('th[data-node-id="' + state.selected_node_id + '"]');
            if ($selected_node) {
                $selected_node.click();
            }
        }
    },
    /**
     * In the list editor, we want to select the whole column, not only a single
     * cell.
     *
     * @override
     */
    setSelectable: function ($el) {
        EditorMixin.setSelectable.apply(this, arguments);

        var self = this;
        $el.click(function (ev) {
            var $target = $(ev.currentTarget);
            self.$('.o_web_studio_clicked').removeClass('o_web_studio_clicked');
            var $elements = self._getColumnElements($target);
            $elements.addClass('o_web_studio_clicked');
        })
        .mouseover(function (ev) {
            if (self.$('.ui-draggable-dragging').length) {
                return;
            }
            var $target = $(ev.currentTarget);
            var $elements = self._getColumnElements($target);
            $elements.addClass('o_web_studio_hovered');
        })
        .mouseout(function () {
            self.$('.o_web_studio_hovered').removeClass('o_web_studio_hovered');
        });
    },
    /**
     * Selects the field on view
     *
     * @param {string} fieldName
     */
    selectField: function (fieldName) {
        this.$('th[data-name=' + fieldName + ']').click();
    },

    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------

    /**
     * @private
     * @param {MouseEvent} ev
     * @param {Object} ui
     */
    _handleDrop: function (ev, ui) {
        var $hook = this.$('.o_web_studio_nearest_hook');
        if ($hook.length) {
            var position = $hook.closest('table').find('th').eq($hook.index()).data('position') || 'after';
            var hookedFieldIndex = position === 'before' && $hook.index() + 1 || $hook.index() - 1;
            var fieldName = $hook.closest('table').find('th').eq(hookedFieldIndex).data('name');
            var node = _.find(this.columns, function (column) {
                return column.attrs.name === fieldName;
            });
            if (fieldName.startsWith('button_group')) {
                if (position === 'after') {
                    node = node.children[node.children.length - 1];
                } else if (position === 'before') {
                    node = node.children[0];
                }
            }
            // When there is no column in the list view, the only possible hook is inside <tree>
            if (!this.columns.length) {
                node = {
                   tag: 'tree',
               };
               position = 'inside';
            }
            // draggable is only set on `droppable` elements, not `draggable`
            var $drag = ui.draggable || $(ev.target);
            this.handleDrop($drag, node, position);
            ui.helper.removeClass('ui-draggable-helper-ready');
            $hook.removeClass('o_web_studio_nearest_hook');
        }
    },
    /**
     * Get all elements associated to a table column.
     *
     * @private
     * @param {jQuery} $target
     * @returns {jQuery}
     */
    _getColumnElements: function ($target) {
        return $target.closest('table')
            .find('tr')
            .children(':nth-child(' + ($target.index() + 1) + ')');
    },
    /**
     * Add totalWidth of columns + hook cells going to add
     *
     * @override
     * @private
     * @return {integer}
     */
    _getColumnsTotalWidth() {
        const thElementsLength = this.el.querySelectorAll('thead th').length + 1;
        return this._super(...arguments) + thElementsLength;
    },
    /**
     * @override
     * @private
     */
    _render: function () {
        var self = this;
        var prom = this._super.apply(this, arguments);
        prom.then(function () {
            self.$el.droppable({
                accept: ".o_web_studio_component",
                drop: self._handleDrop.bind(self),
            });

            self.setSelectable(self.$('th, td').not('.o_web_studio_hook'));
            // Apply 'text-muted' class on optional field dropdown
            self.$('i.o_optional_columns_dropdown_toggle')
                .addClass('text-muted')
        });
        return prom;
    },
    /**
     * @override
     * @private
     */
    _renderBody: function () {
        // we don't want to be able to resequence in the editor
        this.hasHandle = false;
        return this._super();
    },
    /**
     * @override
     * @private
     * @param {Object} record
     * @param {Object} node
     * @param {...any} args
     * @return {jQueryElement}
     */
    _renderBodyCell(record, node, ...args) {
        const $td = this._super(record, node, ...args);
        const invisibleTechnicalNames = this.invisible_columns.map(column => column.attrs.name);
        if (invisibleTechnicalNames.includes(node.attrs.name)) {
            $td.addClass('o_web_studio_show_invisible');
        }
        return $td;
    },
    /**
     * @override
     * @private
     */
    _renderHeader: function () {
        var $header = this._super.apply(this, arguments);
        var self = this;
        // Insert a hook after each th
        _.each($header.find('th'), function (th) {
            var $new_th = $('<th>')
                .addClass('o_web_studio_hook')
                .append(
                    $('<i>').addClass('fa fa-plus')
            );
            $new_th.insertAfter($(th));
            $(th).attr('data-node-id', self.node_id++);

            self._setDraggable($(th));
        });

        // Insert a hook before the first column
        var $new_th_before = $('<th>')
            .addClass('o_web_studio_hook')
            .data('position', 'before')
            .append(
                $('<i>').addClass('fa fa-plus')
        );
        $new_th_before.prependTo($header.find('tr'));
        return $header;
    },
    /**
     * @override
     * @private
     */
    _renderHeaderCell: function (node) {
        var $th = this._super.apply(this, arguments);
        if (_.contains(this.invisible_columns, node)) {
            $th.addClass('o_web_studio_show_invisible');
        }
        return $th;
    },
    /**
     * @override
     * @private
     */
    _renderEmptyRow: function () {
        // render an empty row
        var $tds = [];
         _.each(this.columns, function () {
            $tds.push($('<td>&nbsp;</td>'));
        });
        if (this.has_selectors) {
            $tds.push($('<td>&nbsp;</td>'));
        }
        var $row = $('<tr>').append($tds);

        this._addStudioHooksOnBodyRow($row);

        return $row;
    },
    /**
     * Adds studio hooks for a row in a list right after their rendering
     * Since rows of thead and tfoot have special behaviors and classes
     * this function should only be used for rows in the body of the table
     * @param {JQuery} $row
     */
    _addStudioHooksOnBodyRow: function ($row) {
        // Insert a hook after each cell
        _.each($row.find('td, th'), function (cell) {
            $('<td>')
                .addClass('o_web_studio_hook')
                .insertAfter($(cell));
        });

        // Insert a hook before the first column
        $('<td>')
            .addClass('o_web_studio_hook')
            .prependTo($row);
    },
    /**
     * @override
     * @private
     */
    _renderRow: function () {
        var $row = this._super.apply(this, arguments);
        this._addStudioHooksOnBodyRow($row);

        return $row;
    },
    /**
     * @override
     * @private
     */
    _renderFooter: function () {
        var $footer = this._super.apply(this, arguments);

        // Insert a hook after each td
        _.each($footer.find('td'), function (td) {
            $('<td>')
                .addClass('o_web_studio_hook')
                .insertAfter($(td));
        });

        // Insert a hook before the first column
        $('<td>')
            .addClass('o_web_studio_hook')
            .prependTo($footer.find('tr'));

        return $footer;
    },
    /**
     * Set a jQuery element as draggable.
     * Note that we only set fields as draggable for now.
     *
     * @param {jQuery} $el
     */
    _setDraggable: function ($el) {
        var self = this;

        $el.draggable({
            axis: 'x',
            scroll: false,
            revertDuration: 200,
            refreshPositions: true,
            start: function (e, ui) {
                self.$('.o_web_studio_hovered').removeClass('o_web_studio_hovered');
                self.$('.o_web_studio_clicked').removeClass('o_web_studio_clicked');
                ui.helper.addClass('ui-draggable-helper');
            },
            stop: this._handleDrop.bind(this),
            revert: function () {
                // a field cannot be dropped on the same place
                var $hook = self.$('.o_web_studio_nearest_hook');
                if ($hook.length) {
                    var position = $hook.closest('table').find('th').eq($hook.index()).data('position') || 'after';
                    var hookedFieldIndex = position === 'before' && $hook.index() + 1 || $hook.index() - 1;
                    var fieldName = $hook.closest('table').find('th').eq(hookedFieldIndex).data('name');
                    if (fieldName !== self.$('.ui-draggable-helper').data('name')) {
                        return false;
                    }
                }
                self.$('.ui-draggable-helper').removeClass('ui-draggable-helper');
                self.$('.ui-draggable-helper-ready').removeClass('ui-draggable-helper-ready');
                return true;
            },
        });

        // display nearest hook (handled by the ViewEditorManager)
        $el.on('drag', _.throttle(function (event, ui) {
            self.trigger_up('drag_component', {
                position: {pageX: event.pageX, pageY: event.pageY},
                $helper: ui.helper,
            });
        }, 200));
    },

    //--------------------------------------------------------------------------
    // Handlers
    //--------------------------------------------------------------------------

    /**
     * @private
     * @param {Event} ev
     */
    _onExistingColumn: function (ev) {
        var $el = $(ev.currentTarget);
        var $selected_column = $el.closest('table').find('th').eq($el.index());

        var field_name = $selected_column.data('name');
        var node = _.find(this.columns, function (column) {
            return column.attrs.name === field_name;
        });
        this.selected_node_id = $selected_column.data('node-id');
        this.trigger_up('node_clicked', {node: node});
    },
    /**
     * @private
     */
    _onSelectedHook: function () {
        this.selected_node_id = false;
    },

    /**
     * Undo the ListRenderer._groupAdjacentButtons() operation
     */
    preprocessArch: function (arch) {
        if (!arch.children) return arch;
        const children = [];
        for (let child of arch.children) {
            if (child.tag !== 'button_group') {
                children.push(child);
            } else {
                children.push(...child.children);
            }
        }
        return {...arch, children};
    },
});

});
;

/******************************************************************************************
*  Filepath: /web_studio/static/src/legacy/js/views/view_editors/new_buttonbox_dialog.js  *
*  Bundle: web_studio.studio_assets                                                       *
*  Lines: 114                                                                             *
******************************************************************************************/
odoo.define('web_studio.NewButtonBoxDialog', function (require) {
"use strict";

var core = require('web.core');
var Dialog = require('web.Dialog');
var relational_fields = require('web.relational_fields');

var StandaloneFieldManagerMixin = require('web.StandaloneFieldManagerMixin');
var utils = require('web_studio.utils');

var Many2one = relational_fields.FieldMany2One;
var _t = core._t;

var NewButtonBoxDialog = Dialog.extend(StandaloneFieldManagerMixin, {
    template: 'web_studio.NewButtonBoxDialog',
    events: {
        'click .o_web_studio_icon_selector': '_on_IconSelector',
    },
    /**
     * @override
     */
    init: function (parent, model_name) {
        this.model_name = model_name;
        this.ICONS = utils.ICONS;

        var options = {
            title: _t('Add a Button'),
            size: 'small',
            buttons: [{
                text: _t("Confirm"),
                classes: 'btn-primary',
                click: this._onConfirm.bind(this)
            }, {
                text: _t("Cancel"),
                close: true
            }],
        };

        this._super(parent, options);
        StandaloneFieldManagerMixin.init.call(this);

        var self = this;
        this.opened().then(function () {
            // focus on input
            self.$el.find('input[name="string"]').focus();
        });
    },
    /**
     * @override
     */
    start: function () {
        var self = this;
        var defs = [];
        defs.push(this._super.apply(this, arguments));
        defs.push(this.model.makeRecord('ir.actions.act_window', [{
            name: 'field',
            relation: 'ir.model.fields',
            type: 'many2one',
            domain: [['relation', '=', this.model_name], ['ttype', 'in', ['many2one', 'many2many']], ['store', '=', true]],
        }]).then(function (recordID) {
            var options = {
                mode: 'edit',
                attrs: {
                    can_create: false,
                    can_write: false,
                },
            };
            var record = self.model.get(recordID);
            self.many2one = new Many2one(self, 'field', record, options);
            self._registerWidget(recordID, 'field', self.many2one);
            self.many2one.appendTo(self.$('.js_many2one_field'));
        }));
        return Promise.all(defs);
    },

    //--------------------------------------------------------------------------
    // Handlers
    //--------------------------------------------------------------------------

    /**
     * @private
     */
    _onConfirm: function () {
        var string = this.$('input[name="string"]').val() || 'New Button';
        var icon = this.selected_icon || this.ICONS[0].split(' ')[1];
        var field_id = this.many2one.value && this.many2one.value.res_id;
        if (!field_id) {
            Dialog.alert(this, _t('Select a related field.'));
            return;
        }
        this.trigger('saved', {
            string: string,
            field_id: field_id,
            icon: icon,
        });
        this.close();
    },
    /**
     * @private
     * @param {Event} ev
     */
    _on_IconSelector: function (ev) {
        var $el = $(ev.currentTarget);
        this.$('.o_selected').removeClass('o_selected');
        $el.addClass('o_selected');
        var icon = $(ev.currentTarget).data('value');
        // only takes `fa-...` instead of `fa fa-...`
        this.selected_icon = icon && icon.split(' ')[1];
    },
});

return NewButtonBoxDialog;

});
;

/***********************************************************************************
*  Filepath: /web_studio/static/src/legacy/js/views/view_editors/search_editor.js  *
*  Bundle: web_studio.studio_assets                                                *
*  Lines: 422                                                                      *
***********************************************************************************/
odoo.define('web_studio.SearchEditor', function (require) {
"use strict";

var config = require('web.config');
const core = require('web.core');
var Domain = require('web.Domain');
var DomainSelectorDialog = require("web.DomainSelectorDialog");

var EditorMixin = require('web_studio.EditorMixin');
var FormEditorHook = require('web_studio.FormEditorHook');
var SearchRenderer = require('web_studio.SearchRenderer');
var utils = require('web_studio.utils');

const _t = core._t;

var SearchEditor = SearchRenderer.extend(EditorMixin, {
    nearest_hook_tolerance: 50,
    className: SearchRenderer.prototype.className + ' o_web_studio_search_view_editor',
    custom_events: _.extend({}, SearchRenderer.prototype.custom_events, {
        'on_hook_selected': function () {
            this.selected_node_id = false;
        },
    }),
    /**
     * @constructor
     */
    init: function (parent, state, params) {
        this._super.apply(this, arguments);
        this.hook_nodes = {};
        this.node_id = 1;
        this.show_invisible = params.show_invisible;
        this.FILTER_TYPES = ['date', 'datetime'];
        this.GROUPABLE_TYPES = ['many2one', 'many2many', 'char', 'boolean', 'selection', 'date', 'datetime'];
    },

    //--------------------------------------------------------------------------
    // Public
    //--------------------------------------------------------------------------

    /**
     * @override
     */
    getLocalState: function () {
        var state = this._super.apply(this, arguments) || {};
        if (this.selected_node_id) {
            state.selected_node_id = this.selected_node_id;
        }
        return state;
    },
    /**
     * @override
     */
    highlightNearestHook: function ($helper, position) {
        EditorMixin.highlightNearestHook.apply(this, arguments);

        var $nearest_form_hook = this.$('.o_web_studio_hook')
            .touching({
                    x: position.pageX - this.nearest_hook_tolerance,
                    y: position.pageY - this.nearest_hook_tolerance,
                    w: this.nearest_hook_tolerance*2,
                    h: this.nearest_hook_tolerance*2
                },{
                    container: document.body
                }
            ).nearest({x: position.pageX, y: position.pageY}, {container: document.body}).eq(0);
        if ($nearest_form_hook.length) {
            // We check what is being dropped and in which table
            // since in the autocompletion fields we can drop fields
            // in group_by tables we can drop groupabble fields and separator
            // and in the filter table we can only drop filter and separator and
            // date/datetime components.
            const hookClasses = $helper.attr("class");
            const tableType = $nearest_form_hook.closest('table').data('type');
            const isField = hookClasses.indexOf("o_web_studio_field") > -1;
            const isFilter = hookClasses.indexOf("o_web_studio_filter") > -1;
            const isSeparator = hookClasses.indexOf("o_web_studio_filter_separator") > -1;
            const newAttrs = $helper.data('new_attrs') || {};
            const type = newAttrs.type;
            const store = newAttrs.store;
            let addHook = false;
            if (tableType === 'group_by' && (isField && _.contains(this.GROUPABLE_TYPES, type) && store === 'true')) {
                addHook = true;
            } else if (tableType === 'filters' && (isField && _.contains(this.FILTER_TYPES, type) && store === 'true' || isSeparator || isFilter)) {
                addHook = true;
            } else if (tableType === 'autocompletion_fields' && isField) {
                addHook = true;
            }
            if (addHook) {
                $nearest_form_hook.addClass('o_web_studio_nearest_hook');
                return true;
            }
        }
        return false;
    },
    /**
     * @override
     */
    setLocalState: function (state) {
        if (state.selected_node_id) {
            var $selected_node = this.$('[data-node-id="' + state.selected_node_id + '"]');
            if ($selected_node) {
                $selected_node.click();
            }
        }
    },

    //--------------------------------------------------------------------------
    // Private
    //--------------------------------------------------------------------------

    /**
     * Add hook inside the $parent given
     * whith the tag corresponding to the type.
     *
     * @private
     * @param {JQuery} $parent
     * @param {String} type
     */
    _addFirstHook: function ($parent, type) {
        var node = {
            tag: 'search'
        };
        if (type === "group_by") {
            node = {
                tag: 'group',
            };
        }
        var formEditorHook = this._renderHook(node, 'inside', 'tr', type);
        this.defs.push(formEditorHook.appendTo($parent));
    },
    /**
     * Add hook before the first child of a table.
     *
     * @private
     * @param {JQuery} $result
     * @param {Object} first_child
     * @param {String} type
     */
    _addHookBeforeFirstChild: function ($result, first_child, type) {
        var formEditorHook = this._renderHook(first_child, 'before', 'tr', type);
        this.defs.push(formEditorHook.insertBefore($result));
    },
    /**
     * Check for each table if it is empty.
     * If so, add one hook inside the table.
     *
     * @private
     */
    _addHookEmptyTable: function () {
        var $tbody = this.$('.o_web_studio_search_autocompletion_fields tbody');
        if (!$tbody.children().length) {
            this._addFirstHook($tbody, 'field');
        }
        $tbody = this.$('.o_web_studio_search_filters tbody');
        if (!$tbody.children().length) {
            this._addFirstHook($tbody, 'filter');
        }
        $tbody = this.$('.o_web_studio_search_group_by tbody');
        if (!$tbody.children().length) {
            this._addFirstHook($tbody, 'group_by');
        }
    },
    /**
     * if show_invisible is True then returns all nodes
     * visible + invisible else do super call
     *
     * @override
     */
    _getNodesToTreat() {
        if (this.show_invisible) {
            return this.arch.children.slice();
        }
        return this._super(...arguments);
    },
    /**
     * @private
     * @param {String} model
     * @param {String} value
     * @param {Object} option
     *
     * @returns {Dialog}
     */
    _openDomainDialog: function (model, value, option) {
        return new DomainSelectorDialog(this, model, value, option).open();
    },
    /**
     * Append a node for the type given to the param $result
     * and add 'click' event handler.
     *
     * @private
     * @param {Object} node
     * @param {JQuery} $result
     * @param {String} type
     */
    _prepareEditableSearchNode: function (node, $result, type) {
        var self = this;
        $result.attr('data-node-id', this.node_id++);
        this.setSelectable($result);
        $result.click(function () {
            self.selected_node_id = $result.data('node-id');
            self.trigger_up('node_clicked', {node: node});
        });
        // Add hook after this field
        var formEditorHook = this._renderHook(node, 'after', 'tr', type);
        this.defs.push(formEditorHook.insertAfter($result));
        this._renderHookBeforeFirstChild($result, type);
    },
    /**
     * @override
     * @private
     */
    _render: function () {
        var prom = this._super.apply(this, arguments);

        var self = this;
        this.$('.ui-droppable').droppable({
            accept: ".o_web_studio_component",
            drop: function (event, ui) {
                var $hook = self.$('.o_web_studio_nearest_hook');
                if ($hook.length) {
                    var hook_id = $hook.data('hook_id');
                    var hook = self.hook_nodes[hook_id];
                    var new_attrs = ui.draggable.data('new_attrs') || {};
                    var structure = ui.draggable.data('structure');
                    // Check if a filter component has been dropped
                    if (structure === "filter") {
                        // Create the input for the string here
                        // in order to be able to get the value
                        // easily in the event trigger below
                        var $domain_div = $("<div><label>Label:</label></div>");
                        self.$domain_label_input = $("<input type='text' id='domain_label' class='o_input mb8'/>");
                        $domain_div.append(self.$domain_label_input);
                        var domain_dialog = self._openDomainDialog(
                            self.model,
                            [["id","=",1]],
                            {
                                title: _t("New Filter"),
                                size: 'medium',
                                readonly: false,
                                debugMode: config.isDebug(),
                                $content: $domain_div,
                            }
                        );
                        domain_dialog.opened().then(() => self.$domain_label_input.focus());
                        // Add the node when clicking on the dialog 'save' button
                        domain_dialog.on('domain_selected', self, function (event) {
                            new_attrs = {
                                domain: Domain.prototype.arrayToString(event.data.domain),
                                string: self.$domain_label_input.val(),
                                name: 'studio_' + structure + '_' + utils.randomString(5),
                            };
                            var values = {
                                type: 'add',
                                structure: structure,
                                node: hook.node,
                                new_attrs: new_attrs,
                                position: hook.position,
                            };
                            this.trigger_up('view_change', values);
                        });
                        $hook.removeClass('o_web_studio_nearest_hook');
                        ui.helper.removeClass('ui-draggable-helper-ready');
                        self.trigger_up('on_hook_selected');
                        return;
                    }
                    if (hook.type === "filter" && structure === "field" && _.contains(self.FILTER_TYPES, new_attrs.type)) {
                        structure = "filter";
                        new_attrs.string = new_attrs.label;
                        new_attrs.date = new_attrs.name;
                        new_attrs.name = 'studio_filter_by_' + utils.randomString(5);
                    }
                    // Since the group_by are defined by filter tag inside a group
                    // but the droppable object is a field structure,
                    // the structure is overridden
                    if (hook.type === "group_by" && structure === "field") {
                        structure = "filter";
                        // There is no element 'group' in the view that can be target
                        // to add a group_by filter so we add one before the insertion
                        // of the group_by filter
                        if (!self.first_group_by) {
                            new_attrs.create_group = true;
                        }
                        new_attrs.string = new_attrs.label;
                        new_attrs.context = "{'group_by': '" + new_attrs.name + "'}";
                        new_attrs.name = 'studio_group_by_' + utils.randomString(5);
                    }
                    var values = {
                        type: 'add',
                        structure: structure,
                        field_description: ui.draggable.data('field_description'),
                        node: hook.node,
                        new_attrs: new_attrs,
                        position: hook.position,
                    };
                    ui.helper.removeClass('ui-draggable-helper-ready');
                    self.trigger_up('on_hook_selected');
                    self.trigger_up('view_change', values);
                }
            },
        });
        // Visually indicate the 'undroppable' portion
        this.$el.droppable({
            accept: ".o_web_studio_component",
            tolerance: "touch",
            over: function (ev, ui) {
                var $autocompletionFields = self.$('.o_web_studio_search_autocompletion_fields');
                var $filters = self.$('.o_web_studio_search_filters');
                var $grouBy = self.$('.o_web_studio_search_group_by');
                switch (ui.draggable.data('structure')) {
                    case 'field':
                        var type = ui.draggable.data('new_attrs').type;
                        var store = ui.draggable.data('new_attrs').store;
                        if (!(_.contains(self.FILTER_TYPES, type) && store === 'true')) {
                            $filters.addClass('text-muted');
                        }
                        if (!(_.contains(self.GROUPABLE_TYPES, type) && store === 'true')) {
                            $grouBy.addClass('text-muted');
                        }
                        break;
                    case 'filter':
                    case 'separator':
                        $grouBy.addClass('text-muted');
                        $autocompletionFields.addClass('text-muted');
                        break;
                }
            },
            deactivate: function (ev, ui) {
                self.$('.ui-droppable').removeClass('text-muted');
            },
        });
        this._addHookEmptyTable();

        return prom;
    },
    /**
     * @override
     * @private
     * @param {Object} node
     */
    _renderField: function (node) {
        var $result = this._super.apply(this, arguments);
        this._prepareEditableSearchNode(node, $result, 'field');
        return $result;
    },
    /**
     * @override
     * @private
     * @param {Object} node
     */
    _renderFilter: function (node) {
        var $result = this._super.apply(this, arguments);
        node.attrs.domain = Domain.prototype.arrayToString(node.attrs.domain);
        this._prepareEditableSearchNode(node, $result, 'filter');
        return $result;
    },
    /**
     * @override
     * @private
     * @param {Object} node
     */
    _renderGroupBy: function (node) {
        node.tag = "filter";
        // attribute used in the template to know
        // if we are clicking on a group_by or a filter
        // since the nodes have the same tag "filter"
        node.attrs.is_group_by = true;
        var $result = this._super.apply(this, arguments);
        this._prepareEditableSearchNode(node, $result, 'group_by');
        return $result;
    },
    /**
     * @private
     * @param {Object} node
     * @param {String} position
     * @param {String} tag_name
     * @param {String} type
     *
     * @returns {Widget}
     */
    _renderHook: function (node, position, tag_name, type) {
        var hook_id = _.uniqueId();
        this.hook_nodes[hook_id] = {
            node: node,
            position: position,
            type: type,
        };
        return new FormEditorHook(this, position, hook_id, tag_name);
    },
    /**
     * Render hook before the first child of a table.
     *
     * @private
     * @param {JQuery} $result
     * @param {String} type
     */
    _renderHookBeforeFirstChild: function ($result, type) {
        if (type === 'field' && this.first_field && this.first_field !== 'done') {
            this._addHookBeforeFirstChild($result, this.first_field, 'field');
            this.first_field = 'done';
        } else if (type === 'filter' && this.first_filter && this.first_filter !== 'done') {
            this._addHookBeforeFirstChild($result, this.first_filter, 'filter');
            this.first_filter = 'done';
        } else if (type ==='group_by' && this.first_group_by && this.first_group_by !== 'done') {
            this._addHookBeforeFirstChild($result, this.first_group_by, 'group_by');
            this.first_group_by = 'done';
        }
    },
    /**
     * @override
     * @private
     * @param {Object} node
     */
    _renderSeparator: function (node) {
        var $result = this._super.apply(this, arguments);
        this._prepareEditableSearchNode(node, $result, 'filter');
        return $result;
    },
});

return SearchEditor;

});

//# sourceMappingURL=/web/assets/102-24a45da/web_studio.studio_assets.js.map