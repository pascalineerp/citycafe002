)]}'
{"version": 3, "sources": ["/web/static/src/legacy/js/views/graph/graph_controller.js", "/web/static/src/legacy/js/views/graph/graph_model.js", "/web/static/src/legacy/js/views/graph/graph_renderer.js", "/web/static/src/legacy/js/views/graph/graph_utils.js", "/web/static/src/legacy/js/views/graph/graph_view.js", "/web/static/src/legacy/js/views/pivot/pivot_controller.js", "/web/static/src/legacy/js/views/pivot/pivot_model.js", "/web/static/src/legacy/js/views/pivot/pivot_renderer.js", "/web/static/src/legacy/js/views/pivot/pivot_view.js", "/web_enterprise/static/src/legacy/js/views/pivot_renderer.js", "/web_map/static/src/legacy/js/map_controller.js", "/web_map/static/src/legacy/js/map_model.js", "/web_map/static/src/legacy/js/map_renderer.js", "/web_map/static/src/legacy/js/map_view.js", "/web_cohort/static/src/legacy/js/cohort_controller.js", "/web_cohort/static/src/legacy/js/cohort_model.js", "/web_cohort/static/src/legacy/js/cohort_renderer.js", "/web_cohort/static/src/legacy/js/cohort_view.js", "/web_cohort/static/src/legacy/js/sample_server.js", "/web_dashboard/static/src/legacy/js/dashboard_controller.js", "/web_dashboard/static/src/legacy/js/dashboard_model.js", "/web_dashboard/static/src/legacy/js/dashboard_model_extension.js", "/web_dashboard/static/src/legacy/js/dashboard_renderer.js", "/web_dashboard/static/src/legacy/js/dashboard_view.js"], "mappings": "AAAA;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChWA;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3UA;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACv+BA;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtFA;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/KA;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClUA;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzgDA;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnSA;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrKA;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACpCA;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/IA;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACphBA;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1dA;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxFA;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChNA;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChJA;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnFA;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3IA;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5FA;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpGA;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChOA;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvFA;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9bA;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA", "sourcesContent": ["odoo.define('web.GraphController', function (require) {\n\"use strict\";\n\n/*---------------------------------------------------------\n * Odoo Graph view\n *---------------------------------------------------------*/\n\nconst AbstractController = require('web.AbstractController');\nconst { ComponentWrapper } = require('web.OwlCompatibility');\nconst DropdownMenu = require('web.DropdownMenu');\nconst { DEFAULT_INTERVAL, INTERVAL_OPTIONS } = require('web.searchUtils');\nconst { qweb } = require('web.core');\nconst { _t } = require('web.core');\n\nclass CarretDropdownMenu extends DropdownMenu {\n    /**\n     * @override\n     */\n    get displayCaret() {\n        return true;\n    }\n}\n\nvar GraphController = AbstractController.extend({\n    custom_events: _.extend({}, AbstractController.prototype.custom_events, {\n        item_selected: '_onItemSelected',\n        open_view: '_onOpenView',\n    }),\n\n    /**\n     * @override\n     * @param {Widget} parent\n     * @param {GraphModel} model\n     * @param {GraphRenderer} renderer\n     * @param {Object} params\n     * @param {string[]} params.measures\n     * @param {boolean} params.isEmbedded\n     * @param {string[]} params.groupableFields,\n     */\n    init: function (parent, model, renderer, params) {\n        this._super.apply(this, arguments);\n        this.measures = params.measures;\n        // this parameter condition the appearance of a 'Group By'\n        // button in the control panel owned by the graph view.\n        this.isEmbedded = params.isEmbedded;\n        this.withButtons = params.withButtons;\n        // views to use in the action triggered when the graph is clicked\n        this.views = params.views;\n        this.title = params.title;\n\n        // this parameter determines what is the list of fields\n        // that may be used within the groupby menu available when\n        // the view is embedded\n        this.groupableFields = params.groupableFields;\n        this.buttonDropdownPromises = [];\n    },\n    /**\n     * @todo check if this can be removed (mostly duplicate with\n     * AbstractController method)\n     */\n    destroy: function () {\n        if (this.$buttons) {\n            // remove jquery's tooltip() handlers\n            this.$buttons.find('button').off().tooltip('dispose');\n        }\n        this._super.apply(this, arguments);\n    },\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    /**\n     * Returns the current mode, measure and groupbys, so we can restore the\n     * view when we save the current state in the search view, or when we add it\n     * to the dashboard.\n     *\n     * @override\n     * @returns {Object}\n     */\n    getOwnedQueryParams: function () {\n        var state = this.model.get();\n        return {\n            context: {\n                graph_measure: state.measure,\n                graph_mode: state.mode,\n                graph_groupbys: state.groupBy,\n            }\n        };\n    },\n    /**\n     * @override\n     */\n    reload: async function () {\n        const promises = [this._super(...arguments)];\n        if (this.withButtons) {\n            const state = this.model.get();\n            this.measures.forEach(m => m.isActive = m.fieldName === state.measure);\n            promises.push(this.measureMenu.update({ items: this.measures }));\n        }\n        return Promise.all(promises);\n    },\n    /**\n     * Render the buttons according to the GraphView.buttons and\n     * add listeners on it.\n     * Set this.$buttons with the produced jQuery element\n     *\n     * @param {jQuery} [$node] a jQuery node where the rendered buttons should\n     * be inserted $node may be undefined, in which case the GraphView does\n     * nothing\n     */\n    renderButtons: function ($node) {\n        this.$buttons = $(qweb.render('GraphView.buttons'));\n        this.$buttons.find('button').tooltip();\n        this.$buttons.click(ev => this._onButtonClick(ev));\n\n        if (this.withButtons) {\n            const state = this.model.get();\n            const fragment = document.createDocumentFragment();\n            // Instantiate and append MeasureMenu\n            this.measures.forEach(m => m.isActive = m.fieldName === state.measure);\n            this.measureMenu = new ComponentWrapper(this, CarretDropdownMenu, {\n                title: _t(\"Measures\"),\n                items: this.measures,\n            });\n            this.buttonDropdownPromises = [this.measureMenu.mount(fragment)];\n            if (this.isEmbedded) {\n                // Instantiate and append GroupBy menu\n                this.groupByMenu = new ComponentWrapper(this, CarretDropdownMenu, {\n                    title: _t(\"Group By\"),\n                    icon: 'fa fa-bars',\n                    items: this._getGroupBys(state.groupBy),\n                });\n                this.buttonDropdownPromises.push(this.groupByMenu.mount(fragment));\n            }\n            if ($node) {\n                this.$buttons.appendTo($node);\n            }\n        }\n    },\n    /**\n     * Makes sure that the buttons in the control panel matches the current\n     * state (so, correct active buttons and stuff like that).\n     *\n     * @override\n     */\n    updateButtons: function () {\n        if (!this.$buttons) {\n            return;\n        }\n        var state = this.model.get();\n        this.$buttons.find('.o_graph_button').removeClass('active');\n        this.$buttons\n            .find('.o_graph_button[data-mode=\"' + state.mode + '\"]')\n            .addClass('active');\n        this.$buttons\n            .find('.o_graph_button[data-mode=\"stack\"]')\n            .data('stacked', state.stacked)\n            .toggleClass('active', state.stacked)\n            .toggleClass('o_hidden', state.mode !== 'bar');\n        this.$buttons\n            .find('.o_graph_button[data-order]')\n            .toggleClass('o_hidden', state.mode === 'pie' || !!Object.keys(state.timeRanges).length)\n            .filter('.o_graph_button[data-order=\"' + state.orderBy + '\"]')\n            .toggleClass('active', !!state.orderBy);\n\n        if (this.withButtons) {\n            return this._attachDropdownComponents();\n        }\n    },\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    /**\n     * Attaches the different dropdown components to the buttons container.\n     *\n     * @returns {Promise}\n     */\n    async _attachDropdownComponents() {\n        await Promise.all(this.buttonDropdownPromises);\n        if (this.isDestroyed()) {\n            return;\n        }\n        const actionsContainer = this.$buttons[0];\n        // Attach \"measures\" button\n        actionsContainer.appendChild(this.measureMenu.el);\n        this.measureMenu.el.classList.add('o_graph_measures_list');\n        if (this.isEmbedded) {\n            // Attach \"groupby\" button\n            actionsContainer.appendChild(this.groupByMenu.el);\n            this.groupByMenu.el.classList.add('o_group_by_menu');\n        }\n        // Update button classes accordingly to the current mode\n        const buttons = actionsContainer.querySelectorAll('.dropdown-toggle');\n        for (const button of buttons) {\n            button.classList.remove('btn-secondary');\n            if (this.isEmbedded) {\n                button.classList.add('btn-outline-secondary');\n            } else {\n                button.classList.add('btn-primary');\n                button.tabIndex = 0;\n            }\n        }\n    },\n\n    /**\n     * Returns the items used by the Group By menu in embedded mode.\n     *\n     * @private\n     * @param {string[]} activeGroupBys\n     * @returns {Object[]}\n     */\n    _getGroupBys(activeGroupBys) {\n        const normalizedGroupBys = this._normalizeActiveGroupBys(activeGroupBys);\n        const groupBys = Object.keys(this.groupableFields).map(fieldName => {\n            const field = this.groupableFields[fieldName];\n            const groupByActivity = normalizedGroupBys.filter(gb => gb.fieldName === fieldName);\n            const groupBy = {\n                id: fieldName,\n                isActive: Boolean(groupByActivity.length),\n                description: field.string,\n                itemType: 'groupBy',\n            };\n            if (['date', 'datetime'].includes(field.type)) {\n                groupBy.hasOptions = true;\n                const activeOptionIds = groupByActivity.map(gb => gb.interval);\n                groupBy.options = Object.values(INTERVAL_OPTIONS).map(o => {\n                    return Object.assign({}, o, { isActive: activeOptionIds.includes(o.id) });\n                });\n            }\n            return groupBy;\n        }).sort((gb1, gb2) => {\n            return gb1.description.localeCompare(gb2.description);\n        });\n        return groupBys;\n    },\n\n    /**\n     * This method puts the active groupBys in a convenient form.\n     *\n     * @private\n     * @param {string[]} activeGroupBys\n     * @returns {Object[]} normalizedGroupBys\n     */\n    _normalizeActiveGroupBys(activeGroupBys) {\n        return activeGroupBys.map(groupBy => {\n            const fieldName = groupBy.split(':')[0];\n            const field = this.groupableFields[fieldName];\n            const normalizedGroupBy = { fieldName };\n            if (['date', 'datetime'].includes(field.type)) {\n                normalizedGroupBy.interval = groupBy.split(':')[1] || DEFAULT_INTERVAL;\n            }\n            return normalizedGroupBy;\n        });\n    },\n\n    //--------------------------------------------------------------------------\n    // Handlers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Do what need to be done when a button from the control panel is clicked.\n     *\n     * @private\n     * @param {MouseEvent} ev\n     */\n    _onButtonClick: function (ev) {\n        var $target = $(ev.target);\n        if ($target.hasClass('o_graph_button')) {\n            if (_.contains(['bar','line', 'pie'], $target.data('mode'))) {\n                this.update({ mode: $target.data('mode') });\n            } else if ($target.data('mode') === 'stack') {\n                this.update({ stacked: !$target.data('stacked') });\n            } else if (['asc', 'desc'].includes($target.data('order'))) {\n                const order = $target.data('order');\n                const state = this.model.get();\n                this.update({ orderBy: state.orderBy === order ? false : order });\n            }\n        }\n    },\n\n    /**\n     * @private\n     * @param {OdooEvent} ev\n     */\n    _onItemSelected(ev) {\n        const item = ev.data.item;\n        if (this.isEmbedded && item.itemType === 'groupBy') {\n            const fieldName = item.id;\n            const optionId = ev.data.option && ev.data.option.id;\n            const activeGroupBys = this.model.get().groupBy;\n            if (optionId) {\n                const normalizedGroupBys = this._normalizeActiveGroupBys(activeGroupBys);\n                const index = normalizedGroupBys.findIndex(ngb =>\n                    ngb.fieldName === fieldName && ngb.interval === optionId);\n                if (index === -1) {\n                    activeGroupBys.push(fieldName + ':' + optionId);\n                } else {\n                    activeGroupBys.splice(index, 1);\n                }\n            } else {\n                const groupByFieldNames = activeGroupBys.map(gb => gb.split(':')[0]);\n                const indexOfGroupby = groupByFieldNames.indexOf(fieldName);\n                if (indexOfGroupby === -1) {\n                    activeGroupBys.push(fieldName);\n                } else {\n                    activeGroupBys.splice(indexOfGroupby, 1);\n                }\n            }\n            this.update({ groupBy: activeGroupBys });\n            this.groupByMenu.update({\n                items: this._getGroupBys(activeGroupBys),\n            });\n        } else if (item.itemType === 'measure') {\n            this.update({ measure: item.fieldName });\n            this.measures.forEach(m => m.isActive = m.fieldName === item.fieldName);\n            this.measureMenu.update({ items: this.measures });\n        }\n    },\n\n    /**\n     * @private\n     * @param {OdooEvent} ev\n     * @param {Array[]} ev.data.domain\n     */\n    _onOpenView(ev) {\n        ev.stopPropagation();\n        const state = this.model.get();\n        const context = Object.assign({}, state.context);\n        Object.keys(context).forEach(x => {\n            if (x === 'group_by' || x.startsWith('search_default_')) {\n                delete context[x];\n            }\n        });\n        this.do_action({\n            context: context,\n            domain: ev.data.domain,\n            name: this.title,\n            res_model: this.modelName,\n            target: 'current',\n            type: 'ir.actions.act_window',\n            view_mode: 'list',\n            views: this.views,\n        });\n    },\n});\n\nreturn GraphController;\n\n});\n", "odoo.define('web.GraphModel', function (require) {\n\"use strict\";\n\nvar core = require('web.core');\nconst { DEFAULT_INTERVAL, rankInterval } = require('web.searchUtils');\n\nvar _t = core._t;\n\n/**\n * The graph model is responsible for fetching and processing data from the\n * server.  It basically just do a(some) read_group(s) and format/normalize data.\n */\nvar AbstractModel = require('web.AbstractModel');\n\nreturn AbstractModel.extend({\n    /**\n     * @override\n     * @param {Widget} parent\n     */\n    init: function () {\n        this._super.apply(this, arguments);\n        this.chart = null;\n    },\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    /**\n     *\n     * We defend against outside modifications by extending the chart data. It\n     * may be overkill.\n     *\n     * @override\n     * @returns {Object}\n     */\n    __get: function () {\n        return Object.assign({ isSample: this.isSampleModel }, this.chart);\n    },\n    /**\n     * Initial loading.\n     *\n     * @todo All the work to fall back on the graph_groupbys keys in the context\n     * should be done by the graphView I think.\n     *\n     * @param {Object} params\n     * @param {Object} params.context\n     * @param {Object} params.fields\n     * @param {string[]} params.domain\n     * @param {string[]} params.groupBys a list of valid field names\n     * @param {string[]} params.groupedBy a list of valid field names\n     * @param {boolean} params.stacked\n     * @param {string} params.measure a valid field name\n     * @param {'pie'|'bar'|'line'} params.mode\n     * @param {string} params.modelName\n     * @param {Object} params.timeRanges\n     * @returns {Promise} The promise does not return a handle, we don't need\n     *   to keep track of various entities.\n     */\n    __load: function (params) {\n        var groupBys = params.context.graph_groupbys || params.groupBys;\n        this.initialGroupBys = groupBys;\n        this.fields = params.fields;\n        this.modelName = params.modelName;\n        this.chart = Object.assign({\n            context: params.context,\n            dataPoints: [],\n            domain: params.domain,\n            groupBy: params.groupedBy.length ? params.groupedBy : groupBys,\n            measure: params.context.graph_measure || params.measure,\n            mode: params.context.graph_mode || params.mode,\n            origins: [],\n            stacked: params.stacked,\n            timeRanges: params.timeRanges,\n            orderBy: params.orderBy\n        });\n\n        if (this.chart.measure === \"__count\") {\n            this.chart.measure = \"__count__\";\n        }\n\n        this._computeDerivedParams();\n\n        return this._loadGraph();\n    },\n    /**\n     * Reload data.  It is similar to the load function. Note that we ignore the\n     * handle parameter, we always expect our data to be in this.chart object.\n     *\n     * @todo This method takes 'groupBy' and load method takes 'groupedBy'. This\n     *   is insane.\n     *\n     * @param {any} handle ignored!\n     * @param {Object} params\n     * @param {boolean} [params.stacked]\n     * @param {Object} [params.context]\n     * @param {string[]} [params.domain]\n     * @param {string[]} [params.groupBy]\n     * @param {string} [params.measure] a valid field name\n     * @param {string} [params.mode] one of 'bar', 'pie', 'line'\n     * @param {Object} [params.timeRanges]\n     * @returns {Promise}\n     */\n    __reload: function (handle, params) {\n        if ('context' in params) {\n            this.chart.context = params.context;\n            this.chart.groupBy = params.context.graph_groupbys || this.chart.groupBy;\n            this.chart.measure = params.context.graph_measure || this.chart.measure;\n            this.chart.mode = params.context.graph_mode || this.chart.mode;\n        }\n        if ('domain' in params) {\n            this.chart.domain = params.domain;\n        }\n        if ('groupBy' in params) {\n            this.chart.groupBy = params.groupBy.length ? params.groupBy : this.initialGroupBys;\n        }\n        if ('measure' in params) {\n            this.chart.measure = params.measure;\n        }\n        if ('timeRanges' in params) {\n            this.chart.timeRanges = params.timeRanges;\n        }\n\n        if (this.chart.measure === \"__count\") {\n            this.chart.measure = \"__count__\";\n        }\n\n        this._computeDerivedParams();\n\n        if ('mode' in params) {\n            this.chart.mode = params.mode;\n            return Promise.resolve();\n        }\n        if ('stacked' in params) {\n            this.chart.stacked = params.stacked;\n            return Promise.resolve();\n        }\n        if ('orderBy' in params) {\n            this.chart.orderBy = params.orderBy;\n            return Promise.resolve();\n        }\n        return this._loadGraph();\n    },\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    /**\n     * Compute this.chart.processedGroupBy, this.chart.domains, this.chart.origins,\n     * and this.chart.comparisonFieldIndex.\n     * Those parameters are determined by this.chart.timeRanges, this.chart.groupBy, and this.chart.domain.\n     *\n     * @private\n     */\n    _computeDerivedParams: function () {\n        this.chart.processedGroupBy = this._processGroupBy(this.chart.groupBy);\n\n        const { range, rangeDescription, comparisonRange, comparisonRangeDescription, fieldName } = this.chart.timeRanges;\n        if (range) {\n            this.chart.domains = [\n                this.chart.domain.concat(range),\n                this.chart.domain.concat(comparisonRange),\n            ];\n            this.chart.origins = [rangeDescription, comparisonRangeDescription];\n            const groupBys = this.chart.processedGroupBy.map(function (gb) {\n                return gb.split(\":\")[0];\n            });\n            this.chart.comparisonFieldIndex = groupBys.indexOf(fieldName);\n        } else {\n            this.chart.domains = [this.chart.domain];\n            this.chart.origins = [\"\"];\n            this.chart.comparisonFieldIndex = -1;\n        }\n    },\n    /**\n     * @override\n     */\n    _isEmpty() {\n        return this.chart.dataPoints.length === 0;\n    },\n    /**\n     * Fetch and process graph data.  It is basically a(some) read_group(s)\n     * with correct fields for each domain.  We have to do some light processing\n     * to separate date groups in the field list, because they can be defined\n     * with an aggregation function, such as my_date:week.\n     *\n     * @private\n     * @returns {Promise}\n     */\n    _loadGraph: function () {\n        var self = this;\n        this.chart.dataPoints = [];\n        var groupBy = this.chart.processedGroupBy;\n        var fields = _.map(groupBy, function (groupBy) {\n            return groupBy.split(':')[0];\n        });\n        const loadId = this.loadId ? ++this.loadId : 1;\n        this.loadId = loadId;\n\n        if (this.chart.measure !== '__count__') {\n            if (this.fields[this.chart.measure].type === 'many2one') {\n                fields = fields.concat(this.chart.measure + \":count_distinct\");\n            }\n            else {\n                fields = fields.concat(this.chart.measure);\n            }\n        }\n\n        var context = _.extend({fill_temporal: true}, this.chart.context);\n\n        var proms = [];\n        this.chart.domains.forEach(function (domain, originIndex) {\n            proms.push(self._rpc({\n                model: self.modelName,\n                method: 'read_group',\n                context: context,\n                domain: domain,\n                fields: fields,\n                groupBy: groupBy,\n                lazy: false,\n            }).then(self._processData.bind(self, originIndex, loadId)));\n        });\n        return Promise.all(proms);\n    },\n    /**\n     * Since read_group is insane and returns its result on different keys\n     * depending of some input, we have to normalize the result.\n     * Each group coming from the read_group produces a dataPoint\n     *\n     * @private\n     * @param {number} originIndex\n     * @param {any} rawData result from the read_group\n     */\n    _processData: function (originIndex, loadId, rawData) {\n        if (loadId < this.loadId) {\n            return;\n        }\n        var self = this;\n        var isCount = this.chart.measure === '__count__';\n        var labels;\n\n        function getLabels (dataPt) {\n            return self.chart.processedGroupBy.map(function (field) {\n                return self._sanitizeValue(dataPt[field], field.split(\":\")[0]);\n            });\n        }\n        rawData.forEach(function (dataPt){\n            labels = getLabels(dataPt);\n            var count = dataPt.__count || dataPt[self.chart.processedGroupBy[0]+'_count'] || 0;\n            var value = isCount ? count : dataPt[self.chart.measure];\n            if (value instanceof Array) {\n                // when a many2one field is used as a measure AND as a grouped\n                // field, bad things happen.  The server will only return the\n                // grouped value and will not aggregate it.  Since there is a\n                // name clash, we are then in the situation where this value is\n                // an array.  Fortunately, if we group by a field, then we can\n                // say for certain that the group contains exactly one distinct\n                // value for that field.\n                value = 1;\n            }\n            self.chart.dataPoints.push({\n                resId: dataPt[self.chart.groupBy[0]] instanceof Array ? dataPt[self.chart.groupBy[0]][0] : -1,\n                count: count,\n                domain: dataPt.__domain,\n                value: value,\n                labels: labels,\n                originIndex: originIndex,\n            });\n        });\n    },\n    /**\n     * Process the groupBy parameter in order to keep only the finer interval option for\n     * elements based on date/datetime field (e.g. 'date:year'). This means that\n     * 'week' is prefered to 'month'. The field stays at the place of its first occurence.\n     * For instance,\n     * ['foo', 'date:month', 'bar', 'date:week'] becomes ['foo', 'date:week', 'bar'].\n     *\n     * @private\n     * @param {string[]} groupBy\n     * @returns {string[]}\n     */\n    _processGroupBy: function(groupBy) {\n        const groupBysMap = new Map();\n        for (const gb of groupBy) {\n            let [fieldName, interval] = gb.split(':');\n            const field = this.fields[fieldName];\n            if (['date', 'datetime'].includes(field.type)) {\n                interval = interval || DEFAULT_INTERVAL;\n            }\n            if (groupBysMap.has(fieldName)) {\n                const registeredInterval = groupBysMap.get(fieldName);\n                if (rankInterval(registeredInterval) < rankInterval(interval)) {\n                    groupBysMap.set(fieldName, interval);\n                }\n            } else {\n                groupBysMap.set(fieldName, interval);\n            }\n        }\n        return [...groupBysMap].map(([fieldName, interval]) => {\n            if (interval) {\n                return `${fieldName}:${interval}`;\n            }\n            return fieldName;\n        });\n    },\n    /**\n     * Helper function (for _processData), turns various values in a usable\n     * string form, that we can display in the interface.\n     *\n     * @private\n     * @param {any} value value for the field fieldName received by the read_group rpc\n     * @param {string} fieldName\n     * @returns {string}\n     */\n    _sanitizeValue: function (value, fieldName) {\n        if (value === false && this.fields[fieldName].type !== 'boolean') {\n            return _t(\"Undefined\");\n        }\n        if (value instanceof Array) {\n            return value[1];\n        }\n        if (fieldName && (this.fields[fieldName].type === 'selection')) {\n            var selected = _.where(this.fields[fieldName].selection, {0: value})[0];\n            return selected ? selected[1] : value;\n        }\n        return value;\n    },\n});\n\n});\n", "odoo.define(\"web/static/src/js/views/graph/graph_renderer\", function (require) {\n    \"use strict\";\n\n    const AbstractRenderer = require(\"web.AbstractRendererOwl\");\n    const { DateClasses } = require(\"web.dataComparisonUtils\");\n    const fieldUtils = require(\"web.field_utils\");\n    const { sortBy } = require(\"web.utils\");\n\n    const {\n        COLORS,\n        DEFAULT_BG,\n        FORMAT_OPTIONS,\n        MAX_LEGEND_LENGTH,\n        getColor,\n        getMaxWidth,\n        hexToRGBA,\n        shortenLabel,\n    } = require(\"web/static/src/js/views/graph/graph_utils\");\n\n    const { useRef } = owl.hooks;\n    class GraphRenderer extends AbstractRenderer {\n        constructor() {\n            super(...arguments);\n\n            this.noDataLabel = [this.env._t(\"No data\")];\n            this.fakeDataLabel = [\"\"];\n            this.sampleDataTargets = [\".o_graph_canvas_container\"];\n            this._processProps(this.props);\n\n            this.canvasRef = useRef(\"canvas\");\n            this.containerRef = useRef(\"container\");\n        }\n\n        async willUpdateProps(nextProps) {\n            await super.willUpdateProps(...arguments);\n            this._processProps(nextProps);\n        }\n\n        mounted() {\n            super.mounted();\n            this._renderChart();\n        }\n\n        patched() {\n            super.patched();\n            this._renderChart();\n        }\n\n        //---------------------------------------------------------------------\n        // Getters\n        //---------------------------------------------------------------------\n\n        get measureDescription() {\n            const measure = this.props.measures.find(m => m.fieldName === this.props.measure);\n            return measure ? measure.description : this.props.fields[this.props.measure].string;\n        }\n\n        //---------------------------------------------------------------------\n        // Private\n        //---------------------------------------------------------------------\n\n        /**\n         * This function aims to remove a suitable number of lines from the\n         * tooltip in order to make it reasonably visible. A message indicating\n         * the number of lines is added if necessary.\n         * @private\n         * @param {Number} maxTooltipHeight this the max height in pixels of the tooltip\n         */\n        _adjustTooltipHeight(maxTooltipHeight) {\n            const sizeOneLine = this.tooltip.querySelector(\"tbody tr\").clientHeight;\n            const tbodySize = this.tooltip.querySelector(\"tbody\").clientHeight;\n            const toKeep = Math.max(0, Math.floor(\n                (maxTooltipHeight - (this.tooltip.clientHeight - tbodySize)\n                ) / sizeOneLine) - 1);\n            const lines = this.tooltip.querySelectorAll(\"tbody tr\");\n            const toRemove = lines.length - toKeep;\n            if (toRemove > 0) {\n                for (let index = toKeep; index < lines.length; ++index) {\n                    lines[index].remove();\n                }\n                const tr = document.createElement(\"tr\");\n                const td = document.createElement(\"td\");\n                tr.classList.add(\"o_show_more\");\n                td.innerHTML = this.env._t(\"...\");\n                tr.appendChild(td);\n                this.tooltip.querySelector(\"tbody\").appendChild(tr);\n            }\n        }\n\n        /**\n         * Creates a bar chart config.\n         * @private\n         */\n        _createBarChartConfig() {\n            // prepare data\n            const data = this._prepareData(this.processedDataPoints);\n\n            for (let index = 0; index < data.datasets.length; ++index) {\n                const dataset = data.datasets[index];\n                // used when stacked\n                if (this.props.stacked) {\n                    dataset.stack = this.props.origins[dataset.originIndex];\n                }\n                // set dataset color\n                dataset.backgroundColor = getColor(index);\n            }\n\n            // prepare options\n            const options = this._prepareOptions(data.datasets.length);\n\n            // create bar chart config\n            return { data, options, type: \"bar\" };\n        }\n\n        /**\n         * Returns the graph configuration object.\n         * @private\n         * @returns {Object}\n         */\n        _createConfig() {\n            if (this.noContentHelperData) {\n                return {};\n            }\n            if (this.props.comparisonFieldIndex === 0) {\n                this.dateClasses = this._getDateClasses(this.processedDataPoints);\n            }\n            switch (this.props.mode) {\n                case \"bar\": return this._createBarChartConfig();\n                case \"line\": return this._createLineChartConfig();\n                case \"pie\": return this._createPieChartConfig();\n            }\n        }\n\n        /**\n         * Creates a line chart config.\n         * @private\n         */\n        _createLineChartConfig() {\n            // prepare data\n            const data = this._prepareData(this.processedDataPoints);\n            for (let index = 0; index < data.datasets.length; ++index) {\n                const dataset = data.datasets[index];\n                if (\n                    this.props.processedGroupBy.length <= 1 &&\n                    this.props.origins.length > 1\n                ) {\n                    if (dataset.originIndex === 0) {\n                        dataset.fill = \"origin\";\n                        dataset.backgroundColor = hexToRGBA(COLORS[0], 0.4);\n                        dataset.borderColor = hexToRGBA(COLORS[0], 1);\n                    } else if (dataset.originIndex === 1) {\n                        dataset.borderColor = hexToRGBA(COLORS[1], 1);\n                    } else {\n                        dataset.borderColor = getColor(index);\n                    }\n                } else {\n                    dataset.borderColor = getColor(index);\n                }\n                if (data.labels.length === 1) {\n                    // shift of the real value to right. This is done to\n                    // center the points in the chart. See data.labels below in\n                    // Chart parameters\n                    dataset.data.unshift(undefined);\n                }\n                dataset.pointBackgroundColor = dataset.borderColor;\n                dataset.pointBorderColor = \"rgba(0,0,0,0.2)\";\n            }\n            if (data.datasets.length === 1 && data.datasets[0].originIndex === 0) {\n                const dataset = data.datasets[0];\n                dataset.fill = \"origin\";\n                dataset.backgroundColor = hexToRGBA(COLORS[0], 0.4);\n            }\n\n            // center the points in the chart (without that code they are put\n            // on the left and the graph seems empty)\n            data.labels = data.labels.length > 1 ?\n                data.labels :\n                [this.fakeDataLabel, ...data.labels, this.fakeDataLabel];\n\n            // prepare options\n            const options = this._prepareOptions(data.datasets.length);\n\n            // create line chart config\n            return { data, options, type: \"line\" };\n        }\n\n        /**\n         * Creates a pie chart config.\n         * @private\n         */\n        _createPieChartConfig() {\n            // prepare data\n            let data = {};\n            const allZero = this.processedDataPoints.every(\n                datapt => datapt.value === 0\n            );\n            if (allZero) {\n                // add fake data to display a pie chart with a grey zone associated\n                // with every origin\n                data.labels = [this.noDataLabel];\n                data.datasets = this.props.origins.map(origin => {\n                    return {\n                        label: origin,\n                        data: [1],\n                        backgroundColor: [DEFAULT_BG],\n                    };\n                });\n            } else {\n                data = this._prepareData(this.processedDataPoints);\n                // give same color to same groups from different origins\n                const colors = data.labels.map((_, index) => getColor(index));\n                for (const dataset of data.datasets) {\n                    dataset.backgroundColor = colors;\n                    dataset.borderColor = \"rgba(255,255,255,0.6)\";\n                }\n                // make sure there is a zone associated with every origin\n                const representedOriginIndexes = data.datasets.map(\n                    dataset => dataset.originIndex\n                );\n                let addNoDataToLegend = false;\n                const fakeData = new Array(data.labels.length).concat([1]);\n\n                for (let index = 0; index < this.props.origins.length; ++index) {\n                    const origin = this.props.origins[index];\n                    if (!representedOriginIndexes.includes(index)) {\n                        data.datasets.splice(index, 0, {\n                            label: origin,\n                            data: fakeData,\n                            backgroundColor: [...colors, DEFAULT_BG],\n                        });\n                        addNoDataToLegend = true;\n                    }\n                }\n                if (addNoDataToLegend) {\n                    data.labels.push(this.noDataLabel);\n                }\n            }\n\n            // prepare options\n            const options = this._prepareOptions(data.datasets.length);\n\n            // create pie chart config\n            return { data, options, type: \"pie\" };\n        }\n\n        /**\n         * Creates a custom HTML tooltip.\n         * @private\n         * @param {Object} tooltipModel see chartjs documentation\n         */\n        _customTooltip(tooltipModel) {\n            this.el.style.cursor = \"\";\n            this._removeTooltips();\n            if (tooltipModel.opacity === 0 || tooltipModel.dataPoints.length === 0) {\n                return;\n            }\n            if (this._isRedirectionEnabled()) {\n                this.el.style.cursor = \"pointer\";\n            }\n\n            const chartAreaTop = this.chart.chartArea.top;\n            const rendererTop = this.el.getBoundingClientRect().top;\n\n            const innerHTML = this.env.qweb.renderToString(\"web.GraphRenderer.CustomTooltip\", {\n                maxWidth: getMaxWidth(this.chart.chartArea),\n                measure: this.measureDescription,\n                mode: this.props.mode,\n                tooltipItems: this._getTooltipItems(tooltipModel),\n            });\n            const template = Object.assign(document.createElement(\"template\"), { innerHTML });\n            this.tooltip = template.content.firstChild;\n\n            this.containerRef.el.prepend(this.tooltip);\n\n            let top;\n            const tooltipHeight = this.tooltip.clientHeight;\n            const minTopAllowed = Math.floor(chartAreaTop);\n            const maxTopAllowed = Math.floor(window.innerHeight - (rendererTop + tooltipHeight)) - 2;\n            const y = Math.floor(tooltipModel.y);\n\n            if (minTopAllowed <= maxTopAllowed) {\n                // Here we know that the full tooltip can fit in the screen.\n                // We put it in the position where Chart.js would put it\n                // if two conditions are respected:\n                //  1: the tooltip is not cut (because we know it is possible to not cut it)\n                //  2: the tooltip does not hide the legend.\n                // If it is not possible to use the Chart.js proposition (y)\n                // we use the best approximated value.\n                if (y <= maxTopAllowed) {\n                    if (y >= minTopAllowed) {\n                        top = y;\n                    } else {\n                        top = minTopAllowed;\n                    }\n                } else {\n                    top = maxTopAllowed;\n                }\n            } else {\n                // Here we know that we cannot satisfy condition 1 above,\n                // so we position the tooltip at the minimal position and\n                // cut it the minimum possible.\n                top = minTopAllowed;\n                const maxTooltipHeight = window.innerHeight - (rendererTop + chartAreaTop) - 2;\n                this._adjustTooltipHeight(maxTooltipHeight);\n            }\n\n            this._fixTooltipLeftPosition(this.tooltip, tooltipModel.x);\n            this.tooltip.style.top = Math.floor(top) + \"px\";\n        }\n\n        /**\n         * Filters out some dataPoints because they would lead to bad graphics.\n         * The filtering is done with respect to the graph view mode.\n         * Note that the method does not alter this.state.dataPoints, since we\n         * want to be able to change of mode without fetching data again:\n         * we simply present the same data in a different way.\n         * Note: this should be moved to the model at some point.\n         * @private\n         * @param {Object} props\n         * @returns {Object[]}\n         */\n        _filterDataPoints(props) {\n            let dataPoints = [];\n            if (props.mode === \"line\") {\n                let counts = 0;\n                for (const dataPoint of props.dataPoints) {\n                    if (dataPoint.labels[0] !== this.env._t(\"Undefined\")) {\n                        dataPoints.push(dataPoint);\n                    }\n                    counts += dataPoint.count;\n                }\n                // data points with zero count might have been created on purpose\n                // we only remove them if there are no data point with positive count\n                if (counts === 0) {\n                    dataPoints = [];\n                }\n            } else {\n                dataPoints = props.dataPoints.filter(\n                    dataPoint => dataPoint.count > 0\n                );\n            }\n            return dataPoints;\n        }\n\n        /**\n         * Sets best left position of a tooltip approaching the proposal x.\n         * @private\n         * @param {DOMElement} tooltip\n         * @param {number} x, left offset proposed\n         */\n        _fixTooltipLeftPosition(tooltip, x) {\n            let left;\n            const tooltipWidth = tooltip.clientWidth;\n            const minLeftAllowed = Math.floor(this.chart.chartArea.left + 2);\n            const maxLeftAllowed = Math.floor(this.chart.chartArea.right - tooltipWidth - 2);\n            x = Math.floor(x);\n            if (x <= maxLeftAllowed) {\n                if (x >= minLeftAllowed) {\n                    left = x;\n                } else {\n                    left = minLeftAllowed;\n                }\n            } else {\n                left = maxLeftAllowed;\n            }\n            tooltip.style.left = left + \"px\";\n        }\n\n        /**\n         * Used to format correctly the values in tooltips and yAxes.\n         * @private\n         * @param {number} value\n         * @returns {string} The value formatted using fieldUtils.format.float\n         */\n        _formatValue(value) {\n            const formatter = fieldUtils.format.float;\n            const measure = this.props.fields[this.props.measure];\n            const formatedValue = formatter(value, measure, FORMAT_OPTIONS);\n            return formatedValue;\n        }\n\n        /**\n         * Determines the initial section of the labels array over which\n         * a dataset has to be completed. The section only depends on the\n         * datasets origins.\n         * @private\n         * @param {number} originIndex\n         * @param {number} defaultLength\n         * @returns {number}\n         */\n        _getDatasetDataLength(originIndex, defaultLength) {\n            if (this.props.mode !== \"pie\" && this.props.comparisonFieldIndex === 0) {\n                return this.dateClasses.dateSets[originIndex].length;\n            }\n            return defaultLength;\n        }\n\n        /**\n         * Determines the dataset to which the data point belongs.\n         * @private\n         * @param {Object} dataPoint\n         * @returns {string}\n         */\n        _getDatasetLabel({ labels, originIndex }) {\n            if (this.props.mode === \"pie\") {\n                return this.props.origins[originIndex];\n            }\n            // ([origin] + second to last groupBys) or measure\n            let datasetLabel = labels.slice(1).join(\"/\");\n            if (this.props.origins.length > 1) {\n                datasetLabel = this.props.origins[originIndex] + (\n                    datasetLabel ? (\"/\" + datasetLabel) : \"\"\n                );\n            }\n            return datasetLabel || this.measureDescription;\n        }\n\n        /**\n         * Returns a DateClasses instance used to manage equivalence of dates.\n         * @private\n         * @param {Object[]} dataPoints\n         * @returns {DateClasses}\n         */\n        _getDateClasses(dataPoints) {\n            const dateSets = this.props.origins.map(() => []);\n            for (const { labels, originIndex } of dataPoints) {\n                dateSets[originIndex].push(labels[this.props.comparisonFieldIndex]);\n            }\n            return new DateClasses(dateSets.map(dateSet => [...new Set(dateSet)]));\n        }\n\n        /**\n         * Returns an object used to style chart elements independently from\n         * the datasets.\n         * @private\n         * @returns {Object}\n         */\n        _getElementOptions() {\n            const elementOptions = {};\n            if (this.props.mode === \"bar\") {\n                elementOptions.rectangle = { borderWidth: 1 };\n            } else if (this.props.mode === \"line\") {\n                elementOptions.line = {\n                    tension: 0,\n                    fill: false,\n                };\n            }\n            return elementOptions;\n        }\n\n        /**\n         * Gets the label over which the data point is.\n         * @private\n         * @param {Object} dataPoint\n         * @returns {Array}\n         */\n        _getLabel({ labels, originIndex }) {\n            const index = this.props.comparisonFieldIndex;\n            if (this.props.mode !== \"pie\") {\n                if (index === 0) {\n                    return [this.dateClasses.dateClass(originIndex, labels[index])];\n                } else {\n                    return labels.slice(0, 1);\n                }\n            } else if (index === 0) {\n                return [\n                    this.dateClasses.dateClass(originIndex, labels[index]),\n                    ...labels.slice(index + 1)\n                ];\n            } else {\n                return labels;\n            }\n        }\n\n        /**\n         * Returns the options used to generate the chart legend.\n         * @private\n         * @param {number} datasetsCount\n         * @returns {Object}\n         */\n        _getLegendOptions(datasetsCount) {\n            const legendOptions = {\n                display: datasetsCount <= MAX_LEGEND_LENGTH,\n                position: \"top\",\n                onHover: this._onlegendHover.bind(this),\n                onLeave: this._onLegendLeave.bind(this),\n            };\n            if (this.props.mode === \"line\") {\n                legendOptions.onClick = this._onLegendClick.bind(this);\n            }\n            if (this.props.mode !== \"pie\") {\n                let referenceColor;\n                if (this.props.mode === \"bar\") {\n                    referenceColor = \"backgroundColor\";\n                } else {\n                    referenceColor = \"borderColor\";\n                }\n                legendOptions.labels = {\n                    generateLabels: chart => {\n                        const { data } = chart;\n                        const labels = data.datasets.map((dataset, index) => {\n                            return {\n                                text: shortenLabel(dataset.label),\n                                fullText: dataset.label,\n                                fillStyle: dataset[referenceColor],\n                                hidden: !chart.isDatasetVisible(index),\n                                lineCap: dataset.borderCapStyle,\n                                lineDash: dataset.borderDash,\n                                lineDashOffset: dataset.borderDashOffset,\n                                lineJoin: dataset.borderJoinStyle,\n                                lineWidth: dataset.borderWidth,\n                                strokeStyle: dataset[referenceColor],\n                                pointStyle: dataset.pointStyle,\n                                datasetIndex: index,\n                            };\n                        });\n                        return labels;\n                    },\n                };\n            } else {\n                const { comparisonFieldIndex } = this.props;\n                legendOptions.labels = {\n                    generateLabels: chart => {\n                        const { data } = chart;\n                        const metaData = data.datasets.map(\n                            (_, index) => chart.getDatasetMeta(index).data\n                        );\n                        const labels = data.labels.map((label, index) => {\n                            const hidden = metaData.some(\n                                data => data[index] && data[index].hidden\n                            );\n                            const fullText = this._relabelling(label, comparisonFieldIndex);\n                            const text = shortenLabel(fullText);\n                            const fillStyle = label === this.noDataLabel ?\n                                DEFAULT_BG :\n                                getColor(index);\n                            return { text, fullText, fillStyle, hidden, index };\n                        });\n                        return labels;\n                    },\n                };\n            }\n            return legendOptions;\n        }\n\n        /**\n         * Determines whether the data are good, and displays an error message\n         * if this is not the case.\n         * @private\n         * @returns {Object | null}\n         */\n        _getNoContentHelper() {\n            if (this.props.mode === \"pie\") {\n                const dataPoints = this.processedDataPoints;\n                const someNegative = dataPoints.some(dataPt => dataPt.value < 0);\n                const somePositive = dataPoints.some(dataPt => dataPt.value > 0);\n                if (someNegative && somePositive) {\n                    return {\n                        title: this.env._t(\"Invalid data\"),\n                        description: [\n                            this.env._t(\"Pie chart cannot mix positive and negative numbers. \"),\n                            this.env._t(\"Try to change your domain to only display positive results\")\n                        ].join(\"\")\n                    };\n                }\n            }\n            return null;\n        }\n\n        /**\n         * Returns the options used to generate the chart axes.\n         * @private\n         * @returns {Object}\n         */\n        _getScaleOptions() {\n            if (this.props.mode === \"pie\") {\n                return {};\n            }\n            const { comparisonFieldIndex } = this.props;\n            const xAxes = [{\n                type: \"category\",\n                scaleLabel: {\n                    display: this.props.processedGroupBy.length && !this.props.isEmbedded,\n                    labelString: this.props.processedGroupBy.length ?\n                        this.props.fields[this.props.processedGroupBy[0].split(\":\")[0]].string :\n                        \"\",\n                },\n                ticks: { callback: label => this._relabelling(label, comparisonFieldIndex) },\n            }];\n            const yAxes = [{\n                type: \"linear\",\n                scaleLabel: {\n                    display: !this.props.isEmbedded,\n                    labelString: this.measureDescription,\n                },\n                ticks: {\n                    callback: value => this._formatValue(value),\n                    suggestedMax: 0,\n                    suggestedMin: 0,\n                },\n            }];\n            return { xAxes, yAxes };\n        }\n\n        /**\n         * Extracts the important information from a tooltipItem generated by\n         * Charts.js (a tooltip item corresponds to a line (different from\n         * measure name) of a tooltip).\n         * @private\n         * @param {Object} item\n         * @param {Object} data\n         * @returns {Object}\n         */\n        _getTooltipItemContent(item, data) {\n            const { comparisonFieldIndex } = this.props;\n            const dataset = data.datasets[item.datasetIndex];\n            const id = item.index;\n            let label = data.labels[item.index];\n            let value;\n            let boxColor;\n            let percentage;\n            if (this.props.mode === \"pie\") {\n                if (label === this.noDataLabel) {\n                    value = this._formatValue(0);\n                } else {\n                    value = this._formatValue(dataset.data[item.index]);\n                    const totalData = dataset.data.reduce((a, b) => a + b, 0);\n                    percentage = totalData && ((dataset.data[item.index] * 100) / totalData).toFixed(2);\n                }\n                label = this._relabelling(label, comparisonFieldIndex, dataset.originIndex);\n                if (this.props.origins.length > 1) {\n                    label = `${dataset.label}/${label}`;\n                }\n                boxColor = dataset.backgroundColor[item.index];\n            } else {\n                label = this._relabelling(label, comparisonFieldIndex, dataset.originIndex);\n                if (\n                    this.props.processedGroupBy.length > 1 ||\n                    this.props.origins.length > 1\n                ) {\n                    label = `${label}/${dataset.label}`;\n                }\n                value = this._formatValue(item.yLabel);\n                boxColor = this.props.mode === \"bar\" ?\n                    dataset.backgroundColor :\n                    dataset.borderColor;\n            }\n            return { id, label, value, boxColor, percentage };\n        }\n\n        /**\n         * This function extracts the information from the data points in\n         * tooltipModel.dataPoints (corresponding to datapoints over a given\n         * label determined by the mouse position) that will be displayed in a\n         * custom tooltip.\n         * @private\n         * @param {Object} tooltipModel see chartjs documentation\n         * @return {Object[]}\n         */\n        _getTooltipItems(tooltipModel) {\n            const { data } = this.chart.config;\n            const sortedDataPoints = sortBy(tooltipModel.dataPoints, \"yLabel\", \"desc\");\n            return sortedDataPoints.map(\n                item => this._getTooltipItemContent(item, data)\n            );\n        }\n\n        /**\n         * Returns the options used to generate chart tooltips.\n         * @private\n         * @returns {Object}\n         */\n        _getTooltipOptions() {\n            const tooltipOptions = {\n                // disable Chart.js tooltips\n                enabled: false,\n                custom: this._customTooltip.bind(this),\n            };\n            if (this.props.mode === \"line\") {\n                tooltipOptions.mode = \"index\";\n                tooltipOptions.intersect = false;\n            }\n            return tooltipOptions;\n        }\n\n        /**\n         * Returns true iff the current graph can be clicked on to redirect to\n         * the list of records.\n         * @private\n         * @returns {boolean}\n         */\n        _isRedirectionEnabled() {\n            return !this.props.disableLinking && this.props.mode !== \"line\";\n        }\n\n        /**\n         * Separates dataPoints coming from the read_group(s) into different\n         * datasets. This function returns the parameters data and labels used\n         * to produce the charts.\n         * @param {Object[]} dataPoints\n         * @returns {Object}\n         */\n        _prepareData(dataPoints) {\n            const labelMap = {};\n            const labels = [];\n            for (const dataPt of dataPoints) {\n                const label = this._getLabel(dataPt);\n                const labelKey = `${dataPt.resId}:${JSON.stringify(label)}`;\n                const index = labelMap[labelKey];\n                if (index === undefined) {\n                    labelMap[labelKey] = dataPt.labelIndex = labels.length;\n                    labels.push(label);\n                } else {\n                    dataPt.labelIndex = index;\n                }\n            }\n\n            // dataPoints --> datasets\n            const datasetsTmp = {};\n            for (const dp of dataPoints) {\n                const datasetLabel = this._getDatasetLabel(dp);\n                if (!(datasetLabel in datasetsTmp)) {\n                    const dataLength = this._getDatasetDataLength(dp.originIndex, labels.length);\n                    datasetsTmp[datasetLabel] = {\n                        data: new Array(dataLength).fill(0),\n                        domain: new Array(dataLength).fill([]),\n                        label: datasetLabel,\n                        originIndex: dp.originIndex,\n                    };\n                }\n                const labelIndex = dp.labelIndex;\n                datasetsTmp[datasetLabel].data[labelIndex] = dp.value;\n                datasetsTmp[datasetLabel].domain[labelIndex] = dp.domain;\n            }\n            // sort by origin\n            const datasets = sortBy(Object.values(datasetsTmp), \"originIndex\");\n            return { datasets, labels };\n        }\n\n        /**\n         * Prepares options for the chart according to the current mode\n         * (= chart type). This function returns the parameter options used to\n         * instantiate the chart.\n         * @private\n         * @param {number} datasetsCount\n         * @returns {Object} the chart options used for the current mode\n         */\n        _prepareOptions(datasetsCount) {\n            const options = {\n                maintainAspectRatio: false,\n                scales: this._getScaleOptions(),\n                legend: this._getLegendOptions(datasetsCount),\n                tooltips: this._getTooltipOptions(),\n                elements: this._getElementOptions(),\n            };\n            if (this._isRedirectionEnabled()) {\n                options.onClick = ev => this._onGraphClicked(ev);\n            }\n            return options;\n        }\n\n        /**\n         * Computes various information from the given props object.\n         * @param {Object} props\n         */\n        _processProps(props) {\n            const filteredDataPoints = this._filterDataPoints(props);\n            this.processedDataPoints = this._sortDataPoints(filteredDataPoints, props);\n            this.noContentHelperData = this._getNoContentHelper(props.mode);\n        }\n\n        /**\n         * Determines how to relabel a label according to a given origin. The\n         * idea is that the getLabel function is in general not invertible but\n         * it is when restricted to the set of dataPoints coming from a same\n         * origin.\n         * @private\n         * @param {Array} label\n         * @param {number} index\n         * @param {Array} [originIndex]\n         * @returns {string}\n         */\n        _relabelling(label, index, originIndex) {\n            if (label === this.noDataLabel || label === this.fakeDataLabel) {\n                return label[0];\n            }\n            if (this.props.mode !== \"pie\" && index === 0) {\n                // here label is an array of length 1 and contains a number\n                return this.dateClasses.representative(label, originIndex) || \"\";\n            } else if (this.props.mode === \"pie\" && index === 0) {\n                // here label is an array of length at least one containing string or numbers\n                const labelCopy = label.slice();\n                let newLabel;\n                if (originIndex === undefined) {\n                    newLabel = this.dateClasses.dateClassMembers(label[index]);\n                } else {\n                    newLabel = this.dateClasses.representative(label[index], originIndex);\n                }\n                labelCopy.splice(index, 1, newLabel);\n                return labelCopy.join(\"/\");\n            }\n            // here label is an array containing strings or numbers.\n            return label.join(\"/\") || this.env._t(\"Total\");\n        }\n\n        /**\n         * Removes all existing tooltips.\n         * @private\n         */\n        _removeTooltips() {\n            if (this.tooltip) {\n                this.tooltip.remove();\n                this.tooltip = null;\n            }\n            if (this.legendTooltip) {\n                this.legendTooltip.remove();\n                this.legendTooltip = null;\n            }\n        }\n\n        /**\n         * Instantiates a Chart (Chart.js lib) to render the graph according to\n         * the current config.\n         * @private\n         */\n        _renderChart() {\n            if (this.noContentHelperData) {\n                return;\n            }\n            if (this.chart) {\n                this.chart.destroy();\n            }\n            const config = this._createConfig();\n            const canvasContext = this.canvasRef.el.getContext(\"2d\");\n            this.chart = new Chart(canvasContext, config);\n            // To perform its animations, ChartJS will perform each animation\n            // step in the next animation frame. The initial rendering itself\n            // is delayed for consistency. We can avoid this by manually\n            // advancing the animation service.\n            Chart.animationService.advance();\n        }\n\n        /**\n         * Sorts datapoints according to the current order (ASC or DESC).\n         * Note: this should be moved to the model at some point.\n         * @private\n         * @param {Object[]} dataPoints\n         * @param {Object} props\n         * @returns {Object[]} sorted dataPoints if orderby set on state\n         */\n        _sortDataPoints(dataPoints, props) {\n            if (\n                props.domains.length === 1 &&\n                props.orderBy &&\n                props.mode !== \"pie\" &&\n                props.processedGroupBy.length\n            ) {\n                // group data by their x-axis value, and then sort datapoints\n                // based on the sum of values by group in ascending/descending order\n                const [groupByFieldName] = props.processedGroupBy[0].split(\":\");\n                const { type } = props.fields[groupByFieldName];\n                const groupedDataPoints = {};\n                for (const dataPt of dataPoints) {\n                    const key = type === \"many2one\" ? dataPt.resId : dataPt.labels[0];\n                    if (!groupedDataPoints[key]) {\n                        groupedDataPoints[key] = [];\n                    }\n                    groupedDataPoints[key].push(dataPt);\n                }\n                const groupTotal = group => group.reduce((sum, { value }) => sum + value, 0);\n                dataPoints = sortBy(\n                    Object.values(groupedDataPoints),\n                    groupTotal,\n                    props.orderBy\n                ).flat();\n            }\n            return dataPoints;\n        }\n\n        //---------------------------------------------------------------------\n        // Handlers\n        //---------------------------------------------------------------------\n\n        /**\n         * @private\n         * @param {MouseEvent} ev\n         */\n        _onGraphClicked(ev) {\n            const [activeElement] = this.chart.getElementAtEvent(ev);\n            if (!activeElement) {\n                return;\n            }\n            const { _datasetIndex, _index } = activeElement;\n            const { domain } = this.chart.data.datasets[_datasetIndex];\n            if (domain) {\n                this.trigger(\"open_view\", { domain: domain[_index] });\n            }\n        }\n\n        /**\n         * Overrides the default legend 'onClick' behaviour. This is done to\n         * remove all existing tooltips right before updating the chart.\n         * @private\n         * @param {MouseEvent} ev\n         * @param {Object} legendItem\n         */\n        _onLegendClick(ev, legendItem) {\n            this._removeTooltips();\n            // Default 'onClick' fallback. See web/static/lib/Chart/Chart.js#15138\n            const index = legendItem.datasetIndex;\n            const meta = this.chart.getDatasetMeta(index);\n            meta.hidden = meta.hidden === null ? !this.chart.data.datasets[index].hidden : null;\n            this.chart.update();\n        }\n\n        /**\n         * If the text of a legend item has been shortened and the user mouse\n         * hovers that item (actually the event type is mousemove), a tooltip\n         * with the item full text is displayed.\n         * @private\n         * @param {MouseEvent} ev\n         * @param {Object} legendItem\n         */\n        _onlegendHover(ev, legendItem) {\n            this.canvasRef.el.style.cursor = \"pointer\";\n            /**\n             * The string legendItem.text is an initial segment of legendItem.fullText.\n             * If the two coincide, no need to generate a tooltip. If a tooltip\n             * for the legend already exists, it is already good and doesn't\n             * need to be recreated.\n             */\n            if (legendItem.text === legendItem.fullText || this.legendTooltip) {\n                return;\n            }\n\n            const rendererTop = this.el.getBoundingClientRect().top;\n\n            this.legendTooltip = Object.assign(document.createElement(\"div\"), {\n                className: \"o_tooltip_legend\",\n                innerText: legendItem.fullText,\n            });\n            this.legendTooltip.style.top = (ev.clientY - rendererTop) + \"px\";\n            this.legendTooltip.style.maxWidth = getMaxWidth(this.chart.chartArea);\n\n            this.containerRef.el.appendChild(this.legendTooltip);\n\n            this._fixTooltipLeftPosition(this.legendTooltip, ev.clientX);\n        }\n\n        /**\n         * If there's a legend tooltip and the user mouse out of the\n         * corresponding legend item, the tooltip is removed.\n         * @private\n         */\n        _onLegendLeave() {\n            this.canvasRef.el.style.cursor = \"\";\n            if (this.legendTooltip) {\n                this.legendTooltip.remove();\n                this.legendTooltip = null;\n            }\n        }\n    }\n\n    GraphRenderer.template = \"web.Legacy.GraphRenderer\";\n    GraphRenderer.props = {\n        arch: {\n            type: Object,\n            shape: {\n                children: { type: Array, element: Object },\n                attrs: Object,\n                tag: { validate: t => t === \"graph\" },\n            },\n        },\n        comparisonFieldIndex: Number,\n        context: Object,\n        dataPoints: { type: Array, element: Object },\n        disableLinking: Boolean,\n        domain: [Array, String],\n        domains: { type: Array, element: [Array, String] },\n        fields: Object,\n        groupBy: { type: Array, element: String },\n        isEmbedded: Boolean,\n        isSample: { type: Boolean, optional: 1 },\n        measure: String,\n        measures: { type: Array, element: Object },\n        mode: { validate: m => [\"bar\", \"line\", \"pie\"].includes(m) },\n        origins: { type: Array, element: String },\n        processedGroupBy: { type: Array, element: String },\n        stacked: Boolean,\n        timeRanges: Object,\n        noContentHelp: { type: String, optional: 1 },\n        orderBy: { type: [String, Boolean], optional: 1 },\n        title: { type: String, optional: 1 },\n        withSearchPanel: { type: Boolean, optional: 1 },\n    };\n\n    return GraphRenderer;\n\n});\n", "odoo.define('web/static/src/js/views/graph/graph_utils', function (require) {\n\"use strict\";\n\nconst { device } = require(\"web.config\");\n\nconst COLORS = [\n    \"#1f77b4\", \"#ff7f0e\", \"#aec7e8\", \"#ffbb78\", \"#2ca02c\", \"#98df8a\", \"#d62728\",\n    \"#ff9896\", \"#9467bd\", \"#c5b0d5\", \"#8c564b\", \"#c49c94\", \"#e377c2\", \"#f7b6d2\",\n    \"#7f7f7f\", \"#c7c7c7\", \"#bcbd22\", \"#dbdb8d\", \"#17becf\", \"#9edae5\",\n];\nconst DEFAULT_BG = \"#d3d3d3\";\n// used to format values in tooltips and yAxes.\nconst FORMAT_OPTIONS = {\n    // allow to decide if utils.human_number should be used\n    humanReadable: value => Math.abs(value) >= 1000,\n    // with the choices below, 1236 is represented by 1.24k\n    minDigits: 1,\n    decimals: 2,\n    // avoid comma separators for thousands in numbers when human_number is used\n    formatterCallback: str => str,\n};\n// hide top legend when too many items for device size\nconst MAX_LEGEND_LENGTH = 4 * Math.max(1, device.size_class);\nconst RGB_REGEX = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i;\n\n/**\n * @param {number} index\n * @returns {string}\n */\nfunction getColor(index) {\n    return COLORS[index % COLORS.length];\n}\n\n/**\n * @param {Object} chartArea\n * @returns {string}\n */\nfunction getMaxWidth({ left, right }) {\n    return Math.floor((right - left) / 1.618) + \"px\";\n}\n\n/**\n * @param {string} hex\n * @param {number} opacity\n * @returns {string}\n */\nfunction hexToRGBA(hex, opacity) {\n    const rgb = RGB_REGEX\n        .exec(hex)\n        .slice(1, 4)\n        .map(n => parseInt(n, 16))\n        .join(\",\");\n    return `rgba(${rgb},${opacity})`;\n}\n\n/**\n * Used to avoid too long legend items.\n * @param {string} label\n * @returns {string} shortened version of the input label\n */\nfunction shortenLabel(label) {\n    // string returned could be wrong if a groupby value contain a \"/\"!\n    const groups = label.split(\"/\");\n    let shortLabel = groups.slice(0, 3).join(\"/\");\n    if (shortLabel.length > 30) {\n        shortLabel = `${shortLabel.slice(0, 30)}...`;\n    } else if (groups.length > 3) {\n        shortLabel = `${shortLabel}/...`;\n    }\n    return shortLabel;\n}\n\nreturn {\n    COLORS,\n    DEFAULT_BG,\n    FORMAT_OPTIONS,\n    MAX_LEGEND_LENGTH,\n    RGB_REGEX,\n    getColor,\n    getMaxWidth,\n    hexToRGBA,\n    shortenLabel,\n};\n\n});\n\n", "odoo.define('web.GraphView', function (require) {\n\"use strict\";\n\n/**\n * The Graph View is responsible to display a graphical (meaning: chart)\n * representation of the current dataset.  As of now, it is currently able to\n * display data in three types of chart: bar chart, line chart and pie chart.\n */\n\nvar AbstractView = require('web.AbstractView');\nvar core = require('web.core');\nvar GraphModel = require('web.GraphModel');\nvar Controller = require('web.GraphController');\nconst GraphRenderer = require(\"web/static/src/js/views/graph/graph_renderer\");\nconst RendererWrapper = require(\"web.RendererWrapper\");\nconst viewRegistry = require(\"web.view_registry\");\n\nvar _t = core._t;\nvar _lt = core._lt;\n\nvar searchUtils = require('web.searchUtils');\nvar GROUPABLE_TYPES = searchUtils.GROUPABLE_TYPES;\n\nvar GraphView = AbstractView.extend({\n    display_name: _lt('Graph'),\n    icon: 'fa-bar-chart',\n    jsLibs: [\n        '/web/static/lib/Chart/Chart.js',\n    ],\n    config: _.extend({}, AbstractView.prototype.config, {\n        Model: GraphModel,\n        Controller: Controller,\n        Renderer: GraphRenderer,\n    }),\n    viewType: 'graph',\n    searchMenuTypes: ['filter', 'groupBy', 'comparison', 'favorite'],\n\n    /**\n     * @override\n     */\n    init: function (viewInfo, params) {\n        this._super.apply(this, arguments);\n\n        const additionalMeasures = params.additionalMeasures || [];\n        let measure;\n        const measures = {};\n        const measureStrings = {};\n        let groupBys = [];\n        const groupableFields = {};\n        this.fields.__count__ = { string: _t(\"Count\"), type: 'integer' };\n\n        this.arch.children.forEach(field => {\n            let fieldName = field.attrs.name;\n            if (fieldName === \"id\") {\n                return;\n            }\n            const interval = field.attrs.interval;\n            if (interval) {\n                fieldName = fieldName + ':' + interval;\n            }\n            if (field.attrs.type === 'measure') {\n                const { string } = this.fields[fieldName];\n                measure = fieldName;\n                measures[fieldName] = {\n                    description: string,\n                    fieldName,\n                    groupNumber: 0,\n                    isActive: false,\n                    itemType: 'measure',\n                };\n            } else {\n                groupBys.push(fieldName);\n            }\n            if (field.attrs.string) {\n                measureStrings[fieldName] = field.attrs.string;\n            }\n        });\n\n        for (const name in this.fields) {\n            const field = this.fields[name];\n            if (name !== 'id' && field.store === true) {\n                if (\n                    ['integer', 'float', 'monetary'].includes(field.type) ||\n                    additionalMeasures.includes(name)\n                ) {\n                    measures[name] = {\n                        description: field.string,\n                        fieldName: name,\n                        groupNumber: 0,\n                        isActive: false,\n                        itemType: 'measure',\n                    };\n                }\n                if (GROUPABLE_TYPES.includes(field.type)) {\n                    groupableFields[name] = field;\n                }\n            }\n        }\n        for (const name in measureStrings) {\n            if (measures[name]) {\n                measures[name].description = measureStrings[name];\n            }\n        }\n\n        // Remove invisible fields from the measures\n        this.arch.children.forEach(field => {\n            let fieldName = field.attrs.name;\n            if (field.attrs.invisible && py.eval(field.attrs.invisible)) {\n                groupBys = groupBys.filter(groupBy => groupBy !== fieldName);\n                if (fieldName in groupableFields) {\n                    delete groupableFields[fieldName];\n                }\n                if (!additionalMeasures.includes(fieldName)) {\n                    delete measures[fieldName];\n                }\n            }\n        });\n\n        const sortedMeasures = Object.values(measures).sort((a, b) => {\n                const descA = a.description.toLowerCase();\n                const descB = b.description.toLowerCase();\n                return descA > descB ? 1 : descA < descB ? -1 : 0;\n            });\n        const countMeasure = {\n            description: _t(\"Count\"),\n            fieldName: '__count__',\n            groupNumber: 1,\n            isActive: false,\n            itemType: 'measure',\n        };\n        this.controllerParams.withButtons = params.withButtons !== false;\n        this.controllerParams.measures = [...sortedMeasures, countMeasure];\n        this.controllerParams.groupableFields = groupableFields;\n        this.controllerParams.title = params.title || this.arch.attrs.string || _t(\"Untitled\");\n        // retrieve form and list view ids from the action to open those views\n        // when the graph is clicked\n        function _findView(views, viewType) {\n            const view = views.find(view => {\n                return view.type === viewType;\n            });\n            return [view ? view.viewID : false, viewType];\n        }\n        this.controllerParams.views = [\n            _findView(params.actionViews, 'list'),\n            _findView(params.actionViews, 'form'),\n        ];\n\n        this.rendererParams.fields = this.fields;\n        this.rendererParams.measures = this.controllerParams.measures;\n        this.rendererParams.title = this.arch.attrs.title; // TODO: use attrs.string instead\n        this.rendererParams.disableLinking = !!JSON.parse(this.arch.attrs.disable_linking || '0');\n\n        this.loadParams.mode = this.arch.attrs.type || 'bar';\n        this.loadParams.orderBy = this.arch.attrs.order;\n        this.loadParams.measure = measure || '__count__';\n        this.loadParams.groupBys = groupBys;\n        this.loadParams.fields = this.fields;\n        this.loadParams.comparisonDomain = params.comparisonDomain;\n        this.loadParams.stacked = this.arch.attrs.stacked !== \"False\";\n    },\n\n     /**\n     *\n     * @override\n     */\n    getRenderer(parent, props) {\n        props = Object.assign(props || {}, this.rendererParams);\n        return new RendererWrapper(null, this.config.Renderer, props);\n    },\n});\n\nviewRegistry.add(\"graph\", GraphView);\nreturn GraphView;\n\n});\n", "/** @odoo-module alias=web.PivotController **/\n\n    /**\n     * Odoo Pivot Table Controller\n     *\n     * This class is the Controller for the pivot table view.  It has to coordinate\n     * the actions coming from the search view (through the update method), from\n     * the renderer, from the model, and from the control panel.\n     *\n     * It can display action buttons in the control panel, to select a different\n     * measure, or to perform some other actions such as download/expand/flip the\n     * view.\n     */\n\n    import AbstractController from '../abstract_controller';\n    import core from 'web.core';\n    import framework from 'web.framework';\n    import session from 'web.session';\n\n    const _t = core._t;\n    const QWeb = core.qweb;\n\n    const PivotController = AbstractController.extend({\n        custom_events: Object.assign({}, AbstractController.prototype.custom_events, {\n            closed_header_click: '_onClosedHeaderClicked',\n            open_view: '_onOpenView',\n            opened_header_click: '_onOpenedHeaderClicked',\n            sort_rows: '_onSortRows',\n            groupby_menu_selection: '_onGroupByMenuSelection',\n        }),\n\n        /**\n         * @override\n         * @param parent\n         * @param model\n         * @param renderer\n         * @param {Object} params\n         */\n        init: function (parent, model, renderer, params) {\n            this._super(...arguments);\n\n            this.disableLinking = params.disableLinking;\n            this.measures = params.measures;\n            this.title = params.title;\n            // views to use in the action triggered when a data cell is clicked\n            this.views = params.views;\n            this.groupSelected = null;\n        },\n        /**\n         * @override\n         */\n        destroy: function () {\n            if (this.$buttons) {\n                // remove jquery's tooltip() handlers\n                this.$buttons.find('button').off();\n            }\n            return this._super(...arguments);\n        },\n\n        //--------------------------------------------------------------------------\n        // Public\n        //--------------------------------------------------------------------------\n\n        /**\n         * Returns the current measures and groupbys, so we can restore the view\n         * when we save the current state in the search view, or when we add it to\n         * the dashboard.\n         *\n         * @override method from AbstractController\n         * @returns {Object}\n         */\n        getOwnedQueryParams: function () {\n            const state = this.model.get({ raw: true });\n            return {\n                context: {\n                    pivot_measures: state.measures,\n                    pivot_column_groupby: state.colGroupBys,\n                    pivot_row_groupby: state.rowGroupBys,\n                }\n            };\n        },\n        /**\n         * Render the buttons according to the PivotView.buttons template and\n         * add listeners on it.\n         * Set this.$buttons with the produced jQuery element\n         *\n         * @override\n         * @param {jQuery} [$node] a jQuery node where the rendered buttons should\n         *   be inserted. $node may be undefined, in which case the PivotView\n         *   does nothing\n         */\n        renderButtons: function ($node) {\n            const context = this._getRenderButtonContext();\n            this.$buttons = $(QWeb.render('PivotView.buttons', context));\n            this.$buttons.click(this._onButtonClick.bind(this));\n            this.$buttons.find('button').tooltip();\n            if ($node) {\n                this.$buttons.appendTo($node);\n            }\n        },\n        /**\n         * @override\n         */\n        updateButtons: function () {\n            if (!this.$buttons) {\n                return;\n            }\n            const state = this.model.get({ raw: true });\n            Object.entries(this.measures).forEach(elt => {\n                const name = elt[0];\n                const isSelected = state.measures.includes(name);\n                this.$buttons.find('.dropdown-item[data-field=\"' + name + '\"]')\n                    .toggleClass('selected', isSelected);\n\n            });\n            const noDataDisplayed = !state.hasData || !state.measures.length;\n            this.$buttons.find('.o_pivot_flip_button').prop('disabled', noDataDisplayed);\n            this.$buttons.find('.o_pivot_expand_button').prop('disabled', noDataDisplayed);\n            this.$buttons.find('.o_pivot_download').prop('disabled', noDataDisplayed);\n        },\n\n        //--------------------------------------------------------------------------\n        // Private\n        //--------------------------------------------------------------------------\n\n        /**\n         * Export the current pivot table data in a xls file. For this, we have to\n         * serialize the current state, then call the server /web/pivot/export_xlsx.\n         * Force a reload before exporting to ensure to export up-to-date data.\n         *\n         * @private\n         */\n        _downloadTable: function () {\n            if (this.model.getTableWidth() > 16384) {\n                this.call('crash_manager', 'show_message', _t(\"For Excel compatibility, data cannot be exported if there are more than 16384 columns.\\n\\nTip: try to flip axis, filter further or reduce the number of measures.\"));\n                framework.unblockUI();\n                return;\n            }\n            const table = this.model.exportData();\n            table.title = this.title;\n            table.model = this.modelName;\n            session.get_file({\n                url: '/web/pivot/export_xlsx',\n                data: { data: JSON.stringify(table) },\n                complete: framework.unblockUI,\n                error: (error) => this.call('crash_manager', 'rpc_error', error),\n            });\n        },\n\n        //--------------------------------------------------------------------------\n        // Handlers\n        //--------------------------------------------------------------------------\n\n        /**\n         * This handler is called when the user clicked on a button in the control\n         * panel.  We then have to react properly: it can either be a change in the\n         * current measures, or a request to flip/expand/download data.\n         *\n         * @private\n         * @param {MouseEvent} ev\n         */\n        _onButtonClick: async function (ev) {\n            const $target = $(ev.target);\n            if ($target.hasClass('o_pivot_flip_button')) {\n                this.model.flip();\n                this.update({}, { reload: false });\n            }\n            if ($target.hasClass('o_pivot_expand_button')) {\n                await this.model.expandAll();\n                this.update({}, { reload: false });\n            }\n            if (ev.target.closest('.o_pivot_measures_list')) {\n                ev.preventDefault();\n                ev.stopPropagation();\n                const field = ev.target.dataset.field;\n                if (field) {\n                    this.update({ measure: field });\n                }\n            }\n            if ($target.hasClass('o_pivot_download')) {\n                this._downloadTable();\n            }\n\n            await this._addIncludedButtons(ev);\n        },\n\n        /**\n         * Declared to be overwritten in includes of pivot controller\n         *\n         * @param {MouseEvent} ev\n         * @returns {Promise<void>}\n         * @private\n         */\n        _addIncludedButtons: async function(ev) {},\n        /**\n         * Get the context of rendering of the buttons\n         *\n         * @returns {Object}\n         * @private\n         */\n        _getRenderButtonContext: function () {\n            return {\n                measures: Object.entries(this.measures)\n                .filter(x => x[0] !== '__count')\n                .sort((a, b) => a[1].string.toLowerCase() > b[1].string.toLowerCase() ? 1 : -1),\n            };\n        },\n        /**\n         *\n         * @private\n         * @param {OdooEvent} ev\n         */\n        _onCloseGroup: function (ev) {\n            this.model.closeGroup(ev.data.groupId, ev.data.type);\n            this.update({}, { reload: false });\n        },\n        /**\n         * @param {CustomEvent} ev\n         * @private\n         * */\n        _onOpenedHeaderClicked: function (ev) {\n            this.model.closeGroup(ev.data.cell.groupId, ev.data.type);\n            this.update({}, { reload: false });\n        },\n        /**\n         * @param {CustomEvent} ev\n         * @private\n         * */\n        _onClosedHeaderClicked: async function (ev) {\n            const cell = ev.data.cell;\n            const groupId = cell.groupId;\n            const type = ev.data.type;\n\n            const group = {\n                rowValues: groupId[0],\n                colValues: groupId[1],\n                type: type\n            };\n\n            const state = this.model.get({ raw: true });\n            const groupValues = type === 'row' ? groupId[0] : groupId[1];\n            const groupBys = type === 'row' ?\n                state.rowGroupBys :\n                state.colGroupBys;\n            this.selectedGroup = group;\n            if (groupValues.length < groupBys.length) {\n                const groupBy = groupBys[groupValues.length];\n                await this.model.expandGroup(this.selectedGroup, groupBy);\n                this.update({}, { reload: false });\n            }\n        },\n        /**\n         * This handler is called when the user selects a groupby in the dropdown menu.\n         *\n         * @private\n         * @param {CustomEvent} ev\n         */\n        _onGroupByMenuSelection: async function (ev) {\n            ev.stopPropagation();\n\n            const { fieldName, interval } = ev.data;\n            let groupBy = fieldName;\n            if (interval) {\n                groupBy = `${groupBy}:${interval}`;\n            }\n            this.model.addGroupBy(groupBy, this.selectedGroup.type);\n            await this.model.expandGroup(this.selectedGroup, groupBy);\n            this.update({}, { reload: false });\n        },\n        /**\n         * @private\n         * @param {CustomEvent} ev\n         */\n        _onOpenView: function (ev) {\n            ev.stopPropagation();\n            const cell = ev.data;\n            if (cell.value === undefined || this.disableLinking) {\n                return;\n            }\n\n            const context = Object.assign({}, this.model.data.context);\n            Object.keys(context).forEach(x => {\n                if (x === 'group_by' || x.startsWith('search_default_')) {\n                    delete context[x];\n                }\n            });\n\n            const group = {\n                rowValues: cell.groupId[0],\n                colValues: cell.groupId[1],\n                originIndex: cell.originIndexes[0]\n            };\n\n            const domain = this.model._getGroupDomain(group);\n\n            this.do_action({\n                type: 'ir.actions.act_window',\n                name: this.title,\n                res_model: this.modelName,\n                views: this.views,\n                view_mode: 'list',\n                target: 'current',\n                context: context,\n                domain: domain,\n            });\n        },\n        /**\n         * @private\n         * @param {CustomEvent} ev\n         */\n        _onSortRows: function (ev) {\n            this.model.sortRows({\n                groupId: ev.data.groupId,\n                measure: ev.data.measure,\n                order: (ev.data.order || 'desc') === 'asc' ? 'desc' : 'asc',\n                originIndexes: ev.data.originIndexes,\n            });\n            this.update({}, { reload: false });\n        },\n    });\n\n    export default PivotController;\n", "/** @odoo-module alias=web.PivotModel **/\n\n/**\n * Pivot Model\n *\n * The pivot model keeps an in-memory representation of the pivot table that is\n * displayed on the screen.  The exact layout of this representation is not so\n * simple, because a pivot table is at its core a 2-dimensional object, but\n * with a 'tree' component: some rows/cols can be expanded so we zoom into the\n * structure.\n *\n * However, we need to be able to manipulate the data in a somewhat efficient\n * way, and to transform it into a list of lines to be displayed by the renderer.\n *\n * Basicaly the pivot table presents aggregated values for various groups of records\n * in one domain. If a comparison is asked for, two domains are considered.\n *\n * Let us consider a simple example and let us fix the vocabulary (let us suppose we are in June 2020):\n * ___________________________________________________________________________________________________________________________________________\n * |                    |   Total                                                                                                             |\n * |                    |_____________________________________________________________________________________________________________________|\n * |                    |   Sale Team 1                         |  Sale Team 2                         |                                      |\n * |                    |_______________________________________|______________________________________|______________________________________|\n * |                    |   Sales total                         |  Sales total                         |  Sales total                         |\n * |                    |_______________________________________|______________________________________|______________________________________|\n * |                    |   May 2020   | June 2020  | Variation |  May 2020   | June 2020  | Variation |  May 2020   | June 2020  | Variation |\n * |____________________|______________|____________|___________|_____________|____________|___________|_____________|____________|___________|\n * | Total              |     85       |     110    |  29.4%    |     40      |    30      |   -25%    |    125      |    140     |     12%   |\n * |    Europe          |     25       |     35     |    40%    |     40      |    30      |   -25%    |     65      |     65     |      0%   |\n * |        Brussels    |      0       |     15     |   100%    |     30      |    30      |     0%    |     30      |     45     |     50%   |\n * |        Paris       |     25       |     20     |   -20%    |     10      |     0      |  -100%    |     35      |     20     |  -42.8%   |\n * |    North America   |     60       |     75     |    25%    |             |            |           |     60      |     75     |     25%   |\n * |        Washington  |     60       |     75     |    25%    |             |            |           |     60      |     75     |     25%   |\n * |____________________|______________|____________|___________|_____________|____________|___________|_____________|____________|___________|\n *\n *\n * META DATA:\n *\n * In the above pivot table, the records have been grouped using the fields\n *\n *      continent_id, city_id\n *\n * for rows and\n *\n *      sale_team_id\n *\n * for columns.\n *\n * The measure is the field 'sales_total'.\n *\n * Two domains are considered: 'May 2020' and 'June 2020'.\n *\n * In the model,\n *\n *      - rowGroupBys is the list [continent_id, city_id]\n *      - colGroupBys is the list [sale_team_id]\n *      - measures is the list [sales_total]\n *      - domains is the list [d1, d2] with d1 and d2 domain expressions\n *          for say sale_date in May 2020 and June 2020, for instance\n *          d1 = [['sale_date', >=, 2020-05-01], ['sale_date', '<=', 2020-05-31]]\n *      - origins is the list ['May 2020', 'June 2020']\n *\n * DATA:\n *\n * Recall that a group is constituted by records (in a given domain)\n * that have the same (raw) values for a list of fields.\n * Thus the group itself is identified by this list and the domain.\n * In comparison mode, the same group (forgetting the domain part or 'originIndex')\n * can be eventually found in the two domains.\n * This defines the way in which the groups are identified or not.\n *\n * In the above table, (forgetting the domain) the following groups are found:\n *\n *      the 'row groups'\n *      - Total\n *      - Europe\n *      - America\n *      - Europe, Brussels\n *      - Europe, Paris\n *      - America, Washington\n *\n *      the 'col groups'\n *\n *      - Total\n *      - Sale Team 1\n *      - Sale Team 2\n *\n *      and all non trivial combinations of row groups and col groups\n *\n *      - Europe, Sale Team 1\n *      - Europe, Brussels, Sale Team 2\n *      - America, Washington, Sale Team 1\n *      - ...\n *\n * The list of fields is created from the concatenation of two lists of fields, the first in\n *\n * [], [f1], [f1, f2], ... [f1, f2, ..., fn]  for [f1, f2, ..., fn] the full list of groupbys\n * (called rowGroupBys) used to create row groups\n *\n * In the example: [], [continent_id], [continent_id, city_id].\n *\n * and the second in\n * [], [g1], [g1, g2], ... [g1, g2, ..., gm]  for [g1, g2, ..., gm] the full list of groupbys\n * (called colGroupBys) used to create col groups.\n *\n * In the example: [], [sale_team_id].\n *\n * Thus there are (n+1)*(m+1) lists of fields possible.\n *\n * In the example: 6 lists possible, namely [],\n *                                          [continent_id], [sale_team_id],\n *                                          [continent_id, sale_team_id], [continent_id, city_id],\n *                                          [continent_id, city_id, sale_team_id]\n *\n * A given list is thus of the form [f1,..., fi, g1,..., gj] or better [[f1,...,fi], [g1,...,gj]]\n *\n * For each list of fields possible and each domain considered, one read_group is done\n * and gives results of the form (an exception for list [])\n *\n * g = {\n *  f1: v1, ..., fi: vi,\n *  g1: w1, ..., gj: wj,\n *  m1: x1, ..., mk: xk,\n *  __count: c,\n *  __domain: d\n * }\n *\n * where v1,...,vi,w1,...,Wj are 'values' for the corresponding fields and\n * m1,...,mk are the fields selected as measures.\n *\n * For example, g = {\n *      continent_id: [1, 'Europe']\n *      sale_team_id: [1, 'Sale Team 1']\n *      sales_count: 25,\n *      __count: 4\n *      __domain: [\n *                  ['sale_date', >=, 2020-05-01], ['sale_date', '<=', 2020-05-31],\n *                  ['continent_id', '=', 1],\n *                  ['sale_team_id', '=', 1]\n *                ]\n * }\n *\n * Thus the above group g is fully determined by [[v1,...,vi], [w1,...,wj]] and the base domain\n * or the corresponding 'originIndex'.\n *\n * When j=0, g corresponds to a row group (or also row header) and is of the form [[v1,...,vi], []] or more simply [v1,...vi]\n * (not forgetting the list [v1,...vi] comes from left).\n * When i=0, g corresponds to a col group (or col header) and is of the form [[], [w1,...,wj]] or more simply [w1,...,wj].\n *\n * A generic group g as above [[v1,...,vi], [w1,...,wj]] corresponds to the two headers [[v1,...,vi], []]\n * and [[], [w1,...,wj]].\n *\n * Here is a description of the data structure manipulated by the pivot model.\n *\n * Five objects contain all the data from the read_groups\n *\n *      - rowGroupTree: contains information on row headers\n *             the nodes correspond to the groups of the form [[v1,...,vi], []]\n *             The root is [[], []].\n *             A node [[v1,...,vl], []] has as direct children the nodes of the form [[v1,...,vl,v], []],\n *             this means that a direct child is obtained by grouping records using the single field fi+1\n *\n *             The structure at each level is of the form\n *\n *             {\n *                  root: {\n *                      values: [v1,...,vl],\n *                      labels: [la1,...,lal]\n *                  },\n *                  directSubTrees: {\n *                      v => {\n *                              root: {\n *                                  values: [v1,...,vl,v]\n *                                  labels: [label1,...,labell,label]\n *                              },\n *                              directSubTrees: {...}\n *                          },\n *                      v' => {...},\n *                      ...\n *                  }\n *             }\n *\n *             (directSubTrees is a Map instance)\n *\n *             In the example, the rowGroupTree is:\n *\n *             {\n *                  root: {\n *                      values: [],\n *                      labels: []\n *                  },\n *                  directSubTrees: {\n *                      1 => {\n *                              root: {\n *                                  values: [1],\n *                                  labels: ['Europe'],\n *                              },\n *                              directSubTrees: {\n *                                  1 => {\n *                                          root: {\n *                                              values: [1, 1],\n *                                              labels: ['Europe', 'Brussels'],\n *                                          },\n *                                          directSubTrees: new Map(),\n *                                  },\n *                                  2 => {\n *                                          root: {\n *                                              values: [1, 2],\n *                                              labels: ['Europe', 'Paris'],\n *                                          },\n *                                          directSubTrees: new Map(),\n *                                  },\n *                              },\n *                          },\n *                      2 => {\n *                              root: {\n *                                  values: [2],\n *                                  labels: ['America'],\n *                              },\n *                              directSubTrees: {\n *                                  3 => {\n *                                          root: {\n *                                              values: [2, 3],\n *                                              labels: ['America', 'Washington'],\n *                                          }\n *                                          directSubTrees: new Map(),\n *                                  },\n *                              },\n *                      },\n *                  },\n *             }\n *\n *      - colGroupTree: contains information on col headers\n *              The same as above with right instead of left\n *\n *      - measurements: contains information on measure values for all the groups\n *\n *              the object keys are of the form JSON.stringify([[v1,...,vi], [w1,...,wj]])\n *              and values are arrays of length equal to number of origins containing objects of the form\n *                  {m1: x1,...,mk: xk}\n *              The structure looks like\n *\n *              {\n *                  JSON.stringify([[], []]): [{m1: x1,...,mk: xk}, {m1: x1',...,mk: xk'},...]\n *                  ....\n *                  JSON.stringify([[v1,...,vi], [w1,...,wj]]): [{m1: y1',...,mk: yk'}, {m1: y1',...,mk: yk'},...],\n *                  ....\n *                  JSON.stringify([[v1,...,vn], [w1,...,wm]]): [{m1: z1',...,mk: zk'}, {m1: z1',...,mk: zk'},...],\n *              }\n *              Thus the structure contains all information for all groups and all origins on measure values.\n *\n *\n *              this.measurments[\"[[], []]\"][0]['foo'] gives the value of the measure 'foo' for the group 'Total' and the\n *              first domain (origin).\n *\n *              In the example:\n *                  {\n *                      \"[[], []]\": [{'sales_total': 125}, {'sales_total': 140}]                      (total/total)\n *                      ...\n *                      \"[[1, 2], [2]]\": [{'sales_total': 10}, {'sales_total': 0}]                   (Europe/Paris/Sale Team 2)\n *                      ...\n *                  }\n *\n *      - counts: contains information on the number of records in each groups\n *              The structure is similar to the above but the arrays contains numbers (counts)\n *      - groupDomains:\n *              The structure is similar to the above but the arrays contains domains\n *\n *      With this light data structures, all manipulation done by the model are eased and redundancies are limited.\n *      Each time a rendering or an export of the data has to be done, the pivot table is generated by the _getTable function.\n */\n\nimport AbstractModel from '../abstract_model';\nimport concurrency from 'web.concurrency';\nimport core from 'web.core';\nimport dataComparisonUtils from 'web.dataComparisonUtils';\nimport Domain from 'web.Domain';\nimport * as mathUtils from '@web/core/utils/arrays';\nimport session from 'web.session';\n\n\nvar _t = core._t;\nvar cartesian = mathUtils.cartesian;\nvar computeVariation = dataComparisonUtils.computeVariation;\nvar sections = mathUtils.sections;\n\nvar PivotModel = AbstractModel.extend({\n    /**\n     * @override\n     * @param {Object} params\n     */\n    init: function () {\n        this._super.apply(this, arguments);\n        this.numbering = {};\n        this.data = null;\n        this._loadDataDropPrevious = new concurrency.DropPrevious();\n    },\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    /**\n     * Add a groupBy to rowGroupBys or colGroupBys according to provided type.\n     *\n     * @param {string} groupBy\n     * @param {'row'|'col'} type\n     */\n    addGroupBy: function (groupBy, type) {\n        if (type === 'row') {\n            this.data.expandedRowGroupBys.push(groupBy);\n        } else {\n            this.data.expandedColGroupBys.push(groupBy);\n        }\n    },\n    /**\n     * Close the group with id given by groupId. A type must be specified\n     * in case groupId is [[], []] (the id of the group 'Total') because this\n     * group is present in both colGroupTree and rowGroupTree.\n     *\n     * @param {Array[]} groupId\n     * @param {'row'|'col'} type\n     */\n    closeGroup: function (groupId, type) {\n        var groupBys;\n        var expandedGroupBys;\n        let keyPart;\n        var group;\n        var tree;\n        if (type === 'row') {\n            groupBys = this.data.rowGroupBys;\n            expandedGroupBys = this.data.expandedRowGroupBys;\n            tree = this.rowGroupTree;\n            group = this._findGroup(this.rowGroupTree, groupId[0]);\n            keyPart = 0;\n        } else {\n            groupBys = this.data.colGroupBys;\n            expandedGroupBys = this.data.expandedColGroupBys;\n            tree = this.colGroupTree;\n            group = this._findGroup(this.colGroupTree, groupId[1]);\n            keyPart = 1;\n        }\n\n        const groupIdPart = groupId[keyPart];\n        const range = groupIdPart.map((_, index) => index);\n        function keep(key) {\n            const idPart = JSON.parse(key)[keyPart];\n            return range.some(index => groupIdPart[index] !== idPart[index]) ||\n                    idPart.length ===  groupIdPart.length;\n        }\n        function omitKeys(object) {\n            const newObject = {};\n            for (const key in object) {\n                if (keep(key)) {\n                    newObject[key] = object[key];\n                }\n            }\n            return newObject;\n        }\n        this.measurements = omitKeys(this.measurements);\n        this.counts = omitKeys(this.counts);\n        this.groupDomains = omitKeys(this.groupDomains);\n\n        group.directSubTrees.clear();\n        delete group.sortedKeys;\n        var newGroupBysLength = this._getTreeHeight(tree) - 1;\n        if (newGroupBysLength <= groupBys.length) {\n            expandedGroupBys.splice(0);\n            groupBys.splice(newGroupBysLength);\n        } else {\n            expandedGroupBys.splice(newGroupBysLength - groupBys.length);\n        }\n    },\n    /**\n     * Reload the view with the current rowGroupBys and colGroupBys\n     * This is the easiest way to expand all the groups that are not expanded\n     *\n     * @returns {Promise}\n     */\n    expandAll: function () {\n        return this._loadData();\n    },\n    /**\n     * Expand a group by using groupBy to split it.\n     *\n     * @param {Object} group\n     * @param {string} groupBy\n     * @returns {Promise}\n     */\n    expandGroup: async function (group, groupBy) {\n        var leftDivisors;\n        var rightDivisors;\n\n        if (group.type === 'row') {\n            leftDivisors = [[groupBy]];\n            rightDivisors = sections(this._getGroupBys().colGroupBys);\n        } else {\n            leftDivisors = sections(this._getGroupBys().rowGroupBys);\n            rightDivisors = [[groupBy]];\n        }\n        var divisors = cartesian(leftDivisors, rightDivisors);\n\n        delete group.type;\n        return this._subdivideGroup(group, divisors);\n    },\n    /**\n     * Export model data in a form suitable for an easy encoding of the pivot\n     * table in excell.\n     *\n     * @returns {Object}\n     */\n    exportData: function () {\n        var measureCount = this.data.measures.length;\n        var originCount = this.data.origins.length;\n\n        var table = this._getTable();\n\n        // process headers\n        var headers = table.headers;\n        var colGroupHeaderRows;\n        var measureRow = [];\n        var originRow = [];\n\n        function processHeader(header) {\n            var inTotalColumn = header.groupId[1].length === 0;\n            return {\n                title: header.title,\n                width: header.width,\n                height: header.height,\n                is_bold: !!header.measure && inTotalColumn\n            };\n        }\n\n        if (originCount > 1) {\n            colGroupHeaderRows = headers.slice(0, headers.length - 2);\n            measureRow = headers[headers.length - 2].map(processHeader);\n            originRow = headers[headers.length - 1].map(processHeader);\n        } else {\n            colGroupHeaderRows = headers.slice(0, headers.length - 1);\n            measureRow = headers[headers.length - 1].map(processHeader);\n        }\n\n        // remove the empty headers on left side\n        colGroupHeaderRows[0].splice(0, 1);\n\n        colGroupHeaderRows = colGroupHeaderRows.map(function (headerRow) {\n            return headerRow.map(processHeader);\n        });\n\n        // process rows\n        var tableRows = table.rows.map(function (row) {\n            return {\n                title: row.title,\n                indent: row.indent,\n                values: row.subGroupMeasurements.map(function (measurement) {\n                    var value = measurement.value;\n                    if (value === undefined) {\n                        value = \"\";\n                    } else if (measurement.originIndexes.length > 1) {\n                        // in that case the value is a variation and a\n                        // number between 0 and 1\n                        value = value * 100;\n                    }\n                    return {\n                        is_bold: measurement.isBold,\n                        value: value,\n                    };\n                }),\n            };\n        });\n\n        return {\n            col_group_headers: colGroupHeaderRows,\n            measure_headers: measureRow,\n            origin_headers: originRow,\n            rows: tableRows,\n            measure_count: measureCount,\n            origin_count: originCount,\n        };\n    },\n    /**\n     * Swap the pivot columns and the rows. It is a synchronous operation.\n     */\n    flip: function () {\n        // swap the data: the main column and the main row\n        var temp = this.rowGroupTree;\n        this.rowGroupTree = this.colGroupTree;\n        this.colGroupTree = temp;\n\n        // we need to update the record metadata: (expanded) row and col groupBys\n        temp = this.data.rowGroupBys;\n        this.data.groupedBy = this.data.colGroupBys;\n        this.data.rowGroupBys = this.data.colGroupBys;\n        this.data.colGroupBys = temp;\n        temp = this.data.expandedColGroupBys;\n        this.data.expandedColGroupBys = this.data.expandedRowGroupBys;\n        this.data.expandedRowGroupBys = temp;\n\n        function twistKey(key) {\n            return JSON.stringify(JSON.parse(key).reverse());\n        }\n\n        function twist(object) {\n            var newObject = {};\n            Object.keys(object).forEach(function (key) {\n                var value = object[key];\n                newObject[twistKey(key)] = value;\n            });\n            return newObject;\n        }\n\n        this.measurements = twist(this.measurements);\n        this.counts = twist(this.counts);\n        this.groupDomains = twist(this.groupDomains);\n    },\n    /**\n     * @override\n     *\n     * @param {Object} [options]\n     * @param {boolean} [options.raw=false]\n     * @returns {Object}\n     */\n    __get: function (options) {\n        options = options || {};\n        var raw = options.raw || false;\n        var groupBys = this._getGroupBys();\n        var state = {\n            colGroupBys: groupBys.colGroupBys,\n            context: this.data.context,\n            domain: this.data.domain,\n            fields: this.fields,\n            hasData: this._hasData(),\n            isSample: this.isSampleModel,\n            measures: this.data.measures,\n            origins: this.data.origins,\n            rowGroupBys: groupBys.rowGroupBys,\n            modelName: this.modelName\n        };\n        if (!raw && state.hasData) {\n            state.table = this._getTable();\n            state.tree = this.rowGroupTree;\n        }\n        return state;\n    },\n    /**\n     * Returns the total number of columns of the pivot table.\n     *\n     * @returns {integer}\n     */\n    getTableWidth: function () {\n        var leafCounts = this._getLeafCounts(this.colGroupTree);\n        return leafCounts[JSON.stringify(this.colGroupTree.root.values)] + 2;\n    },\n    /**\n     * @override\n     *\n     * @param {Object} params\n     * @param {boolean} [params.compare=false]\n     * @param {Object} params.context\n     * @param {Object} params.fields\n     * @param {string[]} [params.groupedBy]\n     * @param {string[]} params.colGroupBys\n     * @param {Array[]} params.domain\n     * @param {string[]} params.measures\n     * @param {string[]} params.rowGroupBys\n     * @param {string} [params.default_order]\n     * @param {string} params.modelName\n     * @param {Object} params.timeRanges\n     * @returns {Promise}\n     */\n    __load: function (params) {\n        this.initialDomain = params.domain;\n        this.initialRowGroupBys = params.context.pivot_row_groupby || params.rowGroupBys;\n        this.defaultGroupedBy = params.groupedBy;\n\n        this.fields = params.fields;\n        this.modelName = params.modelName;\n        const measures = this._processMeasures(params.context.pivot_measures) ||\n                            params.measures.map(m => m);\n        this.data = {\n            expandedRowGroupBys: [],\n            expandedColGroupBys: [],\n            domain: this.initialDomain,\n            context: _.extend({}, session.user_context, params.context),\n            groupedBy: params.context.pivot_row_groupby || params.groupedBy,\n            colGroupBys: params.context.pivot_column_groupby || params.colGroupBys,\n            measures,\n            timeRanges: params.timeRanges,\n        };\n        this._computeDerivedParams();\n\n        this.data.groupedBy = this.data.groupedBy.slice();\n        this.data.rowGroupBys = !_.isEmpty(this.data.groupedBy) ? this.data.groupedBy : this.initialRowGroupBys.slice();\n\n        var defaultOrder = params.default_order && params.default_order.split(' ');\n        if (defaultOrder) {\n            this.data.sortedColumn = {\n                groupId: [[], []],\n                measure: defaultOrder[0],\n                order: defaultOrder[1] ? defaultOrder [1] : 'asc',\n            };\n        }\n        return this._loadData();\n    },\n    /**\n     * @override\n     *\n     * @param {any} handle this parameter is ignored\n     * @param {Object} params\n     * @param {boolean} [params.compare=false]\n     * @param {Object} params.context\n     * @param {string[]} [params.groupedBy]\n     * @param {Array[]} params.domain\n     * @param {string[]} params.groupBy\n     * @param {string[]} params.measures\n     * @param {Object} [params.timeRanges]\n     * @returns {Promise}\n     */\n    __reload: function (handle, params) {\n        var self = this;\n        var oldColGroupBys = this.data.colGroupBys;\n        var oldRowGroupBys = this.data.rowGroupBys;\n        if ('context' in params) {\n            this.data.context = params.context;\n            this.data.colGroupBys = params.context.pivot_column_groupby || this.data.colGroupBys;\n            this.data.groupedBy = params.context.pivot_row_groupby || this.data.groupedBy;\n            this.data.measures = this._processMeasures(params.context.pivot_measures) || this.data.measures;\n            this.defaultGroupedBy = this.data.groupedBy.length ? this.data.groupedBy : this.defaultGroupedBy;\n        }\n        if ('domain' in params) {\n            this.data.domain = params.domain;\n            this.initialDomain = params.domain;\n        } else {\n            this.data.domain = this.initialDomain;\n        }\n        if ('groupBy' in params) {\n            this.data.groupedBy = params.groupBy.length ? params.groupBy : this.defaultGroupedBy;\n        }\n        if ('timeRanges' in params) {\n            this.data.timeRanges = params.timeRanges;\n        }\n        this._computeDerivedParams();\n\n        this.data.groupedBy = this.data.groupedBy.slice();\n        this.data.rowGroupBys = !_.isEmpty(this.data.groupedBy) ? this.data.groupedBy : this.initialRowGroupBys.slice();\n\n        if (!_.isEqual(oldRowGroupBys, self.data.rowGroupBys)) {\n            this.data.expandedRowGroupBys = [];\n        }\n        if (!_.isEqual(oldColGroupBys, self.data.colGroupBys)) {\n            this.data.expandedColGroupBys = [];\n        }\n\n        if ('measure' in params) {\n            return this._toggleMeasure(params.measure);\n        }\n\n        if (!this._hasData()) {\n            return this._loadData();\n        }\n\n        var oldRowGroupTree = this.rowGroupTree;\n        var oldColGroupTree = this.colGroupTree;\n        return this._loadData().then(function () {\n            if (_.isEqual(oldRowGroupBys, self.data.rowGroupBys)) {\n                self._pruneTree(self.rowGroupTree, oldRowGroupTree);\n            }\n            if (_.isEqual(oldColGroupBys, self.data.colGroupBys)) {\n                self._pruneTree(self.colGroupTree, oldColGroupTree);\n            }\n        });\n    },\n    /**\n     * Sort the rows, depending on the values of a given column.  This is an\n     * in-memory sort.\n     *\n     * @param {Object} sortedColumn\n     * @param {number[]} sortedColumn.groupId\n     */\n    sortRows: function (sortedColumn) {\n        var self = this;\n        var colGroupValues = sortedColumn.groupId[1];\n        sortedColumn.originIndexes = sortedColumn.originIndexes || [0];\n        this.data.sortedColumn = sortedColumn;\n\n        var sortFunction = function (tree) {\n            return function (subTreeKey) {\n                var subTree = tree.directSubTrees.get(subTreeKey);\n                var groupIntersectionId = [subTree.root.values, colGroupValues];\n                var value = self._getCellValue(\n                    groupIntersectionId,\n                    sortedColumn.measure,\n                    sortedColumn.originIndexes\n                ) || 0;\n                return sortedColumn.order === 'asc' ? value : -value;\n            };\n        };\n\n        this._sortTree(sortFunction, this.rowGroupTree);\n    },\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    /**\n     * Add labels/values in the provided groupTree. A new leaf is created in\n     * the groupTree with a root object corresponding to the group with given\n     * labels/values.\n     *\n     * @private\n     * @param {Object} groupTree, either this.rowGroupTree or this.colGroupTree\n     * @param {string[]} labels\n     * @param {Array} values\n     */\n    _addGroup: function (groupTree, labels, values) {\n        var tree = groupTree;\n        // we assume here that the group with value value.slice(value.length - 2) has already been added.\n        values.slice(0, values.length - 1).forEach(function (value) {\n            tree = tree.directSubTrees.get(value);\n        });\n        const value = values[values.length - 1];\n        if (tree.directSubTrees.has(value)) {\n            return;\n        }\n        tree.directSubTrees.set(value, {\n            root: {\n                labels: labels,\n                values: values,\n            },\n            directSubTrees: new Map(),\n        });\n    },\n    /**\n     * Compute what should be used as rowGroupBys by the pivot view\n     *\n     * @private\n     * @returns {string[]}\n     */\n    _computeRowGroupBys: function () {\n        return !_.isEmpty(this.data.groupedBy) ? this.data.groupedBy : this.initialRowGroupBys;\n    },\n    /**\n     * Find a group with given values in the provided groupTree, either\n     * this.rowGrouptree or this.colGroupTree.\n     *\n     * @private\n     * @param  {Object} groupTree\n     * @param  {Array} values\n     * @returns {Object}\n     */\n    _findGroup: function (groupTree, values) {\n        var tree = groupTree;\n        values.slice(0, values.length).forEach(function (value) {\n            tree = tree.directSubTrees.get(value);\n        });\n        return tree;\n    },\n    /**\n     * In case originIndex is an array of length 1, thus a single origin\n     * index, returns the given measure for a group determined by the id\n     * groupId and the origin index.\n     * If originIndexes is an array of length 2, we compute the variation\n     * ot the measure values for the groups determined by groupId and the\n     * different origin indexes.\n     *\n     * @private\n     * @param  {Array[]} groupId\n     * @param  {string} measure\n     * @param  {number[]} originIndexes\n     * @returns {number}\n     */\n    _getCellValue: function (groupId, measure, originIndexes) {\n        var self = this;\n        var key = JSON.stringify(groupId);\n        if (!self.measurements[key]) {\n            return;\n        }\n        var values = originIndexes.map(function (originIndex) {\n            return self.measurements[key][originIndex][measure];\n        });\n        if (originIndexes.length > 1) {\n            return computeVariation(values[1], values[0]);\n        } else {\n            return values[0];\n        }\n    },\n    /**\n     * Returns the rowGroupBys and colGroupBys arrays that\n     * are actually used by the pivot view internally\n     * (for read_group or other purpose)\n     *\n     * @private\n     * @returns {Object} with keys colGroupBys and rowGroupBys\n     */\n    _getGroupBys: function () {\n        return {\n            colGroupBys: this.data.colGroupBys.concat(this.data.expandedColGroupBys),\n            rowGroupBys: this.data.rowGroupBys.concat(this.data.expandedRowGroupBys),\n        };\n    },\n    /**\n     * Returns a domain representation of a group\n     *\n     * @private\n     * @param  {Object} group\n     * @param  {Array} group.colValues\n     * @param  {Array} group.rowValues\n     * @param  {number} group.originIndex\n     * @returns {Array[]}\n     */\n    _getGroupDomain: function (group) {\n        var key = JSON.stringify([group.rowValues, group.colValues]);\n        return this.groupDomains[key][group.originIndex];\n    },\n    /**\n     * Returns the group sanitized labels.\n     *\n     * @private\n     * @param  {Object} group\n     * @param  {string[]} groupBys\n     * @returns {string[]}\n     */\n    _getGroupLabels: function (group, groupBys) {\n        var self = this;\n        return groupBys.map(function (groupBy) {\n            return self._sanitizeLabel(group[groupBy], groupBy);\n        });\n    },\n    /**\n     * Returns a promise that returns the annotated read_group results\n     * corresponding to a partition of the given group obtained using the given\n     * rowGroupBy and colGroupBy.\n     *\n     * @private\n     * @param  {Object} group\n     * @param  {string[]} rowGroupBy\n     * @param  {string[]} colGroupBy\n     * @returns {Promise}\n     */\n    _getGroupSubdivision: function (group, rowGroupBy, colGroupBy) {\n        var groupDomain = this._getGroupDomain(group);\n        var measureSpecs = this._getMeasureSpecs();\n        var groupBy = rowGroupBy.concat(colGroupBy);\n        return this._rpc({\n            model: this.modelName,\n            method: 'read_group',\n            context: this.data.context,\n            domain: groupDomain,\n            fields: measureSpecs,\n            groupBy: groupBy,\n            lazy: false,\n        }).then(function (subGroups) {\n            return {\n                group: group,\n                subGroups: subGroups,\n                rowGroupBy: rowGroupBy,\n                colGroupBy: colGroupBy\n            };\n        });\n    },\n    /**\n     * Returns the group sanitized values.\n     *\n     * @private\n     * @param  {Object} group\n     * @param  {string[]} groupBys\n     * @returns {Array}\n     */\n    _getGroupValues: function (group, groupBys) {\n        var self = this;\n        return groupBys.map(function (groupBy) {\n            return self._sanitizeValue(group[groupBy]);\n        });\n    },\n    /**\n     * Returns the leaf counts of each group inside the given tree.\n     *\n     * @private\n     * @param {Object} tree\n     * @returns {Object} keys are group ids\n     */\n    _getLeafCounts: function (tree) {\n        var self = this;\n        var leafCounts = {};\n        var leafCount;\n        if (!tree.directSubTrees.size) {\n            leafCount = 1;\n        } else {\n            leafCount = [...tree.directSubTrees.values()].reduce(\n                function (acc, subTree) {\n                    var subLeafCounts = self._getLeafCounts(subTree);\n                    _.extend(leafCounts, subLeafCounts);\n                    return acc + leafCounts[JSON.stringify(subTree.root.values)];\n                },\n                0\n            );\n        }\n\n        leafCounts[JSON.stringify(tree.root.values)] = leafCount;\n        return leafCounts;\n    },\n    /**\n     * Returns the group sanitized measure values for the measures in\n     * this.data.measures (that migth contain '__count', not really a fieldName).\n     *\n     * @private\n     * @param  {Object} group\n     * @returns {Array}\n     */\n    _getMeasurements: function (group) {\n        var self = this;\n        return this.data.measures.reduce(\n            function (measurements, fieldName) {\n                var measurement = group[fieldName];\n                if (measurement instanceof Array) {\n                    // case field is many2one and used as measure and groupBy simultaneously\n                    measurement = 1;\n                }\n                if (self.fields[fieldName].type === 'boolean' && measurement instanceof Boolean) {\n                    measurement = measurement ? 1 : 0;\n                }\n                if (self.data.origins.length > 1 && !measurement) {\n                    measurement = 0;\n                }\n                measurements[fieldName] = measurement;\n                return measurements;\n            },\n            {}\n        );\n    },\n    /**\n     * Returns a description of the measures row of the pivot table\n     *\n     * @private\n     * @param {Object[]} columns for which measure cells must be generated\n     * @returns {Object[]}\n     */\n    _getMeasuresRow: function (columns) {\n        var self = this;\n        var sortedColumn = this.data.sortedColumn || {};\n        var measureRow = [];\n\n        columns.forEach(function (column) {\n            self.data.measures.forEach(function (measure) {\n                var measureCell = {\n                    groupId: column.groupId,\n                    height: 1,\n                    measure: measure,\n                    title: self.fields[measure].string,\n                    width: 2 * self.data.origins.length - 1,\n                };\n                if (sortedColumn.measure === measure &&\n                    _.isEqual(sortedColumn.groupId, column.groupId)) {\n                    measureCell.order = sortedColumn.order;\n                }\n                measureRow.push(measureCell);\n            });\n        });\n\n        return measureRow;\n    },\n    /**\n     * Returns the list of measure specs associated with data.measures, i.e.\n     * a measure 'fieldName' becomes 'fieldName:groupOperator' where\n     * groupOperator is the value specified on the field 'fieldName' for\n     * the key group_operator.\n     *\n     * @private\n     * @return {string[]}\n     */\n    _getMeasureSpecs: function () {\n        var self = this;\n        return this.data.measures.reduce(\n            function (acc, measure) {\n                if (measure === '__count') {\n                    acc.push(measure);\n                    return acc;\n                }\n                var type = self.fields[measure].type;\n                var groupOperator = self.fields[measure].group_operator;\n                if (type === 'many2one') {\n                    groupOperator = 'count_distinct';\n                }\n                if (groupOperator === undefined) {\n                    throw new Error(\"No aggregate function has been provided for the measure '\" + measure + \"'\");\n                }\n                acc.push(measure + ':' + groupOperator);\n                return acc;\n            },\n            []\n        );\n    },\n    /**\n     * Make sure that the labels of different many2one values are distinguished\n     * by numbering them if necessary.\n     *\n     * @private\n     * @param {Array} label\n     * @param {string} fieldName\n     * @returns {string}\n     */\n    _getNumberedLabel: function (label, fieldName) {\n        var id = label[0];\n        var name = label[1];\n        this.numbering[fieldName] = this.numbering[fieldName] || {};\n        this.numbering[fieldName][name] = this.numbering[fieldName][name] || {};\n        var numbers = this.numbering[fieldName][name];\n        numbers[id] = numbers[id] || _.size(numbers) + 1;\n        return name + (numbers[id] > 1 ? \"  (\" + numbers[id] + \")\" : \"\");\n    },\n    /**\n     * Returns a description of the origins row of the pivot table\n     *\n     * @private\n     * @param {Object[]} columns for which origin cells must be generated\n     * @returns {Object[]}\n     */\n    _getOriginsRow: function (columns) {\n        var self = this;\n        var sortedColumn = this.data.sortedColumn || {};\n        var originRow = [];\n\n        columns.forEach(function (column) {\n            var groupId = column.groupId;\n            var measure = column.measure;\n            var isSorted = sortedColumn.measure === measure &&\n                _.isEqual(sortedColumn.groupId, groupId);\n            var isSortedByOrigin = isSorted && !sortedColumn.originIndexes[1];\n            var isSortedByVariation = isSorted && sortedColumn.originIndexes[1];\n\n            self.data.origins.forEach(function (origin, originIndex) {\n                var originCell = {\n                    groupId: groupId,\n                    height: 1,\n                    measure: measure,\n                    originIndexes: [originIndex],\n                    title: origin,\n                    width: 1,\n                };\n                if (isSortedByOrigin && sortedColumn.originIndexes[0] === originIndex) {\n                    originCell.order = sortedColumn.order;\n                }\n                originRow.push(originCell);\n\n                if (originIndex > 0) {\n                    var variationCell = {\n                        groupId: groupId,\n                        height: 1,\n                        measure: measure,\n                        originIndexes: [originIndex - 1, originIndex],\n                        title: _t('Variation'),\n                        width: 1,\n                    };\n                    if (isSortedByVariation && sortedColumn.originIndexes[1] === originIndex) {\n                        variationCell.order = sortedColumn.order;\n                    }\n                    originRow.push(variationCell);\n                }\n\n            });\n        });\n\n        return originRow;\n    },\n\n    /**\n     * Returns a description of the pivot table.\n     *\n     * @private\n     * @returns {Object}\n     */\n    _getTable: function () {\n        var headers = this._getTableHeaders();\n        return {\n            headers: headers,\n            rows: this._getTableRows(this.rowGroupTree, headers[headers.length - 1]),\n        };\n    },\n    /**\n     * Returns the list of header rows of the pivot table: the col group rows\n     * (depending on the col groupbys), the measures row and optionnaly the\n     * origins row (if there are more than one origins).\n     *\n     * @private\n     * @returns {Object[]}\n     */\n    _getTableHeaders: function () {\n        var colGroupBys = this._getGroupBys().colGroupBys;\n        var height = colGroupBys.length + 1;\n        var measureCount = this.data.measures.length;\n        var originCount = this.data.origins.length;\n        var leafCounts = this._getLeafCounts(this.colGroupTree);\n        var headers = [];\n        var measureColumns = []; // used to generate the measure cells\n\n        // 1) generate col group rows (total row + one row for each col groupby)\n        var colGroupRows = (new Array(height)).fill(0).map(function () {\n            return [];\n        });\n        // blank top left cell\n        colGroupRows[0].push({\n            height: height + 1 + (originCount > 1 ? 1 : 0), // + measures rows [+ origins row]\n            title: \"\",\n            width: 1,\n        });\n\n        // col groupby cells with group values\n        /**\n         * Recursive function that generates the header cells corresponding to\n         * the groups of a given tree.\n         *\n         * @param {Object} tree\n         */\n        function generateTreeHeaders(tree, fields) {\n            var group = tree.root;\n            var rowIndex = group.values.length;\n            var row = colGroupRows[rowIndex];\n            var groupId = [[], group.values];\n            var isLeaf = !tree.directSubTrees.size;\n            var leafCount = leafCounts[JSON.stringify(tree.root.values)];\n            var cell = {\n                groupId: groupId,\n                height: isLeaf ? (colGroupBys.length + 1 - rowIndex) : 1,\n                isLeaf: isLeaf,\n                isFolded: isLeaf && colGroupBys.length > group.values.length,\n                label: rowIndex === 0 ? undefined : fields[colGroupBys[rowIndex - 1].split(':')[0]].string,\n                title: group.labels[group.labels.length - 1] || _t('Total'),\n                width: leafCount * measureCount * (2 * originCount - 1),\n            };\n            row.push(cell);\n            if (isLeaf) {\n                measureColumns.push(cell);\n            }\n\n            [...tree.directSubTrees.values()].forEach(function (subTree) {\n                generateTreeHeaders(subTree, fields);\n            });\n        }\n\n        generateTreeHeaders(this.colGroupTree, this.fields);\n        // blank top right cell for 'Total' group (if there is more that one leaf)\n        if (leafCounts[JSON.stringify(this.colGroupTree.root.values)] > 1) {\n            var groupId = [[], []];\n            var totalTopRightCell = {\n                groupId: groupId,\n                height: height,\n                title: \"\",\n                width: measureCount * (2 * originCount - 1),\n            };\n            colGroupRows[0].push(totalTopRightCell);\n            measureColumns.push(totalTopRightCell);\n        }\n        headers = headers.concat(colGroupRows);\n\n        // 2) generate measures row\n        var measuresRow = this._getMeasuresRow(measureColumns);\n        headers.push(measuresRow);\n\n        // 3) generate origins row if more than one origin\n        if (originCount > 1) {\n            headers.push(this._getOriginsRow(measuresRow));\n        }\n\n        return headers;\n    },\n    /**\n     * Returns the list of body rows of the pivot table for a given tree.\n     *\n     * @private\n     * @param {Object} tree\n     * @param {Object[]} columns\n     * @returns {Object[]}\n     */\n    _getTableRows: function (tree, columns) {\n        var self = this;\n\n        var rows = [];\n        var group = tree.root;\n        var rowGroupId = [group.values, []];\n        var title = group.labels[group.labels.length - 1] || _t('Total');\n        var indent = group.labels.length;\n        var isLeaf = !tree.directSubTrees.size;\n        var rowGroupBys = this._getGroupBys().rowGroupBys;\n\n        var subGroupMeasurements = columns.map(function (column) {\n            var colGroupId = column.groupId;\n            var groupIntersectionId = [rowGroupId[0], colGroupId[1]];\n            var measure = column.measure;\n            var originIndexes = column.originIndexes || [0];\n\n            var value = self._getCellValue(groupIntersectionId, measure, originIndexes);\n\n            var measurement = {\n                groupId: groupIntersectionId,\n                originIndexes: originIndexes,\n                measure: measure,\n                value: value,\n                isBold: !groupIntersectionId[0].length || !groupIntersectionId[1].length,\n            };\n            return measurement;\n        });\n\n        rows.push({\n            title: title,\n            label: indent === 0 ? undefined : this.fields[rowGroupBys[indent - 1].split(':')[0]].string,\n            groupId: rowGroupId,\n            indent: indent,\n            isLeaf: isLeaf,\n            isFolded: isLeaf && rowGroupBys.length > group.values.length,\n            subGroupMeasurements: subGroupMeasurements\n        });\n\n        var subTreeKeys = tree.sortedKeys || [...tree.directSubTrees.keys()];\n        subTreeKeys.forEach(function (subTreeKey) {\n            var subTree = tree.directSubTrees.get(subTreeKey);\n            rows = rows.concat(self._getTableRows(subTree, columns));\n        });\n\n        return rows;\n    },\n    /**\n     * returns the height of a given groupTree\n     *\n     * @private\n     * @param  {Object} tree, a groupTree\n     * @returns {number}\n     */\n    _getTreeHeight: function (tree) {\n        var subTreeHeights = [...tree.directSubTrees.values()].map(this._getTreeHeight.bind(this));\n        return Math.max(0, Math.max.apply(null, subTreeHeights)) + 1;\n    },\n    /**\n     * @private\n     * @returns {boolean}\n     */\n    _hasData: function () {\n        return (this.counts[JSON.stringify([[], []])] || []).some(function (count) {\n            return count > 0;\n        });\n    },\n    /**\n     * @override\n     */\n    _isEmpty() {\n        return !this._hasData();\n    },\n    /**\n     * Initilize/Reinitialize this.rowGroupTree, colGroupTree, measurements,\n     * counts and subdivide the group 'Total' as many times it is necessary.\n     * A first subdivision with no groupBy (divisors.slice(0, 1)) is made in\n     * order to see if there is data in the intersection of the group 'Total'\n     * and the various origins. In case there is none, nonsupplementary rpc\n     * will be done (see the code of subdivideGroup).\n     * Once the promise resolves, this.rowGroupTree, colGroupTree,\n     * measurements, counts are correctly set.\n     *\n     * @private\n     * @return {Promise}\n     */\n    _loadData: function () {\n        var self = this;\n\n        this.rowGroupTree = { root: { labels: [], values: [] }, directSubTrees: new Map() };\n        this.colGroupTree = { root: { labels: [], values: [] }, directSubTrees: new Map() };\n        this.measurements = {};\n        this.counts = {};\n\n        var key = JSON.stringify([[], []]);\n        this.groupDomains = {};\n        this.groupDomains[key] = this.data.domains.slice(0);\n\n\n        var group = { rowValues: [], colValues: [] };\n        var groupBys = this._getGroupBys();\n        var leftDivisors = sections(groupBys.rowGroupBys);\n        var rightDivisors = sections(groupBys.colGroupBys);\n        var divisors = cartesian(leftDivisors, rightDivisors);\n\n        return this._subdivideGroup(group, divisors.slice(0, 1)).then(function () {\n            return self._subdivideGroup(group, divisors.slice(1));\n        });\n    },\n    /**\n     * Extract the information in the read_group results (groupSubdivisions)\n     * and develop this.rowGroupTree, colGroupTree, measurements, counts, and\n     * groupDomains.\n     * If a column needs to be sorted, the rowGroupTree corresponding to the\n     * group is sorted.\n     *\n     * @private\n     * @param  {Object} group\n     * @param  {Object[]} groupSubdivisions\n     */\n    _prepareData: function (group, groupSubdivisions) {\n        var self = this;\n\n        var groupRowValues = group.rowValues;\n        var groupRowLabels = [];\n        var rowSubTree = this.rowGroupTree;\n        var root;\n        if (groupRowValues.length) {\n            // we should have labels information on hand! regretful!\n            rowSubTree = this._findGroup(this.rowGroupTree, groupRowValues);\n            root = rowSubTree.root;\n            groupRowLabels = root.labels;\n        }\n\n        var groupColValues = group.colValues;\n        var groupColLabels = [];\n        if (groupColValues.length) {\n            root = this._findGroup(this.colGroupTree, groupColValues).root;\n            groupColLabels = root.labels;\n        }\n\n        groupSubdivisions.forEach(function (groupSubdivision) {\n            groupSubdivision.subGroups.forEach(function (subGroup) {\n\n                var rowValues = groupRowValues.concat(self._getGroupValues(subGroup, groupSubdivision.rowGroupBy));\n                var rowLabels = groupRowLabels.concat(self._getGroupLabels(subGroup, groupSubdivision.rowGroupBy));\n\n                var colValues = groupColValues.concat(self._getGroupValues(subGroup, groupSubdivision.colGroupBy));\n                var colLabels = groupColLabels.concat(self._getGroupLabels(subGroup, groupSubdivision.colGroupBy));\n\n                if (!colValues.length && rowValues.length) {\n                    self._addGroup(self.rowGroupTree, rowLabels, rowValues);\n                }\n                if (colValues.length && !rowValues.length) {\n                    self._addGroup(self.colGroupTree, colLabels, colValues);\n                }\n\n                var key = JSON.stringify([rowValues, colValues]);\n                var originIndex = groupSubdivision.group.originIndex;\n\n                if (!(key in self.measurements)) {\n                    self.measurements[key] = self.data.origins.map(function () {\n                        return self._getMeasurements({});\n                    });\n                }\n                self.measurements[key][originIndex] = self._getMeasurements(subGroup);\n\n                if (!(key in self.counts)) {\n                    self.counts[key] = self.data.origins.map(function () {\n                        return 0;\n                    });\n                }\n                self.counts[key][originIndex] = subGroup.__count;\n\n                if (!(key in self.groupDomains)) {\n                    self.groupDomains[key] = self.data.origins.map(function () {\n                        return Domain.FALSE_DOMAIN;\n                    });\n                }\n                // if __domain is not defined this means that we are in the\n                // case where\n                // groupSubdivision.rowGroupBy = groupSubdivision.rowGroupBy = []\n                if (subGroup.__domain) {\n                    self.groupDomains[key][originIndex] = subGroup.__domain;\n                }\n            });\n        });\n\n        if (this.data.sortedColumn) {\n            this.sortRows(this.data.sortedColumn, rowSubTree);\n        }\n    },\n    /**\n     * In the preview implementation of the pivot view (a.k.a. version 2),\n     * the virtual field used to display the number of records was named\n     * __count__, whereas __count is actually the one used in xml. So\n     * basically, activating a filter specifying __count as measures crashed.\n     * Unfortunately, as __count__ was used in the JS, all filters saved as\n     * favorite at that time were saved with __count__, and not __count.\n     * So in order the make them still work with the new implementation, we\n     * handle both __count__ and __count.\n     *\n     * This function replaces in the given array of measures occurences of\n     * '__count__' by '__count'.\n     *\n     * @private\n     * @param {Array[string] || undefined} measures\n     * @returns {Array[string] || undefined}\n     */\n    _processMeasures: function (measures) {\n        if (measures) {\n            return _.map(measures, function (measure) {\n                return measure === '__count__' ? '__count' : measure;\n            });\n        }\n    },\n    /**\n     * Determine this.data.domains and this.data.origins from\n     * this.data.domain and this.data.timeRanges;\n     *\n     * @private\n     */\n    _computeDerivedParams: function () {\n        const { range, rangeDescription, comparisonRange, comparisonRangeDescription } = this.data.timeRanges;\n        if (range) {\n            this.data.domains = [this.data.domain.concat(comparisonRange), this.data.domain.concat(range)];\n            this.data.origins = [comparisonRangeDescription, rangeDescription];\n        } else {\n            this.data.domains = [this.data.domain];\n            this.data.origins = [\"\"];\n        }\n    },\n    /**\n     * Make any group in tree a leaf if it was a leaf in oldTree.\n     *\n     * @private\n     * @param {Object} tree\n     * @param {Object} oldTree\n     */\n    _pruneTree: function (tree, oldTree) {\n        if (!oldTree.directSubTrees.size) {\n            tree.directSubTrees.clear();\n            delete tree.sortedKeys;\n            return;\n        }\n        var self = this;\n        [...tree.directSubTrees.keys()].forEach(function (subTreeKey) {\n            var subTree = tree.directSubTrees.get(subTreeKey);\n            if (!oldTree.directSubTrees.has(subTreeKey)) {\n                subTree.directSubTrees.clear();\n                delete subTreeKey.sortedKeys;\n            } else {\n                var oldSubTree = oldTree.directSubTrees.get(subTreeKey);\n                self._pruneTree(subTree, oldSubTree);\n            }\n        });\n    },\n    /**\n     * Toggle the active state for a given measure, then reload the data\n     * if this turns out to be necessary.\n     *\n     * @param {string} fieldName\n     * @returns {Promise}\n     */\n    _toggleMeasure: function (fieldName) {\n        var index = this.data.measures.indexOf(fieldName);\n        if (index !== -1) {\n            this.data.measures.splice(index, 1);\n            // in this case, we already have all data in memory, no need to\n            // actually reload a lesser amount of information\n            return Promise.resolve();\n        } else {\n            this.data.measures.push(fieldName);\n        }\n        return this._loadData();\n    },\n    /**\n     * Extract from a groupBy value a label.\n     *\n     * @private\n     * @param  {any} value\n     * @param  {string} groupBy\n     * @returns {string}\n     */\n    _sanitizeLabel: function (value, groupBy) {\n        var fieldName = groupBy.split(':')[0];\n        if (value === false) {\n            return _t(\"Undefined\");\n        }\n        if (value instanceof Array) {\n            return this._getNumberedLabel(value, fieldName);\n        }\n        if (fieldName && this.fields[fieldName] && (this.fields[fieldName].type === 'selection')) {\n            var selected = _.where(this.fields[fieldName].selection, { 0: value })[0];\n            return selected ? selected[1] : value;\n        }\n        return value;\n    },\n    /**\n     * Extract from a groupBy value the raw value of that groupBy (discarding\n     * a label if any)\n     *\n     * @private\n     * @param {any} value\n     * @returns {any}\n     */\n    _sanitizeValue: function (value) {\n        if (value instanceof Array) {\n            return value[0];\n        }\n        return value;\n    },\n    /**\n     * Get all partitions of a given group using the provided list of divisors\n     * and enrich the objects of this.rowGroupTree, colGroupTree,\n     * measurements, counts.\n     *\n     * @private\n     * @param {Object} group\n     * @param {Array[]} divisors\n     * @returns\n     */\n    _subdivideGroup: function (group, divisors) {\n        var self = this;\n\n        var key = JSON.stringify([group.rowValues, group.colValues]);\n\n        var proms = this.data.origins.reduce(\n            function (acc, origin, originIndex) {\n                // if no information on group content is available, we fetch data.\n                // if group is known to be empty for the given origin,\n                // we don't need to fetch data fot that origin.\n                if (!self.counts[key] || self.counts[key][originIndex] > 0) {\n                    var subGroup = {\n                        rowValues: group.rowValues,\n                        colValues: group.colValues,\n                        originIndex: originIndex\n                    };\n                    divisors.forEach(function (divisor) {\n                        acc.push(self._getGroupSubdivision(subGroup, divisor[0], divisor[1]));\n                    });\n                }\n                return acc;\n            },\n            []\n        );\n        return this._loadDataDropPrevious.add(Promise.all(proms)).then(function (groupSubdivisions) {\n            if (groupSubdivisions.length) {\n                self._prepareData(group, groupSubdivisions);\n            }\n        });\n    },\n    /**\n     * Sort recursively the subTrees of tree using sortFunction.\n     * In the end each node of the tree has its direct children sorted\n     * according to the criterion reprensented by sortFunction.\n     *\n     * @private\n     * @param  {Function} sortFunction\n     * @param  {Object} tree\n     */\n    _sortTree: function (sortFunction, tree) {\n        var self = this;\n        tree.sortedKeys = _.sortBy([...tree.directSubTrees.keys()], sortFunction(tree));\n        [...tree.directSubTrees.values()].forEach(function (subTree) {\n            self._sortTree(sortFunction, subTree);\n        });\n    },\n});\n\nexport default PivotModel;\n", "/** @odoo-module alias=web.PivotRenderer **/\n\n    import { useEffect } from \"@web/core/utils/hooks\";\n    import OwlAbstractRenderer from '../abstract_renderer_owl';\n    import field_utils from 'web.field_utils';\n    import { DEFAULT_INTERVAL, INTERVAL_OPTIONS, getIntervalOptions } from 'web.searchUtils';\n\n    const { Component, hooks } = owl;\n    const { useExternalListener, useState } = hooks;\n\n    class PivotCustomGroupByItem extends Component {\n        constructor() {\n            super(...arguments);\n            this.canBeOpened = true;\n            this.state = useState({ fieldName: this.props.fields[0].name });\n        }\n\n        //---------------------------------------------------------------------\n        // Handlers\n        //---------------------------------------------------------------------\n\n        /**\n         * @private\n         */\n        onApply() {\n            const { fieldName } = this.state;\n            const { type } = this.props.fields.find(f => f.name === fieldName);\n            let interval = null;\n            if (['date', 'datetime'].includes(type)) {\n                interval = DEFAULT_INTERVAL;\n            }\n            this.trigger('groupby-menu-selection', { fieldName, interval, custom: true });\n            this.state.open = false;\n        }\n    }\n\n    PivotCustomGroupByItem.template = \"web.CustomGroupByItem\";\n    PivotCustomGroupByItem.props = { fields: Array };\n\n    export class PivotGroupByMenu extends Component {\n\n        constructor() {\n            super(...arguments);\n            this.intervalOptions = INTERVAL_OPTIONS;\n            this.openedSubMenus = {};\n        }\n\n        //---------------------------------------------------------------------\n        // Getters\n        //---------------------------------------------------------------------\n\n        /**\n         * @override\n         */\n        get items() {\n            let items = this.props.fields;\n            if (this.props.hasSearchArchGroupBys) {\n                items = this.props.searchModel.get('filters', f => f.type === 'groupBy');\n                let groupNumber = 1 + Math.max(...items.map(g => g.groupNumber), 0);\n                for (const [_, customGroupBy] of this.props.customGroupBys) {\n                    customGroupBy.groupNumber = groupNumber++;\n                    items.push(customGroupBy);\n                }\n            }\n            return items.map((item) => ({\n                ...item,\n                id: item.id || item.name,\n                fieldName: item.fieldName || item.name,\n                description: item.description || item.string,\n                isActive: false,\n                options:\n                    item.options || [\"date\", \"datetime\"].includes(item.type)\n                        ? getIntervalOptions()\n                        : undefined,\n            }));\n        }\n\n        //---------------------------------------------------------------------\n        // Handlers\n        //---------------------------------------------------------------------\n\n        /**\n         * @param {string} fieldName\n         * @param {string|null} interval\n        */\n        _onClickMenuGroupBy(fieldName, interval) {\n            this.trigger('groupby-menu-selection', { fieldName, interval });\n        }\n\n        _toggleMenu(id) {\n            this.openedSubMenus[id] = !this.openedSubMenus[id];\n            this.render();\n        }\n    }\n\n    PivotGroupByMenu.template = \"web.legacy.PivotGroupByMenu\";\n    PivotGroupByMenu.components = { PivotCustomGroupByItem };\n    PivotGroupByMenu.props = {\n        customGroupBys: Map,\n        fields: Object,\n        hasSearchArchGroupBys: Boolean,\n        searchModel: true,\n    };\n\n    /**\n     * Here is a basic example of the structure of the Pivot Table:\n     *\n     * \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n     * \u2502                         \u2502 - web.PivotHeader                           \u2502                 \u2502\n     * \u2502                         \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524                 \u2502\n     * \u2502                         \u2502 + web.PivotHeader    \u2502 + web.PivotHeader    \u2502                 \u2502\n     * \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n     * \u2502                         \u2502 web.PivotMeasure     \u2502 web.PivotMeasure     \u2502                 \u2502\n     * \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n     * \u2502 \u2500 web.PivotHeader       \u2502                      \u2502                      \u2502                 \u2502\n     * \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n     * \u2502    + web.PivotHeader    \u2502                      \u2502                      \u2502                 \u2502\n     * \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n     * \u2502    + web.PivotHeader    \u2502                      \u2502                      \u2502                 \u2502\n     * \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n     *\n     */\n\n    class PivotRenderer extends OwlAbstractRenderer {\n        /**\n         * @override\n         * @param {boolean} props.disableLinking Disallow opening records by clicking on a cell\n         * @param {Object} props.widgets Widgets defined in the arch\n         */\n        constructor() {\n            super(...arguments);\n            this.sampleDataTargets = ['table'];\n            this.state = useState({\n                activeNodeHeader: {\n                    groupId: false,\n                    isXAxis: false,\n                    click: false\n                },\n            });\n\n            const searchArchGroupBys = this.props.searchModel.get(\n                'filters',\n                f => f.type === 'groupBy' && !f.custom\n            );\n            // searchArchGroupBys is not an array when the control panel model\n            // extension is not installed (e.g. in an embedded pivot view)\n            this.hasSearchArchGroupBys = Boolean(searchArchGroupBys && searchArchGroupBys.length);\n            this.customGroupBys = new Map();\n\n            useEffect(() => this._updateTooltip());\n            useExternalListener(window, 'click', this._resetState);\n        }\n\n        //----------------------------------------------------------------------\n        // Private\n        //----------------------------------------------------------------------\n\n        /**\n         * Get the formatted value of the cell\n         *\n         * @private\n         * @param {Object} cell\n         * @returns {string} Formatted value\n         */\n        _getFormattedValue(cell) {\n            const type = this.props.widgets[cell.measure] ||\n                (this.props.fields[cell.measure].type === 'many2one' ? 'integer' : this.props.fields[cell.measure].type);\n            const formatter = field_utils.format[type];\n            return formatter(cell.value, this.props.fields[cell.measure]);\n        }\n\n        /**\n         * Get the formatted variation of a cell\n         *\n         * @private\n         * @param {Object} cell\n         * @returns {string} Formatted variation\n         */\n        _getFormattedVariation(cell) {\n            const value = cell.value;\n            return isNaN(value) ? '-' : field_utils.format.percentage(value, this.props.fields[cell.measure]);\n        }\n\n        /**\n         * Retrieves the padding of a left header\n         *\n         * @private\n         * @param {Object} cell\n         * @returns {Number} Padding\n         */\n        _getPadding(cell) {\n            return 5 + cell.indent * 30;\n        }\n\n        /**\n         * Reset the state of the node.\n         *\n         * @private\n         */\n        _resetState() {\n            // This check is used to avoid the destruction of the dropdown.\n            // The click on the header bubbles to window in order to hide\n            // all the other dropdowns (in this component or other components).\n            // So we need isHeaderClicked to cancel this behaviour.\n            if (this.isHeaderClicked) {\n                this.isHeaderClicked = false;\n                return;\n            }\n            this.state.activeNodeHeader = {\n                groupId: false,\n                isXAxis: false,\n                click: false\n            };\n        }\n\n        /**\n         * Configure the tooltips on the headers.\n         *\n         * @private\n         */\n        _updateTooltip() {\n            $(this.el).find('.o_pivot_header_cell_opened, .o_pivot_header_cell_closed').tooltip();\n        }\n\n        //----------------------------------------------------------------------\n        // Handlers\n        //----------------------------------------------------------------------\n\n        /**\n         * @private\n         * @param {OwlEvent} ev\n         */\n        _onGroupByMenuSelection(ev) {\n            if (this.hasSearchArchGroupBys) {\n                const { custom, fieldName } = ev.detail;\n                if (custom && !this.customGroupBys.has(fieldName)) {\n                    const field = this.props.groupableFields.find(g => g.fieldName === fieldName)\n                    this.customGroupBys.set(fieldName, field);\n                }\n            }\n        }\n\n        /**\n         * Handles a click on a header node\n         *\n         * @private\n         * @param {Object} cell\n         * @param {string} type col or row\n         */\n        _onHeaderClick(cell, type) {\n            const groupValues = cell.groupId[type === 'col' ? 1 : 0];\n            const groupByLength = type === 'col' ? this.props.colGroupBys.length : this.props.rowGroupBys.length;\n            if (cell.isLeaf && groupValues.length >= groupByLength) {\n                this.isHeaderClicked = true;\n                this.state.activeNodeHeader = {\n                    groupId: cell.groupId,\n                    isXAxis: type === 'col',\n                    click: 'leftClick'\n                };\n            }\n            this.trigger(cell.isLeaf ? 'closed_header_click' : 'opened_header_click', { cell, type });\n        }\n\n        /**\n         * Hover the column in which the mouse is.\n         *\n         * @private\n         * @param {MouseEvent} ev\n         */\n        _onMouseEnter(ev) {\n            var index = [...ev.currentTarget.parentNode.children].indexOf(ev.currentTarget);\n            if (ev.currentTarget.tagName === 'TH') {\n                index += 1;\n            }\n            this.el.querySelectorAll('td:nth-child(' + (index + 1) + ')').forEach(elt => elt.classList.add('o_cell_hover'));\n        }\n\n        /**\n         * Remove the hover on the columns.\n         *\n         * @private\n         */\n        _onMouseLeave() {\n            this.el.querySelectorAll('.o_cell_hover').forEach(elt => elt.classList.remove('o_cell_hover'));\n        }\n    }\n\n    PivotRenderer.template = 'web.legacy.PivotRenderer';\n    PivotRenderer.components = { PivotGroupByMenu };\n\n    export default PivotRenderer;\n", "/** @odoo-module alias=web.PivotView **/\n\n    /**\n     * The Pivot View is a view that represents data in a 'pivot grid' form. It\n     * aggregates data on 2 dimensions and displays the result, allows the user to\n     * 'zoom in' data.\n     */\n\n    import AbstractView from '../abstract_view';\n    import config from 'web.config';\n    import core from 'web.core';\n    import PivotModel from 'web.PivotModel';\n    import PivotController from 'web.PivotController';\n    import PivotRenderer from './pivot_renderer';\n    import RendererWrapper from 'web.RendererWrapper';\n    import { sortBy } from 'web.utils';\n    import viewRegistry from \"web.view_registry\";\n\n    const _t = core._t;\n    const _lt = core._lt;\n\n    import * as searchUtils from 'web.searchUtils';\n    const GROUPABLE_TYPES = searchUtils.GROUPABLE_TYPES;\n\n    const PivotView = AbstractView.extend({\n        display_name: _lt('Pivot'),\n        icon: 'fa-table',\n        config: Object.assign({}, AbstractView.prototype.config, {\n            Model: PivotModel,\n            Controller: PivotController,\n            Renderer: PivotRenderer,\n        }),\n        viewType: 'pivot',\n        searchMenuTypes: ['filter', 'groupBy', 'comparison', 'favorite'],\n\n        /**\n         * @override\n         * @param {Object} params\n         * @param {Array} params.additionalMeasures\n         */\n        init: function (viewInfo, params) {\n            this._super.apply(this, arguments);\n\n            const activeMeasures = []; // Store the defined active measures\n            const colGroupBys = []; // Store the defined group_by used on cols\n            const rowGroupBys = []; // Store the defined group_by used on rows\n            const measures = {}; // All the available measures\n            const groupableFields = {}; // The fields which can be used to group data\n            const widgets = {}; // Wigdets defined in the arch\n            const additionalMeasures = params.additionalMeasures || [];\n\n            this.fields.__count = { string: _t(\"Count\"), type: \"integer\" };\n\n            //Compute the measures and the groupableFields\n            Object.keys(this.fields).forEach(name => {\n                const field = this.fields[name];\n                if (name !== 'id' && field.store === true) {\n                    if (['integer', 'float', 'monetary'].includes(field.type) || additionalMeasures.includes(name)) {\n                        measures[name] = field;\n                    }\n                    if (GROUPABLE_TYPES.includes(field.type)) {\n                        groupableFields[name] = Object.assign({\n                            description: field.string,\n                            fieldName: name,\n                            fieldType: field.type,\n                            name,\n                        }, field);\n                    }\n                }\n            });\n            measures.__count = { string: _t(\"Count\"), type: \"integer\" };\n\n\n            this.arch.children.forEach(field => {\n                let name = field.attrs.name;\n                // Remove invisible fields from the measures if not in additionalMeasures\n                if (field.attrs.invisible && py.eval(field.attrs.invisible)) {\n                    if (name in groupableFields) {\n                        delete groupableFields[name];\n                    }\n                    if (!additionalMeasures.includes(name)) {\n                        delete measures[name];\n                        return;\n                    }\n                }\n                if (field.attrs.interval) {\n                    name += ':' + field.attrs.interval;\n                }\n                if (field.attrs.widget) {\n                    widgets[name] = field.attrs.widget;\n                }\n                // add active measures to the measure list.  This is very rarely\n                // necessary, but it can be useful if one is working with a\n                // functional field non stored, but in a model with an overrided\n                // read_group method.  In this case, the pivot view could work, and\n                // the measure should be allowed.  However, be careful if you define\n                // a measure in your pivot view: non stored functional fields will\n                // probably not work (their aggregate will always be 0).\n                if (field.attrs.type === 'measure' && !(name in measures)) {\n                    measures[name] = this.fields[name];\n                }\n                if (field.attrs.string && name in measures) {\n                    measures[name].string = field.attrs.string;\n                }\n                if (field.attrs.type === 'measure' || 'operator' in field.attrs) {\n                    activeMeasures.push(name);\n                    measures[name] = this.fields[name];\n                }\n                if (field.attrs.type === 'col') {\n                    colGroupBys.push(name);\n                }\n                if (field.attrs.type === 'row') {\n                    rowGroupBys.push(name);\n                }\n            });\n            if ((!activeMeasures.length) || this.arch.attrs.display_quantity) {\n                activeMeasures.splice(0, 0, '__count');\n            }\n\n            this.loadParams.measures = activeMeasures;\n            this.loadParams.colGroupBys = config.device.isMobile ? [] : colGroupBys;\n            this.loadParams.rowGroupBys = rowGroupBys;\n            this.loadParams.fields = this.fields;\n            this.loadParams.default_order = params.default_order || this.arch.attrs.default_order;\n\n            const disableLinking = !!(this.arch.attrs.disable_linking &&\n                                        JSON.stringify(this.arch.attrs.disable_linking));\n\n            this.rendererParams.widgets = widgets;\n            this.rendererParams.disableLinking = disableLinking;\n            const { searchModel } = this.controllerParams;\n            this.rendererParams.searchModel = searchModel;\n            this.rendererParams.groupableFields = sortBy(Object.values(groupableFields), (f) => f.description);\n\n            this.controllerParams.disableLinking = disableLinking;\n            this.controllerParams.title = params.title || this.arch.attrs.string || _t(\"Untitled\");\n            this.controllerParams.measures = measures;\n\n            // retrieve form and list view ids from the action to open those views\n            // when a data cell of the pivot view is clicked\n            this.controllerParams.views = [\n                _findView(params.actionViews, 'list'),\n                _findView(params.actionViews, 'form'),\n            ];\n\n            function _findView(views, viewType) {\n                const view = views.find(view => {\n                    return view.type === viewType;\n                });\n                return [view ? view.viewID : false, viewType];\n            }\n        },\n\n        /**\n         *\n         * @override\n         */\n        getRenderer(parent, state) {\n            state = Object.assign(state || {}, this.rendererParams);\n            return new RendererWrapper(parent, this.config.Renderer, state);\n        },\n    });\n    viewRegistry.add(\"pivot\", PivotView);\n\n    export default PivotView;\n", "/** @odoo-module **/\n\nimport config from \"web.config\";\nimport PivotRenderer from \"@web/legacy/js/views/pivot/pivot_renderer\";\nimport { PivotGroupByMenu } from \"@web/legacy/js/views/pivot/pivot_renderer\";\nimport { patch } from \"web.utils\";\n\nif (config.device.isMobile) {\n    patch(PivotRenderer.prototype, \"pivot_mobile\", {\n        /**\n         * Do not compute the tooltip on mobile\n         * @override\n         */\n        _updateTooltip() {},\n\n        /**\n         * @override\n         */\n        _getPadding(cell) {\n            return 5 + cell.indent * 5;\n        },\n    });\n\n    patch(PivotGroupByMenu.prototype, \"pivot_mobile\", {\n        /**\n         * @override\n         */\n        _onClickMenuGroupBy(fieldName, interval, ev) {\n            if (!ev.currentTarget.classList.contains(\"o_pivot_field_selection\")) {\n                this._super(...arguments);\n            } else {\n                ev.stopPropagation();\n            }\n        },\n    });\n}\n", "odoo.define('web_map.MapController', function (require) {\n\"use strict\";\n\nconst AbstractController = require('web.AbstractController');\nconst core = require('web.core');\nconst qweb = core.qweb;\n\nconst MapController = AbstractController.extend({\n    custom_events: _.extend({}, AbstractController.prototype.custom_events, {\n        'pin_clicked': '_onPinClick',\n        'get_itinerary_clicked': '_onGetItineraryClicked',\n        'open_clicked': '_onOpenClicked',\n        'pager_changed': '_onPagerChanged',\n        'coordinate_fetched': '_onCoordinateFetched',\n    }),\n\n    /**\n     * @constructor\n     */\n    init: function (parent, model, renderer, params) {\n        this._super.apply(this, arguments);\n        this.actionName = params.actionName;\n    },\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    /**\n     * @override\n     * @param {jQuery} [$node]\n     */\n    renderButtons: function ($node) {\n        this.$buttons = $(qweb.render(\"web_map.legacy.buttons\"), { widget: this });\n        this._updateGoogleMapUrl();\n        this.$buttons.appendTo($node);\n    },\n    /**\n     * @override\n     */\n    update: async function () {\n        await this._super(...arguments);\n        this._updatePaging();\n        this._updateGoogleMapUrl();\n    },\n    /**\n     * When the records dataset is updated, the URL to Google Maps need to be updated as well\n     * to reflect the new recordset.\n     * This will redirect the user to the displayed records even if he filters them using the search bar.\n     *\n     * @private\n     */\n    _updateGoogleMapUrl: function () {\n        var url = 'https://www.google.com/maps/dir/?api=1';\n        if (this.model.data.records.length) {\n            url += '&waypoints=';\n            var all_coord = this.model.data.records.filter((record) => record.partner && record.partner.partner_latitude && record.partner.partner_longitude);\n            _.uniq(all_coord, function (record) { return record.partner.partner_latitude + '_' + record.partner.partner_longitude; })\n                .forEach((record) => {\n                    url += record.partner.partner_latitude + ',' + record.partner.partner_longitude + '|';\n                });\n            url = url.slice(0, -1);\n        }\n        this.$buttons.find('a.btn.btn-primary').attr('href', url);\n    },\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    /**\n     * Return the params (currentMinimum, limit and size) to pass to the pager,\n     * according to the current state.\n     *\n     * @private\n     * @returns {Object}\n     */\n    _getPagingInfo: function () {\n        const state = this.model.get();\n        return {\n            currentMinimum: state.offset + 1,\n            limit: state.limit,\n            size: state.count,\n        };\n    },\n\n    //--------------------------------------------------------------------------\n    // Handlers\n    //--------------------------------------------------------------------------\n\n    /**\n     * @private\n     * @param {OdooEvent} ev\n     */\n    _onCoordinateFetched: function (ev) {\n        ev.stopPropagation();\n        this.update({}, { reload: false });\n    },\n    /**\n     * Redirects to google maps with all the records' coordinates.\n     *\n     * @private\n     * @param {MouseEvent} ev\n     */\n    _onGetItineraryClicked: function (ev) {\n        window.open(`https://www.google.com/maps/dir/?api=1&destination=${ev.data.lat},${ev.data.lon}`);\n    },\n    /**\n     * Redirects to views when clicked on open button in marker popup.\n     *\n     * @private\n     * @param {MouseEvent} ev\n     */\n    _onOpenClicked: function (ev) {\n        if (ev.data.ids.length > 1) {\n            this.do_action({\n                type: 'ir.actions.act_window',\n                name: this.actionName,\n                views: [[false, 'list'], [false, 'form']],\n                res_model: this.modelName,\n                domain: [['id', 'in', ev.data.ids]],\n            });\n        } else {\n            this.trigger_up('switch_view', {\n                view_type: 'form',\n                res_id: ev.data.ids[0],\n                mode: 'readonly',\n                model: this.modelName\n            });\n        }\n    },\n    /**\n     * @private\n     * @param {OdooEvent} ev\n     */\n    async _onPagerChanged(ev) {\n        const { currentMinimum, limit } = ev.data;\n        await this.reload({ limit, offset: currentMinimum - 1 });\n    },\n});\n\nreturn MapController;\n});\n", "odoo.define('web_map.MapModel', function (require) {\n\"use strict\";\n\nconst AbstractModel = require('web.AbstractModel');\nconst session = require('web.session');\nconst core = require('web.core');\nconst _t = core._t;\n\nconst MapModel = AbstractModel.extend({\n    // Used in _openStreetMapAPIAsync to add delay between coordinates fetches\n    // We need this delay to not get banned from OSM.\n    COORDINATE_FETCH_DELAY: 1000,\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    /**\n     * @constructor\n     */\n    init: function () {\n        this._super.apply(this, arguments);\n        this.data = {};\n        this.data.mapBoxToken = session.map_box_token;\n    },\n    __get: function () {\n        return this.data;\n    },\n    __load: function (params) {\n        this.data.count = 0;\n        this.data.offset = 0;\n        this.data.limit = params.limit;\n        this.partnerToCache = [];\n        this.partnerIds = [];\n        this.resPartnerField = params.resPartnerField;\n        this.model = params.modelName;\n        this.context = params.context;\n        this.fields = params.fieldNames;\n        this.fieldsInfo = params.fieldsInfo;\n        this.domain = params.domain;\n        this.params = params;\n        this.orderBy = params.orderBy;\n        this.routing = params.routing;\n        this.numberOfLocatedRecords = 0;\n        this.coordinateFetchingTimeoutHandle = undefined;\n        this.data.shouldUpdatePosition = true;\n        this.data.fetchingCoordinates = false;\n        this.data.groupBy = params.groupedBy.length ? params.groupedBy[0] : false;\n        return this._fetchData();\n    },\n    __reload: function (handle, params) {\n        const options = params || {};\n        this.partnerToCache = [];\n        this.partnerIds = [];\n        this.numberOfLocatedRecords = 0;\n        this.data.shouldUpdatePosition = true;\n        this.data.fetchingCoordinates = false;\n        if (this.coordinateFetchingTimeoutHandle !== undefined) {\n            clearInterval(this.coordinateFetchingTimeoutHandle);\n            this.coordinateFetchingTimeoutHandle = undefined;\n        }\n        if (options.domain !== undefined) {\n            this.domain = options.domain;\n        }\n        if (options.limit !== undefined) {\n            this.data.limit = options.limit;\n        }\n        if (options.offset !== undefined) {\n            this.data.offset = options.offset;\n        }\n        if (options.groupBy !== undefined && options.groupBy[0] !== this.data.groupBy) {\n            this.data.groupBy = options.groupBy.length ? options.groupBy[0] : false;\n        }\n        return this._fetchData();\n    },\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    /**\n     * Adds the corresponding partner to a record.\n     *\n     * @private\n     */\n    _addPartnerToRecord: function () {\n        this.data.records.forEach((record) => {\n            this.data.partners.forEach((partner) => {\n                let recordPartnerId;\n                if (this.model === \"res.partner\" && this.resPartnerField === \"id\") {\n                    recordPartnerId = record.id;\n                } else {\n                    recordPartnerId = record[this.resPartnerField][0];\n                }\n\n                if (recordPartnerId == partner.id) {\n                    record.partner = partner;\n                    this.numberOfLocatedRecords++;\n                }\n            });\n        });\n    },\n    /**\n     * The partner's coordinates should be between -90 <= latitude <= 90 and -180 <= longitude <= 180.\n     *\n     * @private\n     * @param {Object} partner\n     * @param {float} partner.partner_latitude latitude of the partner\n     * @param {float} partner.partner_longitude longitude of the partner\n     * @returns {boolean}\n     */\n    _checkCoordinatesValidity: function (partner) {\n        if (partner.partner_latitude && partner.partner_longitude &&\n            partner.partner_latitude >= -90 && partner.partner_latitude <= 90 &&\n            partner.partner_longitude >= -180 && partner.partner_longitude <= 180) {\n            return true;\n        }\n        return false;\n    },\n    /**\n     * This function convert the addresses to coordinates using the mapbox API.\n     *\n     * @private\n     * @param {Object} record this object contains the record fetched from the database.\n     * @returns {Promise<result>} result.query contains the query the the api received\n     *      result.features contains results in descendant order of relevance\n     */\n    _fetchCoordinatesFromAddressMB: function (record) {\n        const address = encodeURIComponent(record.contact_address_complete);\n        const token = this.data.mapBoxToken;\n        const encodedUrl = `https://api.mapbox.com/geocoding/v5/mapbox.places/${address}.json?access_token=${token}&cachebuster=1552314159970&autocomplete=true`;\n        return new Promise((resolve, reject) => {\n            $.get(encodedUrl).then(resolve).catch(reject);\n        });\n    },\n    /**\n     * This function convert the addresses to coordinates using the openStreetMap api.\n     *\n     * @private\n     * @param {Object} record this object contains the record fetched from the database.\n     * @returns {Promise<result>} result is an array that contains the result in descendant order of relevance\n     *      result[i].lat is the latitude of the converted address\n     *      result[i].lon is the longitude of the converted address\n     *      result[i].importance is a float that the relevance of the result the closer the float is to one the best it is.\n     */\n    _fetchCoordinatesFromAddressOSM: function (record) {\n        const address = encodeURIComponent(record.contact_address_complete.replace('/', ' '));\n        const encodedUrl = `https://nominatim.openstreetmap.org/search/${address}?format=jsonv2`;\n        return new Promise(function (resolve, reject) {\n            $.get(encodedUrl).then(resolve).catch(reject);\n        });\n    },\n    /**\n     * Handles the case of an empty map.\n     * Handles the case where the model is res_partner.\n     * Fetches the records according to the model given in the arch.\n     * If the records has no partner_id field it is sliced from the array.\n     *\n     * @private\n     * @return {Promise}\n     */\n    _fetchData: async function () {\n        //case of empty map\n        if (!this.resPartnerField) {\n            this.data.recordGroups = [];\n            this.data.records = [];\n            this.data.routeInfo = { routes: [] };\n            return;\n        }\n        const results = await this._fetchRecordData();\n        this.data.records = results.records;\n        this.data.count = results.length;\n        if (this.data.groupBy) {\n            this.data.recordGroups = this._getRecordGroups();\n        } else {\n            this.data.recordGroups = {};\n        }\n\n        this.partnerIds = [];\n        if (this.model === \"res.partner\" && this.resPartnerField === \"id\") {\n            this.data.records.forEach((record) => {\n                this.partnerIds.push(record.id);\n                record.partner_id = [record.id];\n            });\n        } else {\n            this._fillPartnerIds(this.data.records);\n        }\n\n        this.partnerIds = _.uniq(this.partnerIds);\n        return this._partnerFetching(this.partnerIds);\n    },\n    /**\n     * Fetch the records for a given model.\n     *\n     * @private\n     * @returns {Promise<results>}\n     */\n    async _fetchRecordData() {\n        const groupBy = this.data.groupBy ? this.data.groupBy.split(':')[0] : false;\n        const results = await this._rpc({\n            route: '/web/dataset/search_read',\n            model: this.model,\n            context: this.context,\n            fields: groupBy ?\n                this.fields.concat(groupBy) :\n                this.fields,\n            domain: this.domain,\n            orderBy: this.orderBy,\n            limit: this.data.limit,\n            offset: this.data.offset\n        })\n        if (results && groupBy && [\"one2many\", \"many2many\"].includes(this.fieldsInfo[groupBy].type)) {\n            const ids = new Set(results.records.flatMap((record) => record[groupBy]));\n            const groupbyRecords = await this._rpc({\n                method: 'name_get',\n                model: this.fieldsInfo[groupBy].relation,\n                context: this.context,\n                args: [[...ids]],\n            })\n            const labelPerRecordId = Object.fromEntries(groupbyRecords);\n            for (const record of results.records) {\n                record[groupBy] = record[groupBy].map(\n                    val =>\n                        val && val in labelPerRecordId\n                            ? [val, labelPerRecordId[val]]\n                            : false\n                );\n            }\n        }\n        return results;\n    },\n    /**\n     * @private\n     * @returns {Object} the fetched records grouped by the groupBy field.\n     */\n    _getRecordGroups: function () {\n        const [fieldName, subGroup] = this.data.groupBy.split(':');\n        const dateGroupFormats = {\n            year: 'YYYY',\n            quarter: '[Q]Q YYYY',\n            month: 'MMMM YYYY',\n            week: '[W]WW YYYY',\n            day: 'DD MMM YYYY',\n        };\n        const groups = {};\n        for (const record of this.data.records) {\n            const vals = [\"one2many\", \"many2many\"].includes(this.fieldsInfo[fieldName].type)\n                ? record[fieldName] : [record[fieldName]];\n\n            for(const val of vals){\n                let id, name;\n                if (['date', 'datetime'].includes(this.fieldsInfo[fieldName].type)) {\n                    const date = moment(val);\n                    id = name = date.format(dateGroupFormats[subGroup]);\n                } else {\n                    id = Array.isArray(val) ? val[0] : val;\n                    name = Array.isArray(val) ? val[1] : val;\n                }\n                if (!groups[id]) {\n                    groups[id] = {\n                        name,\n                        records: [],\n                    };\n                }\n                groups[id].records.push(record);\n            }\n        }\n        return groups;\n    },\n    /**\n     * @private\n     * @param {Number[]} ids contains the ids from the partners\n     * @returns {Promise}\n     */\n    _fetchRecordsPartner: function (ids) {\n        return this._rpc({\n            model: 'res.partner',\n            method: 'search_read',\n            fields: ['contact_address_complete', 'partner_latitude', 'partner_longitude'],\n            domain: [['contact_address_complete', '!=', 'False'], ['id', 'in', ids]],\n        });\n    },\n    /**\n     * Fetch the route from the mapbox api.\n     *\n     * @private\n     * @returns {Promise<results>}\n     *      results.geometry.legs[i] contains one leg (i.e: the trip between two markers).\n     *      results.geometry.legs[i].steps contains the sets of coordinates to follow to reach a point from an other.\n     *      results.geometry.legs[i].distance: the distance in meters to reach the destination\n     *      results.geometry.legs[i].duration the duration of the leg\n     *      results.geometry.coordinates contains the sets of coordinates to go from the first to the last marker without the notion of waypoint\n     */\n    _fetchRoute: function () {\n        const coordinatesParam = this.data.records\n            .filter(record => record.partner.partner_latitude && record.partner.partner_longitude)\n            .map(record => record.partner.partner_longitude + ',' + record.partner.partner_latitude);\n        const address = encodeURIComponent(coordinatesParam.join(';'));\n        const token = this.data.mapBoxToken;\n        const encodedUrl = `https://api.mapbox.com/directions/v5/mapbox/driving/${address}?access_token=${token}&steps=true&geometries=geojson`;\n        return new Promise(function (resolve, reject) {\n            $.get(encodedUrl).then(resolve).catch(reject);\n        });\n    },\n    /**\n     * @private\n     * @param {Object[]} records the records that are going to be filtered\n     * @returns {Object[]} Array of records that contains a partner_id\n     */\n    _fillPartnerIds: function (records) {\n        return records.forEach(record => {\n            if (record[this.resPartnerField]) {\n                this.partnerIds.push(record[this.resPartnerField][0]);\n            }\n        });\n    },\n    /**\n     * Converts a MapBox error message into a custom translatable one.\n     *\n     * @private\n     * @param {string} message\n     */\n    _getErrorMessage: function (message) {\n        const ERROR_MESSAGES = {\n            'Too many coordinates; maximum number of coordinates is 25': _t(\"Too many routing points (maximum 25)\"),\n            'Route exceeds maximum distance limitation': _t(\"Some routing points are too far apart\"),\n            'Too Many Requests': _t(\"Too many requests, try again in a few minutes\"),\n        };\n        return ERROR_MESSAGES[message];\n    },\n    /**\n     * Handles the case where the selected api is MapBox.\n     * Iterates on all the partners and fetches their coordinates when they're not set.\n     *\n     * @private\n     * @return {Promise<routeResult> | Promise<>} if there's more than 2 located records and the routing option is activated it returns a promise that fetches the route\n     *      resultResult is an object that contains the computed route\n     *      or if either of these conditions are not respected it returns an empty promise\n     */\n    _maxBoxAPI: function () {\n        const promises = [];\n        this.data.partners.forEach(partner => {\n            if (partner.contact_address_complete && (!partner.partner_latitude || !partner.partner_longitude)) {\n                promises.push(this._fetchCoordinatesFromAddressMB(partner).then(coordinates => {\n                    if (coordinates.features.length) {\n                        partner.partner_longitude = coordinates.features[0].geometry.coordinates[0];\n                        partner.partner_latitude = coordinates.features[0].geometry.coordinates[1];\n                        this.partnerToCache.push(partner);\n                    }\n                }));\n            } else if (!this._checkCoordinatesValidity(partner)) {\n                partner.partner_latitude = undefined;\n                partner.partner_longitude = undefined;\n            }\n        });\n        return Promise.all(promises).then(() => {\n            this.data.routeInfo = { routes: [] };\n            if (this.numberOfLocatedRecords > 1 && this.routing && !this.data.groupBy) {\n                return this._fetchRoute().then(routeResult => {\n                    if (routeResult.routes) {\n                        this.data.routeInfo = routeResult;\n                    } else {\n                        this.data.routingError = this._getErrorMessage(routeResult.message);\n                    }\n                });\n            } else {\n                return Promise.resolve();\n            }\n        });\n    },\n    /**\n     * Handles the displaying of error message according to the error.\n     *\n     * @private\n     * @param {Object} err contains the error returned by the requests\n     * @param {Number} err.status contains the status_code of the failed http request\n     */\n    _mapBoxErrorHandling: function (err) {\n        switch (err.status) {\n            case 401:\n                this.displayNotification({\n                    title: _t('Token invalid'),\n                    message: _t('The view has switched to another provider but functionalities will be limited'),\n                    type: 'danger',\n                });\n                break;\n            case 403:\n                this.displayNotification({\n                    title: _t('Unauthorized connection'),\n                    message: _t('The view has switched to another provider but functionalities will be limited'),\n                    type: 'danger',\n                });\n                break;\n            case 422:   // Max. addresses reached\n            case 429:   // Max. requests reached\n                this.data.routingError = this._getErrorMessage(err.responseJSON.message);\n                break;\n            case 500:\n                this.displayNotification({\n                    title: _t('MapBox servers unreachable'),\n                    message: _t('The view has switched to another provider but functionalities will be limited'),\n                    type: 'danger',\n                });\n        }\n    },\n    /**\n     * Notifies the fetched coordinates to server and controller.\n     *\n     * @private\n     */\n    _notifyFetchedCoordinate: function () {\n        this._writeCoordinatesUsers();\n        this.data.shouldUpdatePosition = false;\n        this.trigger_up('coordinate_fetched');\n    },\n    /**\n     * Calls (without awaiting) _openStreetMapAPIAsync with a delay of 1000ms\n     * to not get banned from openstreetmap's server.\n     *\n     * Tests should patch this function to wait for coords to be fetched.\n     *\n     * @see _openStreetMapAPIAsync\n     * @private\n     * @return {Promise}\n     */\n    _openStreetMapAPI: function () {\n        this._openStreetMapAPIAsync();\n        return Promise.resolve();\n    },\n    /**\n     * Handles the case where the selected api is open street map.\n     * Iterates on all the partners and fetches their coordinates when they're not set.\n     *\n     * @private\n     * @returns {Promise}\n     */\n    _openStreetMapAPIAsync: function () {\n        // Group partners by address to reduce address list\n        const addressPartnerMap = new Map();\n        for (const partner of this.data.partners) {\n            if (partner.contact_address_complete && (!partner.partner_latitude || !partner.partner_longitude)) {\n                if (!addressPartnerMap.has(partner.contact_address_complete)) {\n                    addressPartnerMap.set(partner.contact_address_complete, []);\n                }\n                addressPartnerMap.get(partner.contact_address_complete).push(partner);\n                partner.fetchingCoordinate = true;\n            } else if (!this._checkCoordinatesValidity(partner)) {\n                partner.partner_latitude = undefined;\n                partner.partner_longitude = undefined;\n            }\n        }\n\n        // `fetchingCoordinates` is used to display the \"fetching banner\"\n        // We need to check if there are coordinates to fetch before reload the\n        // view to prevent flickering\n        this.data.fetchingCoordinates = addressPartnerMap.size > 0;\n        const fetch = async () => {\n            const partnersList = Array.from(addressPartnerMap.values());\n            for (let i = 0; i < partnersList.length; i++) {\n                const partners = partnersList[i];\n                try {\n                    const coordinates = await this._fetchCoordinatesFromAddressOSM(partners[0]);\n                    if (coordinates.length) {\n                        for (const partner of partners) {\n                            partner.partner_longitude = coordinates[0].lon;\n                            partner.partner_latitude = coordinates[0].lat;\n                            this.partnerToCache.push(partner);\n                        }\n                    }\n                } finally {\n                    for (const partner of partners) {\n                        partner.fetchingCoordinate = false;\n                    }\n                    this.data.fetchingCoordinates = (i < partnersList.length - 1);\n                    this._notifyFetchedCoordinate();\n                    await new Promise((resolve) => {\n                        this.coordinateFetchingTimeoutHandle =\n                            setTimeout(resolve, this.COORDINATE_FETCH_DELAY);\n                    });\n                }\n            }\n        }\n        return fetch();\n    },\n    /**\n     * Fetches the partner which ids are contained in the the array partnerids\n     * if the token is set it uses the mapBoxApi to fetch address and route\n     * if not is uses the openstreetmap api to fetch the address.\n     *\n     * @private\n     * @param {number[]} partnerIds this array contains the ids from the partner that are linked to records\n     * @returns {Promise}\n     */\n    _partnerFetching: async function (partnerIds) {\n        this.data.partners = partnerIds.length ? await this._fetchRecordsPartner(partnerIds) : [];\n        this._addPartnerToRecord();\n        if (this.data.mapBoxToken) {\n            return this._maxBoxAPI()\n                .then(() => {\n                    this._writeCoordinatesUsers();\n                }).catch((err) => {\n                    this._mapBoxErrorHandling(err);\n                    this.data.mapBoxToken = '';\n                    return this._openStreetMapAPI();\n                });\n        } else {\n            return this._openStreetMapAPI().then(() => {\n                this._writeCoordinatesUsers();\n            });\n        }\n    },\n    /**\n     * Writes partner_longitude and partner_latitude of the res.partner model.\n     *\n     * @private\n     * @return {Promise}\n     */\n    _writeCoordinatesUsers: function () {\n        if (this.partnerToCache.length) {\n            this._rpc({\n                model: 'res.partner',\n                method: 'update_latitude_longitude',\n                context: this.context,\n                args: [this.partnerToCache]\n            });\n            this.partnerToCache = [];\n        }\n    },\n});\n\nreturn MapModel;\n});\n", "/* global L */\n// L is the object of leaflet\nodoo.define('web_map.MapRenderer', function (require) {\n    \"use strict\";\n\n    const AbstractRendererOwl = require('web.AbstractRendererOwl');\n    const { format } = require(\"web.field_utils\");\n\n    const { useRef, useState } = owl.hooks;\n\n    const apiTilesRouteWithToken =\n        'https://api.mapbox.com/styles/v1/{id}/tiles/{z}/{x}/{y}?access_token={accessToken}';\n    const apiTilesRouteWithoutToken = 'https://a.tile.openstreetmap.org/{z}/{x}/{y}.png';\n\n    const colors = [\n        '#F06050',\n        '#6CC1ED',\n        '#F7CD1F',\n        '#814968',\n        '#30C381',\n        '#D6145F',\n        '#475577',\n        '#F4A460',\n        '#EB7E7F',\n        '#2C8397',\n    ];\n\n    const mapTileAttribution = `\n        \u00a9 <a href=\"https://www.mapbox.com/about/maps/\">Mapbox</a>\n        \u00a9 <a href=\"http://www.openstreetmap.org/copyright\">OpenStreetMap</a>\n        <strong>\n            <a href=\"https://www.mapbox.com/map-feedback/\" target=\"_blank\">\n                Improve this map\n            </a>\n        </strong>`;\n\n    class MapRenderer extends AbstractRendererOwl {\n        /**\n         * @constructor\n         */\n        constructor() {\n            super(...arguments);\n            this.leafletMap = null;\n            this.markers = [];\n            this.polylines = [];\n            this.mapContainerRef = useRef('mapContainer');\n            this.state = useState({\n                closedGroupIds: [],\n            });\n        }\n        /**\n         * Load marker icons.\n         *\n         * @override\n         */\n        async willStart() {\n            const p = { method: 'GET' };\n            [this._pinCircleSVG, this._pinNoCircleSVG] = await Promise.all([\n                this.env.services.httpRequest('web_map/static/img/pin-circle.svg', p, 'text'),\n                this.env.services.httpRequest('web_map/static/img/pin-no-circle.svg', p, 'text'),\n            ]);\n            return super.willStart(...arguments);\n        }\n        /**\n         * Initialize and mount map.\n         *\n         * @override\n         */\n        mounted() {\n            this.leafletMap = L.map(this.mapContainerRef.el, {\n                maxBounds: [L.latLng(180, -180), L.latLng(-180, 180)],\n            });\n            L.tileLayer(this.apiTilesRoute, {\n                attribution: mapTileAttribution,\n                tileSize: 512,\n                zoomOffset: -1,\n                minZoom: 2,\n                maxZoom: 19,\n                id: 'mapbox/streets-v11',\n                accessToken: this.props.mapBoxToken,\n            }).addTo(this.leafletMap);\n            this._updateMap();\n            super.mounted(...arguments);\n        }\n        /**\n         * Update position in the map, markers and routes.\n         *\n         * @override\n         */\n        patched() {\n            this._updateMap();\n            super.patched(...arguments);\n        }\n        /**\n         * Update group opened/closed state.\n         *\n         * @override\n         */\n        willUpdateProps(nextProps) {\n            if (this.props.groupBy !== nextProps.groupBy) {\n                this.state.closedGroupIds = [];\n            }\n            return super.willUpdateProps(...arguments);\n        }\n        /**\n         * Remove map and the listeners on its markers and routes.\n         *\n         * @override\n         */\n        willUnmount() {\n            for (const marker of this.markers) {\n                marker.off('click');\n            }\n            for (const polyline of this.polylines) {\n                polyline.off('click');\n            }\n            this.leafletMap.remove();\n            super.willUnmount(...arguments);\n        }\n\n        //----------------------------------------------------------------------\n        // Getters\n        //----------------------------------------------------------------------\n\n        /**\n         * Return the route to the tiles api with or without access token.\n         *\n         * @returns {string}\n         */\n        get apiTilesRoute() {\n            return this.props.mapBoxToken ? apiTilesRouteWithToken : apiTilesRouteWithoutToken;\n        }\n\n        //----------------------------------------------------------------------\n        // Private\n        //----------------------------------------------------------------------\n\n        /**\n         * If there's located records, adds the corresponding marker on the map.\n         * Binds events to the created markers.\n         *\n         * @private\n         */\n        _addMarkers() {\n            this._removeMarkers();\n\n            const markersInfo = {};\n            let records = this.props.records;\n            if (this.props.groupBy) {\n                records = Object.entries(this.props.recordGroups)\n                    .filter(([key]) => !this.state.closedGroupIds.includes(key))\n                    .flatMap(([, value]) => value.records);\n            }\n\n            for (const record of records) {\n                const partner = record.partner;\n                if (partner && partner.partner_latitude && partner.partner_longitude) {\n                    const key = `${partner.partner_latitude}-${partner.partner_longitude}`;\n                    if (key in markersInfo) {\n                        markersInfo[key].record = record;\n                        markersInfo[key].ids.push(record.id);\n                    } else {\n                        markersInfo[key] = { record: record, ids: [record.id] };\n                    }\n                }\n            }\n\n            for (const markerInfo of Object.values(markersInfo)) {\n                const params = {\n                    count: markerInfo.ids.length,\n                    isMulti: markerInfo.ids.length > 1,\n                    number: this.props.records.indexOf(markerInfo.record) + 1,\n                    numbering: this.props.numbering,\n                    pinSVG: (this.props.numbering ? this._pinNoCircleSVG : this._pinCircleSVG),\n                };\n\n                if (this.props.groupBy) {\n                    const group = Object.entries(this.props.recordGroups)\n                        .find(([, value]) => value.records.includes(markerInfo.record));\n                    params.color = this._getGroupColor(group[0]);\n                    params.number = group[1].records.indexOf(markerInfo.record) + 1;\n                }\n\n                // Icon creation\n                const iconInfo = {\n                    className: 'o_map_marker',\n                    html: this.env.qweb.renderToString('web_map.legacy.marker', params),\n                };\n\n                // Attach marker with icon and popup\n                const marker = L.marker([\n                    markerInfo.record.partner.partner_latitude,\n                    markerInfo.record.partner.partner_longitude\n                ], { icon: L.divIcon(iconInfo) });\n                marker.addTo(this.leafletMap);\n                marker.on('click', () => {\n                    this._createMarkerPopup(markerInfo);\n                });\n                this.markers.push(marker);\n            }\n        }\n        /**\n         * If there are computed routes, create polylines and add them to the map.\n         * each element of this.props.routeInfo[0].legs array represent the route between\n         * two waypoints thus each of these must be a polyline.\n         *\n         * @private\n         */\n        _addRoutes() {\n            this._removeRoutes();\n            if (!this.props.mapBoxToken || !this.props.routeInfo.routes.length) {\n                return;\n            }\n\n            for (const leg of this.props.routeInfo.routes[0].legs) {\n                const latLngs = [];\n                for (const step of leg.steps) {\n                    for (const coordinate of step.geometry.coordinates) {\n                        latLngs.push(L.latLng(coordinate[1], coordinate[0]));\n                    }\n                }\n\n                const polyline = L.polyline(latLngs, {\n                    color: 'blue',\n                    weight: 5,\n                    opacity: 0.3,\n                }).addTo(this.leafletMap);\n\n                const polylines = this.polylines;\n                polyline.on('click', function () {\n                    for (const polyline of polylines) {\n                        polyline.setStyle({ color: 'blue', opacity: 0.3 });\n                    }\n                    this.setStyle({ color: 'darkblue', opacity: 1.0 });\n                });\n                this.polylines.push(polyline);\n            }\n        }\n        /**\n         * Create a popup for the specified marker.\n         *\n         * @private\n         * @param {Object} markerInfo\n         */\n        _createMarkerPopup(markerInfo) {\n            const popupFields = this._getMarkerPopupFields(markerInfo);\n            const partner = markerInfo.record.partner;\n            const popupHtml = this.env.qweb.renderToString('web_map.legacy.markerPopup', {\n                fields: popupFields,\n                hasFormView: this.props.hasFormView,\n                url: `https://www.google.com/maps/dir/?api=1&destination=${partner.partner_latitude},${partner.partner_longitude}`,\n            });\n\n            const popup = L.popup({ offset: [0, -30] })\n                .setLatLng([partner.partner_latitude, partner.partner_longitude])\n                .setContent(popupHtml)\n                .openOn(this.leafletMap);\n\n            const openBtn = popup.getElement().querySelector('button.o_open');\n            if (openBtn) {\n                openBtn.onclick = () => {\n                    this.trigger('open_clicked', { ids: markerInfo.ids });\n                };\n            }\n            return popup;\n        }\n        /**\n         * @private\n         * @param {Number} groupId\n         */\n        _getGroupColor(groupId) {\n            const index = Object.keys(this.props.recordGroups).indexOf(groupId);\n            return colors[index % colors.length];\n        }\n        /**\n         * Creates an array of latLng objects if there is located records.\n         *\n         * @private\n         * @returns {latLngBounds|boolean} objects containing the coordinates that\n         *          allows all the records to be shown on the map or returns false\n         *          if the records does not contain any located record.\n         */\n        _getLatLng() {\n            const tabLatLng = [];\n            for (const record of this.props.records) {\n                const partner = record.partner;\n                if (partner && partner.partner_latitude && partner.partner_longitude) {\n                    tabLatLng.push(L.latLng(partner.partner_latitude, partner.partner_longitude));\n                }\n            }\n            if (!tabLatLng.length) {\n                return false;\n            }\n            return L.latLngBounds(tabLatLng);\n        }\n        /**\n         * Get the fields' name and value to display in the popup.\n         *\n         * @private\n         * @param {Object} markerInfo\n         * @returns {Object} value contains the value of the field and string\n         *                   contains the value of the xml's string attribute\n         */\n        _getMarkerPopupFields(markerInfo) {\n            const record = markerInfo.record;\n            const fieldsView = [];\n            // Only display address in multi coordinates marker popup\n            if (markerInfo.ids.length > 1) {\n                if (!this.props.hideAddress) {\n                    fieldsView.push({\n                        value: record.partner.contact_address_complete,\n                        string: this.env._t(\"Address\"),\n                    });\n                }\n                return fieldsView;\n            }\n            if (!this.props.hideName) {\n                fieldsView.push({\n                    value: record.display_name,\n                    string: this.env._t(\"Name\"),\n                });\n            }\n            if (!this.props.hideAddress) {\n                fieldsView.push({\n                    value: record.partner.contact_address_complete,\n                    string: this.env._t(\"Address\"),\n                });\n            }\n            for (const field of this.props.fieldNamesMarkerPopup) {\n                if (record[field.fieldName]) {\n                    let fieldName = record[field.fieldName] instanceof Array ?\n                        record[field.fieldName][1] :\n                        record[field.fieldName];\n\n                    if ([\"date\", \"datetime\"].includes(field.type)) {\n                        const date = moment.utc(fieldName);\n                        fieldName = format[field.type](date);\n                    }\n\n                    fieldsView.push({\n                        value: fieldName,\n                        string: field.string,\n                    });\n                }\n            }\n            return fieldsView;\n        }\n        /**\n         * Remove the markers from the map and empty the markers array.\n         *\n         * @private\n         */\n        _removeMarkers() {\n            for (const marker of this.markers) {\n                this.leafletMap.removeLayer(marker);\n            }\n            this.markers = [];\n        }\n        /**\n         * Remove the routes from the map and empty the the polyline array.\n         *\n         * @private\n         */\n        _removeRoutes() {\n            for (const polyline of this.polylines) {\n                this.leafletMap.removeLayer(polyline);\n            }\n            this.polylines = [];\n        }\n        /**\n         * Update position in the map, markers and routes.\n         *\n         * @private\n         */\n        _updateMap() {\n            if (this.props.shouldUpdatePosition) {\n                const initialCoord = this._getLatLng();\n                if (initialCoord) {\n                    this.leafletMap.flyToBounds(initialCoord, { animate: false });\n                } else {\n                    this.leafletMap.fitWorld();\n                }\n                this.leafletMap.closePopup();\n            }\n            this._addMarkers();\n            this._addRoutes();\n        }\n\n        //----------------------------------------------------------------------\n        // Handlers\n        //----------------------------------------------------------------------\n\n        /**\n         * Center the map on a certain pin and open the popup linked to it.\n         *\n         * @private\n         * @param {Object} record\n         */\n        _centerAndOpenPin(record) {\n            const popup = this._createMarkerPopup({\n                record: record,\n                ids: [record.id],\n            });\n            const px = this.leafletMap.project([record.partner.partner_latitude, record.partner.partner_longitude]);\n            const popupHeight = popup.getElement().offsetHeight;\n            px.y -= popupHeight / 2;\n            const latlng = this.leafletMap.unproject(px);\n            this.leafletMap.panTo(latlng, { animate: true });\n        }\n        /**\n         * @private\n         * @param {Number} id\n         */\n        _toggleGroup(id) {\n            if (this.state.closedGroupIds.includes(id)) {\n                const index = this.state.closedGroupIds.indexOf(id);\n                this.state.closedGroupIds.splice(index, 1);\n            } else {\n                this.state.closedGroupIds.push(id);\n            }\n        }\n    }\n    MapRenderer.props = {\n        arch: Object,\n        count: Number,\n        defaultOrder: {\n            type: String,\n            optional: true,\n        },\n        fetchingCoordinates: Boolean,\n        fieldNamesMarkerPopup: {\n            type: Array,\n            element: {\n                type: Object,\n                shape: {\n                    fieldName: String,\n                    string: String,\n                    type: String,\n                },\n            },\n        },\n        groupBy: [String, Boolean],\n        hasFormView: Boolean,\n        hideAddress: Boolean,\n        hideName: Boolean,\n        isEmbedded: Boolean,\n        limit: Number,\n        mapBoxToken: { type: [Boolean, String], optional: 1 },\n        noContentHelp: {\n            type: String,\n            optional: true,\n        },\n        numbering: Boolean,\n        hideTitle: Boolean,\n        panelTitle: String,\n        offset: Number,\n        partners: { type: [Array, Boolean], optional: 1 },\n        recordGroups: Object,\n        records: Array,\n        routeInfo: {\n            type: Object,\n            optional: true,\n        },\n        routing: Boolean,\n        routingError: {\n            type: String,\n            optional: true,\n        },\n        shouldUpdatePosition: Boolean,\n    };\n    MapRenderer.template = 'web_map.legacy.MapRenderer';\n\n    return MapRenderer;\n});\n", "odoo.define('web_map.MapView', function (require) {\n\"use strict\";\n\nconst MapModel = require('web_map.MapModel');\nconst MapController = require('web_map.MapController');\nconst MapRenderer = require('web_map.MapRenderer');\nconst AbstractView = require('web.AbstractView');\nconst RendererWrapper = require('web.RendererWrapper');\nconst utils = require('web.utils');\nconst viewRegistry = require('web.view_registry');\nconst _t = require('web.core')._t;\n\nconst MapView = AbstractView.extend({\n    jsLibs: [\n        '/web_map/static/lib/leaflet/leaflet.js',\n    ],\n    config: _.extend({}, AbstractView.prototype.config, {\n        Model: MapModel,\n        Controller: MapController,\n        Renderer: MapRenderer,\n    }),\n    icon: 'fa-map-marker',\n    display_name: 'Map',\n    viewType: 'map',\n    mobile_friendly: true,\n    searchMenuTypes: ['filter', 'groupBy', 'favorite'],\n\n    init: function (viewInfo, params) {\n        this._super.apply(this, arguments);\n\n        const fieldNames = [];\n        const fieldNamesMarkerPopup = [];\n\n        this.loadParams.resPartnerField = this.arch.attrs.res_partner;\n        fieldNames.push(this.arch.attrs.res_partner);\n        fieldNames.push('display_name');\n\n        if (this.arch.attrs.default_order) {\n            this.loadParams.orderBy = [{ name: this.arch.attrs.default_order || 'display_name', asc: true }];\n        }\n\n        const routing = [\"true\", \"True\", \"1\"].includes(this.arch.attrs.routing);\n\n        this.loadParams.limit = this.arch.attrs.limit ?\n            parseInt(this.arch.attrs.limit, 10) :\n            params.limit || 80;\n        this.loadParams.routing = routing;\n        this.rendererParams.routing = routing;\n        this.rendererParams.numbering = this.arch.attrs.routing ? true : false;\n        this.rendererParams.defaultOrder = this.arch.attrs.default_order;\n        this.rendererParams.panelTitle = this.arch.attrs.panel_title || params.displayName || _t('Items');\n        this.rendererParams.hideTitle = utils.toBoolElse(this.arch.attrs.hide_title || '', false);\n\n        const hideName = utils.toBoolElse(this.arch.attrs.hide_name || '', false);\n        this.rendererParams.hideName = hideName;\n        if (!hideName) {\n            fieldNames.push('display_name');\n        }\n        this.rendererParams.hideAddress = utils.toBoolElse(this.arch.attrs.hide_address || '', false);\n\n        this.arch.children.forEach(node => {\n            if (node.tag === 'field') {\n                fieldNames.push(node.attrs.name);\n                fieldNamesMarkerPopup.push({ fieldName: node.attrs.name, string: node.attrs.string, type: this.fields[node.attrs.name].type});\n            }\n        });\n\n        this.loadParams.fieldsInfo = this.fields;\n        this.loadParams.fieldNames = _.uniq(fieldNames);\n        this.rendererParams.fieldNamesMarkerPopup = fieldNamesMarkerPopup;\n\n        this.rendererParams.hasFormView = params.actionViews.some(view => view.type === \"form\");\n\n        this.controllerParams.actionName = params.action ? params.action.name : _t(\"Untitled\");\n    },\n    /**\n     * @override\n     */\n    getRenderer(parent, state) {\n        state = Object.assign({}, state, this.rendererParams);\n        return new RendererWrapper(null, this.config.Renderer, state);\n    },\n});\n\nviewRegistry.add('map', MapView);\n\nreturn MapView;\n});\n", "odoo.define('web_cohort.CohortController', function (require) {\n'use strict';\n\nconst AbstractController = require('web.AbstractController');\nconst config = require('web.config');\nconst core = require('web.core');\nconst framework = require('web.framework');\nconst session = require('web.session');\n\nconst qweb = core.qweb;\nconst _t = core._t;\n\nvar CohortController = AbstractController.extend({\n    custom_events: Object.assign({}, AbstractController.prototype.custom_events, {\n        row_clicked: '_onRowClicked',\n    }),\n    /**\n     * @override\n     * @param {Widget} parent\n     * @param {CohortModel} model\n     * @param {CohortRenderer} renderer\n     * @param {Object} params\n     * @param {string} params.modelName\n     * @param {string} params.title\n     * @param {Object} params.measures\n     * @param {Object} params.intervals\n     * @param {string} params.dateStartString\n     * @param {string} params.dateStopString\n     * @param {string} params.timeline\n     * @param {Array[]} params.views\n     */\n    init: function (parent, model, renderer, params) {\n        this._super.apply(this, arguments);\n        this.title = params.title;\n        this.measures = params.measures;\n        this.intervals = params.intervals;\n        this.dateStartString = params.dateStartString;\n        this.dateStopString = params.dateStopString;\n        this.timeline = params.timeline;\n        this.views = params.views;\n    },\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    /**\n     * Returns the current mode, measure and groupbys, so we can restore the\n     * view when we save the current state in the search view, or when we add it\n     * to the dashboard.\n     *\n     * @override\n     * @returns {Object}\n     */\n    getOwnedQueryParams: function () {\n        var state = this.model.get();\n        return {\n            context: {\n                cohort_measure: state.measure,\n                cohort_interval: state.interval,\n            }\n        };\n    },\n\n    /**\n     * @override\n     * @param {jQuery} [$node]\n     */\n    renderButtons: function ($node) {\n        this.$buttons = $(qweb.render('CohortView.buttons', {\n            measures: _.sortBy(_.pairs(this.measures), function(x){ return x[1].toLowerCase(); }),\n            intervals: this.intervals,\n            isMobile: config.device.isMobile\n        }));\n        this.$measureList = this.$buttons.find('.o_cohort_measures_list');\n        this.$buttons.on('click', 'button', this._onButtonClick.bind(this));\n        if ($node) {\n            this.$buttons.appendTo($node);\n        }\n    },\n    /**\n     * Makes sure that the buttons in the control panel matches the current\n     * state (so, correct active buttons and stuff like that);\n     *\n     * @override\n     */\n    updateButtons: function () {\n        if (!this.$buttons) {\n            return;\n        }\n        var data = this.model.get();\n        // Hide download button if no cohort data\n        var noData = !data.report.rows.length &&\n                    (!data.comparisonReport ||\n                    !data.comparisonReport.rows.length);\n        this.$buttons.find('.o_cohort_download_button').toggleClass(\n            'd-none',\n            noData\n        );\n        if (config.device.isMobile) {\n            var $activeInterval = this.$buttons\n                .find('.o_cohort_interval_button[data-interval=\"' + data.interval + '\"]');\n            this.$buttons.find('.dropdown_cohort_content').text($activeInterval.text());\n        }\n        this.$buttons.find('.o_cohort_interval_button').removeClass('active');\n        this.$buttons\n            .find('.o_cohort_interval_button[data-interval=\"' + data.interval + '\"]')\n            .addClass('active');\n        _.each(this.$measureList.find('.dropdown-item'), function (el) {\n            var $el = $(el);\n            $el.toggleClass('selected', $el.data('field') === data.measure);\n        });\n    },\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    /**\n     * Export cohort data in Excel file\n     *\n     * @private\n     */\n    _downloadExcel: function () {\n        var data = this.model.get();\n        data = _.extend(data, {\n            title: this.title,\n            model: this.modelName,\n            interval_string: this.intervals[data.interval].toString(), // intervals are lazy-translated\n            measure_string: this.measures[data.measure] || _t('Count'),\n            date_start_string: this.dateStartString,\n            date_stop_string: this.dateStopString,\n            timeline: this.timeline,\n        });\n        framework.blockUI();\n        session.get_file({\n            url: '/web/cohort/export',\n            data: {data: JSON.stringify(data)},\n            complete: framework.unblockUI,\n            error: (error) => this.call('crash_manager', 'rpc_error', error),\n        });\n    },\n    /**\n     * @private\n     * @param {string} interval\n     */\n    _setInterval: function (interval) {\n      this.update({interval: interval});\n    },\n    /**\n     * @private\n     * @param {string} measure should be a valid (and aggregatable) field name\n     */\n    _setMeasure: function (measure) {\n        this.update({measure: measure});\n    },\n    /**\n     * @override\n     * @private\n     * @returns {Promise}\n     */\n    _update: function () {\n      this.updateButtons();\n      return this._super.apply(this, arguments);\n    },\n\n    //--------------------------------------------------------------------------\n    // Handlers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Do what need to be done when a button from the control panel is clicked.\n     *\n     * @private\n     * @param {MouseEvent} ev\n     */\n    _onButtonClick: function (ev) {\n        var $btn = $(ev.currentTarget);\n        if ($btn.hasClass('o_cohort_interval_button')) {\n            this._setInterval($btn.data('interval'));\n        } else if ($btn.hasClass('o_cohort_download_button')) {\n            this._downloadExcel();\n        } else if ($btn.closest('.o_cohort_measures_list').length) {\n            ev.preventDefault();\n            ev.stopPropagation();\n            this._setMeasure($btn.data('field'));\n        }\n    },\n    /**\n     * Open view when clicked on row\n     *\n     * @private\n     * @param {OdooEvent} event\n     */\n    _onRowClicked: function (event) {\n        this.do_action({\n            type: 'ir.actions.act_window',\n            name: this.title,\n            res_model: this.modelName,\n            views: this.views,\n            domain: event.data.domain,\n        });\n    },\n});\n\nreturn CohortController;\n\n});\n", "odoo.define('web_cohort.CohortModel', function (require) {\n'use strict';\n\nvar AbstractModel = require('web.AbstractModel');\nconst { processMeasure } = require(\"@web/views/helpers/utils\");\n\nvar CohortModel = AbstractModel.extend({\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    /**\n    * @override\n    * @returns {Object}\n    */\n    __get: function () {\n        const { rangeDescription, comparisonRangeDescription } = this.timeRanges;\n        return Object.assign({}, this.data, {\n            hasContent: !this._isEmpty(),\n            isSample: this.isSampleModel,\n            rangeDescription,\n            comparisonRangeDescription\n        });\n    },\n    /**\n     * @override\n     * @param {Object} params\n     * @param {string} params.modelName\n     * @param {string} params.dateStart\n     * @param {string} params.dateStop\n     * @param {string} params.measure\n     * @param {string} params.interval\n     * @param {Array[]} params.domain\n     * @param {string} params.mode\n     * @param {string} params.timeline\n     * @param {Object} params.timeRanges\n     * @returns {Promise}\n     */\n    __load: function (params) {\n        this.modelName = params.modelName;\n        this.dateStart = params.dateStart;\n        this.dateStop = params.dateStop;\n        this.measure = processMeasure(params.measure);\n        this.interval = params.interval;\n        this.domain = params.domain;\n        this.mode = params.mode;\n        this.timeline = params.timeline;\n        this.data = {\n            measure: this.measure,\n            interval: this.interval,\n        };\n        this.context = params.context;\n        this.timeRanges = params.timeRanges;\n        return this._fetchData();\n    },\n    /**\n     * Reload data.\n     *\n     * @param {any} handle\n     * @param {Object} params\n     * @param {string} [params.measure]\n     * @param {string} [params.interval]\n     * @param {Array[]} [params.domain]\n     * @param {Object} [params.timeRanges]\n     * @returns {Promise}\n     */\n    __reload: function (handle, params) {\n        if ('measure' in params) {\n            this.data.measure = processMeasure(params.measure);\n        }\n        if ('interval' in params) {\n            this.data.interval = params.interval;\n        }\n        if ('domain' in params) {\n            this.domain = params.domain;\n        }\n        if ('timeRanges' in params) {\n            this.timeRanges = params.timeRanges;\n        }\n        return this._fetchData();\n    },\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    /**\n     * Fetch cohort data.\n     *\n     * @private\n     * @returns {Promise}\n     */\n    _fetchData: function () {\n        const domains = this._getDomains();\n        const proms = domains.map(domain => {\n            return this._rpc({\n                model: this.modelName,\n                method: 'get_cohort_data',\n                kwargs: {\n                    date_start: this.dateStart,\n                    date_stop: this.dateStop,\n                    measure: this.data.measure,\n                    interval: this.data.interval,\n                    domain: domain,\n                    mode: this.mode,\n                    timeline: this.timeline,\n                    context: this.context\n                }\n            });\n        });\n        return Promise.all(proms).then(([report, comparisonReport]) => {\n            this.data.report = report;\n            this.data.comparisonReport = comparisonReport;\n        });\n    },\n    /**\n     * @private\n     * @returns {Array[]}\n     */\n    _getDomains: function () {\n        const { range, comparisonRange } = this.timeRanges;\n        if (!range) {\n            return [this.domain];\n        }\n        return [\n            this.domain.concat(range),\n            this.domain.concat(comparisonRange),\n        ];\n    },\n    /**\n     * @override\n     */\n    _isEmpty() {\n        let rowCount = this.data.report.rows.length;\n        if (this.data.comparisonReport) {\n            rowCount += this.data.comparisonReport.rows.length;\n        }\n        return rowCount === 0;\n    },\n});\n\nreturn CohortModel;\n\n});\n", "odoo.define('web_cohort.CohortRenderer', function (require) {\n    'use strict';\n\n    const OwlAbstractRenderer = require('web.AbstractRendererOwl');\n    const field_utils = require('web.field_utils');\n\n    class CohortRenderer extends OwlAbstractRenderer {\n\n        constructor() {\n            super(...arguments);\n            this.sampleDataTargets = ['table'];\n        }\n\n        //--------------------------------------------------------------------------\n        // Private\n        //--------------------------------------------------------------------------\n\n        /**\n         * @param {integer} value\n         * @returns {Array} first integers from 0 to value-1\n         */\n        _range(value) {\n            return _.range(value);\n        }\n        /**\n         * @param {float} value\n         * @returns {string} formatted value with 1 digit\n         */\n        _formatFloat(value) {\n            return field_utils.format.float(value, null, {\n                digits: [42, 1],\n            });\n        }\n        /**\n         * @param {float} value\n         * @returns {string} formatted value with 1 digit\n         */\n        _formatPercentage(value) {\n            return field_utils.format.percentage(value, null, {\n                digits: [42, 1],\n            });\n        }\n\n        //--------------------------------------------------------------------------\n        // Handlers\n        //--------------------------------------------------------------------------\n\n        /**\n         * @private\n         * @param {MouseEvent} ev\n         */\n        _onClickRow(ev) {\n            if (!ev.target.classList.contains('o_cohort_value')) {\n                return;\n            }\n            const rowData = ev.currentTarget.dataset;\n            const rowIndex = rowData.rowIndex;\n            const colIndex = ev.target.dataset.colIndex; // pas de colIndex dans le template\n            // TODO: [SAD] fixme in master (type is always data because set unconditionally in template)\n            const row = (rowData.type === 'data') ?\n                this.props.report.rows[rowIndex] :\n                this.props.comparisonReport.rows[rowIndex];\n            const rowDomain = row ? row.domain : [];\n            const cellContent = row ? row.columns[colIndex] : false;\n            const cellDomain = cellContent ? cellContent.domain : [];\n\n            const fullDomain = rowDomain.concat(cellDomain);\n            if (cellDomain.length) {\n                fullDomain.unshift('&');\n            }\n            if (fullDomain.length) {\n                this.trigger('row_clicked', {\n                    domain: fullDomain\n                });\n            }\n        }\n    }\n\n    CohortRenderer.template = 'web_cohort.Legacy.CohortRenderer';\n\n    return CohortRenderer;\n\n});\n", "odoo.define('web_cohort.CohortView', function (require) {\n'use strict';\n\nvar AbstractView = require('web.AbstractView');\nvar core = require('web.core');\nvar CohortController = require('web_cohort.CohortController');\nvar CohortModel = require('web_cohort.CohortModel');\nvar CohortRenderer = require('web_cohort.CohortRenderer');\nconst RendererWrapper = require('web.RendererWrapper');\nconst legacyViewRegistry = require(\"web.view_registry\");\n\nvar _t = core._t;\nvar _lt = core._lt;\n\nvar intervals = {\n    day: _lt('Day'),\n    week: _lt('Week'),\n    month: _lt('Month'),\n    year: _lt('Year'),\n};\n\nvar CohortView = AbstractView.extend({\n    display_name: _lt('Cohort'),\n    icon: 'fa-signal',\n    config: _.extend({}, AbstractView.prototype.config, {\n        Model: CohortModel,\n        Controller: CohortController,\n        Renderer: CohortRenderer,\n    }),\n    viewType: 'cohort',\n    searchMenuTypes: ['filter', 'comparison', 'favorite'],\n\n    /**\n     * @override\n     */\n    init: function (viewInfo, params) {\n        this._super.apply(this, arguments);\n\n        var fields = this.fields;\n        var attrs = this.arch.attrs;\n        const additionalMeasures = params.additionalMeasures || [];\n\n        if (!attrs.date_start) {\n            throw new Error(_lt('Cohort view has not defined \"date_start\" attribute.'));\n        }\n        if (!attrs.date_stop) {\n            throw new Error(_lt('Cohort view has not defined \"date_stop\" attribute.'));\n        }\n\n\n        // Renderer Parameters\n        var measures = {};\n        _.each(fields, function (field, name) {\n            if (name !== 'id' && field.store === true && _.contains(['integer', 'float', 'monetary'], field.type)) {\n                measures[name] = field.string;\n            }\n        });\n\n        this.arch.children.forEach(field => {\n            let fieldName = field.attrs.name;\n            // Remove invisible fields from the measures\n            if (\n                !additionalMeasures.includes(fieldName) &&\n                field.attrs.invisible && py.eval(field.attrs.invisible)\n            ) {\n                delete measures[fieldName];\n                return;\n            }\n            if (fieldName in measures && field.attrs.string) {\n                measures[fieldName] = field.attrs.string;\n            }\n        });\n\n        measures.__count = _t('Count');\n        this.rendererParams.measures = measures;\n        this.rendererParams.intervals = intervals;\n\n        // Controller Parameters\n        this.controllerParams.measures = _.omit(measures, '__count');\n        this.controllerParams.intervals = intervals;\n        this.controllerParams.title = params.title || attrs.string || _t('Untitled');\n        // Used in export\n        // Retrieve form and list view ids from the action to open those views\n        // when a row of the cohort view is clicked\n        this.controllerParams.views = [\n            _findViewID('list'),\n            _findViewID('form'),\n        ];\n        function _findViewID(viewType) {\n            var action = params.action;\n\n            if (action === undefined) {\n                return [false, viewType];\n            }\n            var contextID = viewType === 'list' ? action.context.list_view_id : action.context.form_view_id;\n            if (contextID) {\n                return [contextID, viewType];\n            } else {\n                const result = action._views ? action._views.find((v) => v[1] === viewType) : undefined;\n                return result || [false, viewType];\n            }\n        }\n    },\n\n\n    _updateMVCParams: function () {\n        this._super.apply(this, arguments);\n        // Model Parameters\n        var context = this.loadParams.context;\n        var attrs = this.arch.attrs;\n        this.loadParams.dateStart = context.cohort_date_start ||  attrs.date_start;\n        this.loadParams.dateStop = context.cohort_date_stop ||  attrs.date_stop;\n        this.loadParams.mode = context.cohort_mode || attrs.mode || 'retention';\n        this.loadParams.timeline = context.cohort_timeline || attrs.timeline || 'forward';\n        this.loadParams.measure = context.cohort_measure ||  attrs.measure || '__count';\n        this.loadParams.interval = context.cohort_interval || attrs.interval || 'day';\n\n        this.rendererParams.mode = this.loadParams.mode;\n        this.rendererParams.timeline = this.loadParams.timeline;\n        this.rendererParams.dateStartString = this.fields[this.loadParams.dateStart].string;\n        this.rendererParams.dateStopString = this.fields[this.loadParams.dateStop].string;\n\n        this.controllerParams.dateStartString = this.rendererParams.dateStartString;\n        this.controllerParams.dateStopString = this.rendererParams.dateStopString;\n        this.controllerParams.timeline = this.rendererParams.timeline;\n    },\n     /**\n     * @override\n     */\n    getRenderer(parent, state) {\n        state = Object.assign({}, state, this.rendererParams);\n        return new RendererWrapper(null, this.config.Renderer, state);\n    },\n});\n\nlegacyViewRegistry.add(\"cohort\", CohortView); // Compatibility with Studio!\nreturn CohortView;\n\n});\n", "odoo.define('web_cohort/static/src/js/sample_server.js', function (require) {\n    \"use strict\";\n\n    const SampleServer = require('web.SampleServer');\n\n    /**\n     * This function mocks calls to the 'get_cohort_data' method. It is\n     * registered to the SampleServer's mockRegistry, so it is called with a\n     * SampleServer instance as \"this\".\n     * @private\n     * @param {Object} params\n     * @param {string} params.model\n     * @param {Object} params.kwargs\n     * @returns {Object}\n     */\n    function _mockGetCohortData(params) {\n        const { model } = params;\n        const { date_start, interval, measure, mode, timeline } = params.kwargs;\n\n        const columns_avg = {};\n        const rows = [];\n        let initialChurnValue = 0;\n\n        const groups = this._mockReadGroup({ model, fields: [date_start], groupBy: [date_start + ':' + interval] });\n        const totalCount = groups.length;\n        let totalValue = 0;\n        for (const group of groups) {\n            const format = SampleServer.FORMATS[interval];\n            const displayFormat = SampleServer.DISPLAY_FORMATS[interval];\n            const date = moment(group[date_start + ':' + interval], format);\n            const now = moment();\n            let colStartDate = date.clone();\n            if (timeline === 'backward') {\n                colStartDate = colStartDate.subtract(15, interval);\n            }\n\n            let value = measure === '__count' ?\n                            this._getRandomInt(SampleServer.MAX_INTEGER) :\n                            this._generateFieldValue(model, measure);\n            value = value || 25;\n            totalValue += value;\n            let initialValue = value;\n            let max = value;\n\n            const columns = [];\n            for (let column = 0; column <= 15; column++) {\n                if (!columns_avg[column]) {\n                    columns_avg[column] = { percentage: 0, count: 0 };\n                }\n                if (colStartDate.clone().add(column, interval) > now) {\n                    columns.push({ value: '-', churn_value: '-', percentage: '' });\n                    continue;\n                }\n                let colValue = 0;\n                if (max > 0) {\n                    colValue = Math.min(Math.round(Math.random() * max), max);\n                    max -= colValue;\n                }\n                if (timeline === 'backward' && column === 0) {\n                    initialValue = Math.min(Math.round(Math.random() * value), value);\n                    initialChurnValue = value - initialValue;\n                }\n                const previousValue = column === 0 ? initialValue : columns[column - 1].value;\n                const remainingValue = previousValue - colValue;\n                const previousChurnValue = column === 0 ? initialChurnValue : columns[column - 1].churn_value;\n                const churn_value = colValue + previousChurnValue;\n                let percentage = value ? parseFloat(remainingValue / value) : 0;\n                if (mode === 'churn') {\n                    percentage = 1 - percentage;\n                }\n                percentage = Number((100 * percentage).toFixed(1));\n                columns_avg[column].percentage += percentage;\n                columns_avg[column].count += 1;\n                columns.push({\n                    value: remainingValue,\n                    churn_value,\n                    percentage,\n                    period: column, // used as a t-key but we don't care about value itself\n                });\n            }\n            const keepRow = columns.some(c => c.percentage !== '');\n            if (keepRow) {\n                rows.push({ date: date.format(displayFormat), value, columns });\n            }\n        }\n        const avg_value = totalCount ? (totalValue / totalCount) : 0;\n        const avg = { avg_value, columns_avg };\n        return { rows, avg };\n    }\n\n    SampleServer.mockRegistry.add('get_cohort_data', _mockGetCohortData);\n});\n", "odoo.define('web_dashboard.DashboardController', function (require) {\n\"use strict\";\n\nvar AbstractController = require('web.AbstractController');\nvar BasicController = require('web.BasicController');\nvar core = require('web.core');\nvar Domain = require('web.Domain');\n\nvar _t = core._t;\n\nvar DashboardController = AbstractController.extend({\n\tcustom_events: _.extend({}, BasicController.prototype.custom_events, {\n        open_view: '_onOpenView',\n    }),\n\n    /**\n     * @override\n     */\n    init: function (parent, model, renderer, params) {\n        this._super.apply(this, arguments);\n        // the dashboard view can trigger domain changes (when fields with a\n        // domain attribute are clicked) ; this array registers the current -\n        // clicked field specific - filters, so that they can be removed if\n        // another field is clicked.\n        this.actionDomain = params.actionDomain;\n        this.currentFilterIDs = [];\n    },\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    /**\n     * @override\n     */\n    getOwnedQueryParams: function () {\n        return {context: this.renderer.getsubControllersContext()};\n    },\n\n    //--------------------------------------------------------------------------\n    // Handlers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Opens the requested view in an other action, so that it is displayed in\n     * full screen.\n     *\n     * @private\n     * @param {OdooEvent} ev\n     * @param {string[]} [ev.data.additionalMeasures] view options to specify\n     *  additional fields to consider for measures.\n     * @param {Object} ev.data.context\n     * @param {string} ev.data.viewType\n     */\n    _onOpenView: function (ev) {\n        ev.stopPropagation();\n        var data = ev.data;\n        var action = {\n            domain: this.actionDomain,\n            context: data.context,\n            name: _.str.sprintf(_t('%s Analysis'), _.str.capitalize(data.viewType)),\n            res_model: this.modelName,\n            type: 'ir.actions.act_window',\n            views: [[false, data.viewType]],\n            useSampleModel: false, // disable sample data when zooming on a sub view\n        };\n        if (!_.isEmpty(ev.data.additionalMeasures)) {\n            action.flags = {\n                additionalMeasures: ev.data.additionalMeasures\n            };\n        }\n        this.do_action(action);\n    },\n    /**\n     * Handles a reload request (it occurs when a field is clicked). If this\n     * field as a domain attribute, a new filter for this domain is added to the\n     * search view. If another field with a domain attribute has been clicked\n     * previously, the corresponding filter is removed from the search view.\n     * Finally, triggers a reload of the dashboard with the new combined domain.\n     *\n     * @override\n     * @private\n     * @param {OdooEvent} ev\n     * @param {Array[]} ev.data.domain\n     * @param {string} ev.data.domainLabel\n     */\n    _onReload: async function (ev) {\n        ev.stopPropagation();\n        const dashboardDomain = {};\n        if (ev.data.domain && ev.data.domain.length) {\n            dashboardDomain.domain = Domain.prototype.arrayToString(ev.data.domain);\n            dashboardDomain.label = ev.data.domainLabel;\n        }\n        this.searchModel.dispatch(\"updateDashboardDomain\", dashboardDomain);\n    },\n});\n\nreturn DashboardController;\n\n});\n", "odoo.define('web_dashboard.DashboardModel', function (require) {\n\"use strict\";\n\n/**\n * This module defines the DashboardModel, an extension of the BasicModel.\n * Unlike the BasicModel, the DashboardModel only keep a single dataPoint (there\n * is no relational data in this model), and this dataPoint contains two\n * additional keys: aggregates and formulas, which gather the information\n * about the <aggregate> and <formula> occurrences in the dashboard arch.\n */\n\nvar BasicModel = require('web.BasicModel');\nvar dataComparisonUtils = require('web.dataComparisonUtils');\nvar Domain = require('web.Domain');\nvar pyUtils = require('web.py_utils');\n\nvar computeVariation = dataComparisonUtils.computeVariation;\n\nvar DashboardModel = BasicModel.extend({\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    /**\n     * @override\n     */\n    __get: function () {\n        var record = this._super.apply(this, arguments);\n        record.timeRanges = this.dataPoint.timeRanges;\n        record.timeRange = this.dataPoint.timeRange;\n        record.comparisonTimeRange = this.dataPoint.comparisonTimeRange;\n        record.compare = this.dataPoint.compare;\n        record.comparisonData = this.dataPoint.comparisonData;\n        record.variationData = this.dataPoint.variationData;\n        record.isSample = this.isSampleModel;\n        return record;\n     },\n    /**\n     * @override\n     */\n    __load: function (params) {\n        params.type = 'record';\n        this.dataPoint = this._makeDataPoint(params);\n        return this._load(this.dataPoint);\n    },\n    /**\n     * @override\n     */\n    __reload: function (id, options) {\n        options = options || {};\n        if (options.domain !== undefined) {\n            this.dataPoint.domain = options.domain;\n        }\n        if ('timeRanges' in options) {\n            this._processTimeRanges(this.dataPoint, options.timeRanges);\n        }\n        return this._load(this.dataPoint);\n    },\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    /**\n     * Evaluates formulas of the dataPoint with its values.\n     *\n     * @private\n     * @param {Object} dataPoint\n     */\n    _evaluateFormulas: function (dataPoint) {\n        _.each(dataPoint.formulas, function (formula, formulaID) {\n            try {\n                dataPoint.data[formulaID] = pyUtils.py_eval(formula.value, {\n                    record: dataPoint.data\n                });\n                if (!isFinite(dataPoint.data[formulaID])) {\n                    dataPoint.data[formulaID] = NaN;\n                }\n            } catch (e) {\n                dataPoint.data[formulaID] = NaN;\n            }\n            if (dataPoint.compare) {\n                try {\n                    dataPoint.comparisonData[formulaID] = pyUtils.py_eval(formula.value, {\n                        record: dataPoint.comparisonData\n                    });\n                    if (!isFinite(dataPoint.comparisonData[formulaID])) {\n                        dataPoint.comparisonData[formulaID] = NaN;\n                    }\n                } catch (e) {\n                    dataPoint.comparisonData[formulaID] = NaN;\n                }\n            }\n        });\n    },\n    /**\n     * @param  {Array[]} aggregateDomain\n     * @param  {Array[]} range\n     * @return {Array[]}\n     */\n    _getReadGroupDomain: function (aggregateDomain, range) {\n        return Domain.prototype.normalizeArray(this.dataPoint.domain)\n            .concat(range)\n            .concat(Domain.prototype.normalizeArray(new Domain(aggregateDomain).toArray()));\n    },\n    /**\n     * @override\n     */\n    _isEmpty() {\n        return this.dataPoint.count === 0;\n    },\n    /**\n     * @override\n     * @private\n     */\n    _load: function (dataPoint) {\n        var self = this;\n\n        let count = 0;\n        const domainMapping = {};\n        if (this.useSampleModel) {\n            // force to do a read_group RPC without domain to determine if there is data to display\n            domainMapping['[]'] = [];\n        }\n        var fieldsInfo = dataPoint.fieldsInfo.dashboard;\n        _.each(dataPoint.aggregates, function (aggregateName) {\n            var domain = fieldsInfo[aggregateName].domain;\n            if (domain in domainMapping) {\n                domainMapping[domain].push(aggregateName);\n            } else {\n                domainMapping[domain] = [aggregateName];\n            }\n        });\n\n        var defs = [];\n        _.each(domainMapping, function (aggregateNames, domain) {\n            var fields = _.map(aggregateNames, function (aggregateName) {\n                var fieldName = fieldsInfo[aggregateName].field;\n                var groupOperator = fieldsInfo[aggregateName].group_operator;\n                return aggregateName + ':' + groupOperator + '(' + fieldName + ')';\n            });\n\n            defs.push(self._readGroup({\n                domain: self._getReadGroupDomain(domain, self.dataPoint.timeRange),\n                fields: fields,\n            }).then(function (result) {\n                count = count + (domain === '[]' ? result.__count : 0);\n                _.extend(self.dataPoint.data, _.pick(result, aggregateNames));\n            }));\n            if (dataPoint.compare) {\n                defs.push(self._readGroup({\n                    domain: self._getReadGroupDomain(domain, self.dataPoint.comparisonTimeRange),\n                    fields: fields,\n                }).then(function (result) {\n                    count = count + (domain === '[]' ? result.__count : 0);\n                    _.extend(self.dataPoint.comparisonData, _.pick(result, aggregateNames));\n                }));\n            }\n        });\n\n        return Promise.all(defs).then(function () {\n            self.dataPoint.count = count;\n            self._evaluateFormulas(dataPoint);\n            if (dataPoint.compare) {\n                var value, comparisonValue;\n                for (var statisticName in dataPoint.data) {\n                    value = dataPoint.data[statisticName];\n                    comparisonValue = dataPoint.comparisonData[statisticName];\n                    dataPoint.variationData[statisticName] = computeVariation(value, comparisonValue);\n                }\n            } else {\n                dataPoint.comparisonData = {};\n                dataPoint.variationData = {};\n            }\n            return dataPoint.id;\n        });\n    },\n    /**\n     * @override\n     * @private\n     */\n    _makeDataPoint: function (params) {\n        var dataPoint = this._super.apply(this, arguments);\n        dataPoint.aggregates = params.aggregates;\n        dataPoint.count = 0;\n        dataPoint.formulas = params.formulas;\n        dataPoint.comparisonData = {};\n        dataPoint.variationData = {};\n        this._processTimeRanges(dataPoint, params.timeRanges);\n        return dataPoint;\n    },\n    /**\n     * @param  {Object} args\n     * @returns {Promise}\n     */\n    _readGroup: function (args) {\n        var readGroupArgs = _.extend({\n            context: this.dataPoint.getContext(),\n            groupBy: [],\n            lazy: true,\n            method: 'read_group',\n            model: this.dataPoint.model,\n            orderBy: [],\n        }, args);\n        return this._rpc(readGroupArgs).then(function (result) {\n            result = result[0];\n            return _.mapObject(result, function (value) {\n                return value || 0;\n            });\n        });\n    },\n    _processTimeRanges: function (dataPoint, timeRanges) {\n        const { range, comparisonRange } = timeRanges;\n        dataPoint.timeRanges = timeRanges;\n        dataPoint.timeRange = range || [];\n        dataPoint.comparisonTimeRange = comparisonRange || [];\n        dataPoint.compare = Boolean(dataPoint.comparisonTimeRange.length);\n    },\n});\n\nreturn DashboardModel;\n\n});\n", "odoo.define(\"web_dashboard/static/src/js/dashboard_model_extension.js\", function (require) {\n    \"use strict\";\n\n    const ActionModel = require(\"web.ActionModel\");\n\n    const DASHBOARD_FACET_ID = \"dashboard\";\n\n    class DashboardModelExtension extends ActionModel.Extension {\n\n        //---------------------------------------------------------------------\n        // Public\n        //---------------------------------------------------------------------\n\n        /**\n         * @override\n         */\n        prepareState() {\n            this.state.domain = null;\n            this.state.facets = null;\n        }\n\n        /**\n         * @override\n         * @returns {any}\n         */\n        get(property) {\n            switch (property) {\n                case \"domain\": return this.getDomain();\n                case \"facets\": return this.getFacets();\n            }\n        }\n\n        //---------------------------------------------------------------------\n        // Actions / Getters\n        //---------------------------------------------------------------------\n\n        /**\n         * Removes the dashboard group facet if the right ID is given.\n         * @param {number | string} groupId\n         */\n        deactivateGroup(groupId) {\n            if (groupId === DASHBOARD_FACET_ID) {\n                this.state.domain = null;\n                this.state.facets = null;\n            }\n        }\n\n        /**\n         * Returns the current dashboard domain.\n         * @returns {Array[] | null}\n         */\n        getDomain() {\n            return this.state.domain;\n        }\n\n        /**\n         * Returns the current dashboard facet.\n         * @returns {Object | null}\n         */\n        getFacets() {\n            return this.state.facets;\n        }\n\n        /**\n         * Updates the current dashboard domain and creates a facet based on\n         * the given label.\n         * @param {Object} params\n         * @param {Array[]} params.domain\n         * @param {string} params.label\n         */\n        updateDashboardDomain({ domain, label }) {\n            this.state.domain = domain || null;\n            if (domain) {\n                const facet = {\n                    groupId: DASHBOARD_FACET_ID,\n                    type: \"filter\",\n                    values: [label],\n                };\n                this.state.facets = [facet];\n            } else {\n                this.state.facets = null;\n            }\n        }\n    }\n\n    ActionModel.registry.add(\"Dashboard\", DashboardModelExtension, 50);\n});\n", "odoo.define('web_dashboard.DashboardRenderer', function (require) {\n\"use strict\";\n\nvar config = require('web.config');\nvar core = require('web.core');\nvar dataComparisonUtils = require('web.dataComparisonUtils');\nvar Domain = require('web.Domain');\nvar fieldUtils = require('web.field_utils');\nvar FormRenderer = require('web.FormRenderer');\nvar pyUtils = require('web.py_utils');\nvar viewRegistry = require('web.view_registry');\n\nvar renderComparison = dataComparisonUtils.renderComparison;\nvar renderVariation = dataComparisonUtils.renderVariation;\n\nvar QWeb = core.qweb;\n\nvar DashboardRenderer = FormRenderer.extend({\n    className: \"o_legacy_dashboard_view\",\n    sampleDataTargets: ['.o_subview', '.o_group'],\n    events: {\n        'click .o_aggregate.o_clickable': '_onAggregateClicked',\n    },\n    // override the defaul col attribute for groups as in the dashbard view,\n    // labels and fields are displayed vertically, thus allowing to display\n    // more fields on the same line\n    OUTER_GROUP_COL: 6,\n\n    /**\n     * @override\n     */\n    init: function (parent, state, params) {\n        this._super.apply(this, arguments);\n        this.mode = 'readonly';\n        this.subFieldsViews = params.subFieldsViews;\n        this.subViewRefs = params.subViewRefs;\n        this.additionalMeasures = params.additionalMeasures;\n        this.subControllers = {};\n        this.subControllersContext = _.pick(state.context || {}, 'pivot', 'graph', 'cohort');\n        this.subcontrollersNextMeasures = {pivot: {}, graph: {}, cohort: {}};\n        var session = this.getSession();\n        var currency_id = session.company_currency_id;\n        if (session.companies_currency_id && session.user_context.allowed_company_ids) {\n            currency_id = session.companies_currency_id[session.user_context.allowed_company_ids[0]];\n        }\n        this.formatOptions = {\n            // in the dashboard view, all monetary values are displayed in the\n            // currency of the current company of the user\n            currency_id: currency_id,\n            // allow to decide if utils.human_number should be used\n            humanReadable: function (value) {\n                return Math.abs(value) >= 1000;\n            },\n            // with the choices below, 1236 is represented by 1.24k\n            minDigits: 1,\n            decimals: 2,\n            // avoid comma separators for thousands in numbers when human_number is used\n            formatterCallback: function (str) {\n                return str;\n            }\n        };\n    },\n    /**\n     * @override\n     */\n    on_attach_callback: function () {\n        this._super.apply(this, arguments);\n        this.isInDOM = true;\n        _.invoke(this.subControllers, 'on_attach_callback');\n    },\n    /**\n     * @override\n     */\n    on_detach_callback: function () {\n        this._super.apply(this, arguments);\n        this.isInDOM = false;\n    },\n\n    //--------------------------------------------------------------------------\n    // Public\n    //--------------------------------------------------------------------------\n\n    /**\n     * Returns a dict containing the context of sub views.\n     *\n     * @returns {Object}\n     */\n    getsubControllersContext: function () {\n        return _.mapObject(this.subControllers, function (controller) {\n            // for now the views embedded in a dashboard can be of type\n            // cohort, graph, pivot. The getOwnedQueryParams method of their controller\n            // does not export anything but a context.\n            return controller.getOwnedQueryParams().context;\n        });\n    },\n    /**\n     * Overrides to update the context of sub controllers.\n     *\n     * @override\n     */\n    updateState: function (state, params) {\n        var viewType;\n        for (viewType in this.subControllers) {\n            this.subControllersContext[viewType] = this.subControllers[viewType].getOwnedQueryParams().context;\n        }\n        var subControllersContext = _.pick(params.context || {}, 'pivot', 'graph', 'cohort');\n        _.extend(this.subControllersContext, subControllersContext);\n        for (viewType in this.subControllers) {\n            _.extend(this.subControllersContext[viewType], this.subcontrollersNextMeasures[viewType]);\n            this.subcontrollersNextMeasures[viewType] = {};\n        }\n        return this._super.apply(this, arguments);\n    },\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    /**\n     * Add a tooltip on a $node.\n     * The message can be customize using the tooltip attribute\n     *\n     * @param {FieldWidget} widget\n     * @param {$node} $node\n     */\n    _addStatisticTooltip: function ($el, node) {\n        $el.tooltip({\n            delay: { show: 1000, hide: 0 },\n            title: function () {\n                return QWeb.render('web_dashboard.LegacyStatisticTooltip', {\n                    debug: config.isDebug(),\n                    node: node,\n                });\n            }\n        });\n    },\n\n    /**\n     * Renders an aggregate (or formula)'s label.\n     *\n     * @private\n     * @param {Object} node\n     * @returns {jQueryElement}\n     */\n    _renderLabel: function (node) {\n        var text = node.attrs.name;\n        if ('string' in node.attrs) { // allow empty string\n            text = node.attrs.string;\n        }\n        var $result = $('<label>', {text: text});\n        return $result;\n    },\n    /**\n     * Renders a statistic (from an aggregate or a formula) with its label.\n     * If a widget attribute is specified, and if there is no corresponding\n     * formatter, instanciates a widget to render the value. Otherwise, simply\n     * uses the corresponding formatter (with a fallback on the field's type).\n     *\n     * @private\n     * @param {Object} node\n     * @returns {jQueryElement}\n     */\n    _renderStatistic: function (node) {\n        var self = this;\n        var $label = this._renderLabel(node);\n\n        var $el = $('<div>')\n            .attr('name', node.attrs.name)\n            .append($label);\n        var $value;\n        var statisticName = node.attrs.name;\n        var variation;\n        var formatter;\n        var statistic = self.state.fieldsInfo.dashboard[statisticName];\n        var valueLabel =  statistic.value_label ? (' ' + statistic.value_label) : '';\n        if (!node.attrs.widget || (node.attrs.widget in fieldUtils.format)) {\n            // use a formatter to render the value if there exists one for the\n            // specified widget attribute, or there is no widget attribute\n            var fieldValue = self.state.data[statisticName];\n            fieldValue = _.contains(['date', 'datetime'], statistic.type) ? (fieldValue === 0 ? NaN : moment(fieldValue)) : fieldValue;\n            var formatType = node.attrs.widget || statistic.type;\n            formatter = fieldUtils.format[formatType];\n            if (this.state.compare) {\n                var comparisonValue = this.state.comparisonData[statisticName];\n                comparisonValue = _.contains(['date', 'datetime'], statistic.type) ? (comparisonValue === 0 ? NaN : moment(comparisonValue)) : comparisonValue;\n                variation = this.state.variationData[statisticName];\n                renderComparison($el, fieldValue, comparisonValue, variation, formatter, statistic, this.formatOptions);\n                $('.o_comparison', $el).append(valueLabel);\n\n            } else {\n                fieldValue = isNaN(fieldValue) ? '-' : formatter(fieldValue, statistic, this.formatOptions);\n                $value = $('<div>', {class: 'o_value'}).html(fieldValue + valueLabel);\n                $el.append($value);\n            }\n        } else {\n            if (this.state.compare) {\n                // use fakeState here too (to change domain)?\n                var $originalValue = this._renderFieldWidget(node, this.state);\n                var fakeState = _.clone(this.state);\n                fakeState.data = fakeState.comparisonData;\n                var $comparisonValue = this._renderFieldWidget(node, fakeState);\n                variation = this.state.variationData[statisticName];\n                fakeState.data[statisticName] = variation;\n\n                $el\n                .append(renderVariation(variation, statistic))\n                .append($('<div>', {class: 'o_comparison'}).append(\n                    $originalValue,\n                    $('<span>').html(\" vs \"),\n                    $comparisonValue\n                ));\n            } else {\n                // instantiate a widget to render the value if there is no formatter\n                $value = this._renderFieldWidget(node, this.state).addClass('o_value');\n                $el.append($value);\n            }\n        }\n\n        // customize border left\n        if (variation) {\n            if (variation > 0) {\n                $el.addClass('border-success');\n            } else if (variation < 0) {\n                $el.addClass('border-danger');\n            }\n        }\n\n        this._registerModifiers(node, this.state, $el);\n        if (config.isDebug() || node.attrs.help) {\n            this._addStatisticTooltip($el, node);\n        }\n        return $el;\n    },\n    /**\n     * Renders the buttons of a given sub view, with an additional button to\n     * open the view in full screen.\n     *\n     * @private\n     */\n    _renderSubViewButtons: async function ($el, controller) {\n        var $buttons = $('<div>', {class: 'o_' + controller.viewType + '_buttons o_dashboard_subview_buttons'});\n\n        // render the view's buttons\n        controller.renderButtons($buttons);\n\n        // we create a button's group, get the primary button(s)\n        // and put it/them into this group\n        var $buttonGroup = $('<div class=\"btn-group\">');\n        $buttonGroup.append($buttons.find('[aria-label=\"Main actions\"]'));\n        $buttonGroup.append($buttons.find('.dropdown:has(.o_group_by_menu)'));\n        $buttonGroup.prependTo($buttons);\n\n        // render the button to open the view in full screen\n        $('<button>')\n            .addClass(\"btn btn-outline-secondary fa fa-arrows-alt float-right o_button_switch\")\n            .attr({title: 'Full Screen View', viewType: controller.viewType})\n            .tooltip()\n            .on('click', this._onViewSwitcherClicked.bind(this))\n            .appendTo($buttons);\n\n        // select primary and interval buttons and alter their style\n        $buttons.find('.btn-primary,.btn-secondary')\n            .removeClass('btn-primary btn-secondary')\n            .addClass(\"btn-outline-secondary\");\n        $buttons.find('[class*=interval_button]').addClass('text-muted text-capitalize');\n        // remove bars icon on \"Group by\" button\n        $buttons.find('.fa.fa-bars').removeClass('fa fa-bars');\n\n        $buttons.prependTo($el);\n\n        return controller.updateButtons();\n    },\n    /**\n     * @private\n     * @param {Object} node\n     * @returns {jQueryElement}\n     */\n    _renderTagAggregate: function (node) {\n        var $aggregate = this._renderStatistic(node).addClass('o_aggregate');\n        var isClickable = node.attrs.clickable === undefined || pyUtils.py_eval(node.attrs.clickable);\n        $aggregate.toggleClass('o_clickable', isClickable);\n\n        var $result = $('<div>').addClass('o_aggregate_col').append($aggregate);\n        this._registerModifiers(node, this.state, $result);\n        return $result;\n    },\n    /**\n     * @private\n     * @param {Object} node\n     * @returns {jQueryElement}\n     */\n    _renderTagFormula: function (node) {\n        return this._renderStatistic(node).addClass('o_formula');\n    },\n    /**\n     * In the dashboard, both inner and outer groups are rendered the same way:\n     * with a div (no table), i.e. like the outer group of the form view.\n     *\n     * @override\n     * @private\n     */\n    _renderTagGroup: function (node) {\n        var $group = this._renderOuterGroup(node);\n        if (node.children.length && node.children[0].tag === 'widget') {\n            $group.addClass('o_has_widget');\n        }\n        return $group;\n    },\n    /**\n     * Handles nodes with tagname 'view': instanciates the requested view,\n     * renders its buttons and returns a jQuery element containing the buttons\n     * and the controller's $el.\n     *\n     * @private\n     * @param {Object} node\n     * @returns {jQueryElement}\n     */\n    _renderTagView: function (node) {\n        var self = this;\n        var viewType = node.attrs.type;\n        var controllerContext = this.subControllersContext[viewType];\n        var searchQuery = {\n            context: _.extend({}, this.state.context, controllerContext),\n            domain: this.state.domain,\n            groupBy: [],\n            timeRanges: this.state.timeRanges,\n        };\n        var subViewParams = {\n            modelName: this.state.model,\n            withControlPanel: false,\n            withSearchPanel: false,\n            hasSwitchButton: true,\n            isEmbedded: true,\n            additionalMeasures: this.additionalMeasures,\n            searchQuery: searchQuery,\n            useSampleModel: Boolean(this.state.isSample),\n        };\n        var SubView = viewRegistry.get(viewType);\n        var subView = new SubView(this.subFieldsViews[viewType], subViewParams);\n        var $div = $('<div>', {class: 'o_subview', type: viewType});\n        var def = subView.getController(this).then(function (controller) {\n            return controller.appendTo($div).then(function () {\n                return self._renderSubViewButtons($div, controller).then(() => {\n                    self.subControllers[viewType] = controller;\n                });\n            });\n        });\n        this.defs.push(def);\n        return $div;\n    },\n    /**\n     * Overrides to destroy potentially previously instantiates sub views, and\n     * to call 'on_attach_callback' on the new sub views and the widgets if the\n     * dashboard is already in the DOM when being rendered.\n     *\n     * @override\n     * @private\n     */\n    _renderView: function () {\n        var self = this;\n        var oldControllers = _.values(this.subControllers);\n        var r = this._super.apply(this, arguments);\n        return r.then(function () {\n            _.invoke(oldControllers, 'destroy');\n            if (self.isInDOM) {\n                _.invoke(self.subControllers, 'on_attach_callback');\n            }\n            if (self.state.isSample) {\n                self._renderNoContentHelper();\n            }\n        });\n    },\n    /**\n     * Overrides to get rid of the FormRenderer logic about fields, as there is\n     * no field tag in the dashboard view. Simply updates the renderer's $el.\n     *\n     * @private\n     * @override\n     */\n    _updateView: function ($newContent) {\n        this.$el.html($newContent);\n    },\n\n    //--------------------------------------------------------------------------\n    // Handlers\n    //--------------------------------------------------------------------------\n\n    /**\n     * Handles the click on a measure (i.e. a real field of the model, not a\n     * formula). Activates this measure on subviews, and if there is a domain\n     * specified, activates this domain on the whole dashboard.\n     *\n     * @private\n     * @param {MouseEvent} ev\n     */\n    _onAggregateClicked: function (ev) {\n        // update the measure(s) of potential graph and pivot subcontrollers\n        // (this doesn't trigger a reload, it only updates the internal state\n        // of those controllers)\n        var aggregate = ev.currentTarget.getAttribute('name');\n        var aggregateInfo = this.state.fieldsInfo.dashboard[aggregate];\n        var measure = aggregateInfo.measure !== undefined ? aggregateInfo.measure : aggregateInfo.field;\n        if (this.subControllers.pivot) {\n            this.subcontrollersNextMeasures.pivot.pivot_measures = [measure];\n        }\n        if (this.subControllers.graph) {\n            this.subcontrollersNextMeasures.graph.graph_measure = measure;\n        }\n        if (this.subControllers.cohort) {\n            this.subcontrollersNextMeasures.cohort.cohort_measure = measure;\n        }\n        // update the domain and trigger a reload\n        var domain = new Domain(aggregateInfo.domain);\n        // I don't know if it is a good idea to use this.state.fields[measure].string\n        var label = aggregateInfo.domain_label || aggregateInfo.string || aggregateInfo.name;\n        this.trigger_up('reload', {\n            domain: domain.toArray(),\n            domainLabel: label,\n        });\n    },\n    /**\n     * Sends a request to open the given view in full screen.\n     *\n     * @todo; take the current domain into account, once it will be correctly\n     * propagated to subviews\n     * @private\n     * @param {MouseEvent} ev\n     */\n    _onViewSwitcherClicked: function (ev) {\n        ev.stopPropagation();\n        var viewType = $(ev.currentTarget).attr('viewType');\n        var controller = this.subControllers[viewType];\n        // For now the views embedded in a dashboard can be of type cohort, graph, pivot. The\n        // getOwnedQueryParams method of their controller does not export anything but a context.\n        const controllerContext = controller.getOwnedQueryParams().context;\n        this.trigger_up('open_view', {\n            context: Object.assign({}, this.state.context, controllerContext, this.subViewRefs),\n            viewType: viewType,\n            additionalMeasures: this.additionalMeasures,\n        });\n    },\n});\n\nreturn DashboardRenderer;\n\n});\n", "odoo.define('web_dashboard.DashboardView', function (require) {\n\"use strict\";\n\n/**\n * This file defines the Dashboard view and adds it to the view registry. This\n * is a reporting that can embed graph and/or pivot views, and displays\n * aggregate values (obtained from read_group RPCs). It is based on the FormView\n * (extensions of FormRenderer, BasicView and BasicModel).\n */\n\nvar BasicView = require('web.BasicView');\nvar core = require('web.core');\nvar viewRegistry = require('web.view_registry');\n\nvar DashboardController = require('web_dashboard.DashboardController');\nvar DashboardModel = require('web_dashboard.DashboardModel');\nvar DashboardRenderer = require('web_dashboard.DashboardRenderer');\n\nvar _lt = core._lt;\n\nvar DashboardView = BasicView.extend({\n    config: _.extend({}, BasicView.prototype.config, {\n        Model: DashboardModel,\n        Controller: DashboardController,\n        Renderer: DashboardRenderer,\n    }),\n    display_name: _lt('Dashboard'),\n    searchMenuTypes: ['filter', 'comparison', 'favorite'],\n    icon: 'fa-tachometer',\n    viewType: 'dashboard',\n\n    /**\n     * @override\n     */\n\tinit: function (viewInfo, params) {\n        this._super.apply(this, arguments);\n        this.modelName = params.modelName;\n\n        this.controllerParams.actionDomain = (params.action && params.action.domain) || [];\n\n        this.rendererParams.subFieldsViews = {};\n\n        // pass all measurable fields to subviews\n        var fields = this.fieldsInfo.dashboard;\n        const additionalMeasures = [];\n        for (const f of Object.values(fields)) {\n            if (f.realType === \"many2one\" && !f.invisible) {\n                additionalMeasures.push(f.field);\n            }\n        }\n        this.rendererParams.additionalMeasures = additionalMeasures;\n\n        // generate sub view refs to add in the context to fetch the adequate views\n        this.subViewRefs = {};\n        _.each(this.fieldsView.subViews, subView => {\n            if (subView[0]) {\n                this.subViewRefs[subView[1] + '_view_ref'] = subView[0];\n            }\n        });\n        this.rendererParams.subViewRefs = this.subViewRefs;\n\n        // replaces the xmlids by false in the views description\n        this.fieldsView.subViews = _.map(this.fieldsView.subViews, function (subView) {\n            return [false, subView[1]]; // e.g. [false, 'graph']\n        });\n\n        this.loadParams.aggregates = this.fieldsView.aggregates;\n        this.loadParams.formulas = this.fieldsView.formulas;\n\n\t},\n\n    //--------------------------------------------------------------------------\n    // Private\n    //--------------------------------------------------------------------------\n\n    /**\n     * @override\n     */\n    _createSearchModel(params, extraExtensions = {}) {\n        Object.assign(extraExtensions, { Dashboard: {} });\n        return this._super(params, extraExtensions);\n    },\n\n    /**\n     * Overrides to fetch the fieldsView of subviews.\n     *\n     * @override\n     * @private\n     */\n    _loadData: function (model) {\n        var self = this;\n\n        var subViewsDef;\n        if (this.fieldsView.subViews.length) {\n            const context = Object.assign({}, this.subViewRefs, this.loadParams.context);\n            subViewsDef = model\n                .loadViews(this.modelName, context, this.fieldsView.subViews)\n                .then(function (fieldsViews) {\n                    for (var viewType in fieldsViews) {\n                        self.rendererParams.subFieldsViews[viewType] = fieldsViews[viewType];\n                    }\n                });\n        }\n\n        var superDef = this._super.apply(this, arguments);\n        return Promise.all([superDef, subViewsDef]).then(function (results) {\n            // the parent expects a promise resolved with an Object of the form\n            // { state, handle }, but with this override, it becomes a promise\n            // resolved with an Array, whose first element is the wanted object.\n            return results[0];\n        });\n    },\n    /**\n     * Processes nodes with tagName 'aggregate'. Same API as _processNode.\n     *\n     * @private\n     * @param {Object} node\n     * @param {Object} fv\n     * @returns {boolean}\n     */\n    _processAggregateNode: function (node, fv) {\n        var aggregateID = node.attrs.name;\n        var field = fv.viewFields[node.attrs.field];\n\n        var aggregate = _.defaults({}, node.attrs, {\n            domain: '[]',\n            group_operator: field.group_operator,\n        });\n        aggregate.Widget = this._getFieldWidgetClass('dashboard', field, aggregate);\n\n        // in the dashboard views, many2one fields are fetched with the\n        // group_operator 'count_distinct', which means that the values\n        // manipulated client side for these fields are integers\n        if (field.type === 'many2one') {\n            field.type = 'integer';\n            field.realType = 'many2one';\n            aggregate.realType = 'many2one';\n            aggregate.group_operator = 'count_distinct';\n        }\n        aggregate.type = field.type;\n\n        fv.fieldsInfo.dashboard[aggregateID] = aggregate;\n        fv.viewFields[node.attrs.name] = _.extend({}, field, {\n            name: node.attrs.name,\n        });\n        fv.aggregates.push(aggregateID);\n        return false;\n    },\n    /**\n     * In the dashboard view, additional tagnames are allowed: 'view', 'formula'\n     * and 'aggregate'. We override the processing of the arch to gather\n     * information about the occurrences of these tagnames in the arch.\n     *\n     * @override\n     * @private\n     */\n    _processArch: function (arch, fv) {\n        fv.aggregates = [];\n        fv.formulas = {};\n        fv.subViews = [];\n        // there are no field nodes in the dashboard arch, so viewFields is\n        // basically a shallow copy of fields, which is the dict shared between\n        // all views, and which is thus (deeply) frozen ; we here deeply clone\n        // it so that we can change (in place) the type of many2one fields into\n        // integer.\n        fv.viewFields = $.extend(true, {}, fv.viewFields);\n        this._super.apply(this, arguments);\n    },\n    /**\n     * Processes nodes with tagName 'formula'. Same API as _processNode.\n     *\n     * @private\n     * @param {Object} node\n     * @param {Object} fv\n     * @returns {boolean}\n     */\n    _processFormulaNode: function (node, fv) {\n        var formulaID = node.attrs.name || _.uniqueId('formula_');\n        node.attrs.name = formulaID;\n\n        var formula = _.extend({}, node.attrs, {type: 'float'});\n        var fakeField = {name: formulaID, type: 'float'};\n        formula.Widget = this._getFieldWidgetClass('dashboard', fakeField, formula);\n\n        fv.fieldsInfo.dashboard[formulaID] = formula;\n        fv.viewFields[formulaID] = fakeField;\n        fv.formulas[formulaID] = _.pick(node.attrs, 'string', 'value');\n        return false;\n    },\n    /**\n     * Overrides to handle nodes with tagname 'aggregate', 'formula' and 'view'.\n     *\n     * @override\n     * @private\n     */\n    _processNode: function (node, fv) {\n        var res = this._super.apply(this, arguments);\n\n        if (node.tag === 'aggregate') {\n            res = this._processAggregateNode(node, fv);\n        }\n        if (node.tag === 'formula') {\n            res = this._processFormulaNode(node, fv);\n        }\n        if (node.tag === 'view') {\n            fv.subViews.push([node.attrs.ref, node.attrs.type]);\n            res = false;\n        }\n\n        return res;\n    },\n});\n\nviewRegistry.add('dashboard', DashboardView);\n\nreturn DashboardView;\n\n});\n"], "file": "/web/assets/99-b4a8124/web.assets_backend_legacy_lazy.js", "sourceRoot": "../../../"}